<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This document describes the libraries distributed along with version
0.4d1 of Vicare Scheme, an R6RS compliant native
compiler for the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library (vicare formations) is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

The documentation of the libraries (vicare parser-tools silex
-) are derived form the documentation of SILex.  Copyright
(C) 2001, 2009 Danny Dube'.

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License version 3 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see
http://www.gnu.org/licenses/.

Trademarks used herein are the property of their respective owners. -->
<!-- Created by GNU Texinfo 6.3, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Libraries for Vicare Scheme: srfi ralists rationale</title>

<meta name="description" content="Libraries for Vicare Scheme: srfi ralists rationale">
<meta name="keywords" content="Libraries for Vicare Scheme: srfi ralists rationale">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="concept-index.html#concept-index" rel="index" title="concept index">
<link href="srfi-ralists.html#srfi-ralists" rel="up" title="srfi ralists">
<link href="srfi-ralists-spec.html#srfi-ralists-spec" rel="next" title="srfi ralists spec">
<link href="srfi-ralists-issues.html#srfi-ralists-issues" rel="prev" title="srfi ralists issues">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="srfi-ralists-rationale"></a>
<div class="header">
<p>
Next: <a href="srfi-ralists-spec.html#srfi-ralists-spec" accesskey="n" rel="next">srfi ralists spec</a>, Previous: <a href="srfi-ralists-issues.html#srfi-ralists-issues" accesskey="p" rel="prev">srfi ralists issues</a>, Up: <a href="srfi-ralists.html#srfi-ralists" accesskey="u" rel="up">srfi ralists</a> &nbsp; [<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Rationale-30"></a>
<h4 class="subsection">2.33.3 Rationale</h4>


<p>Functional programming and list hacking go together like peanut butter
and jelly, eval and apply, syntax and semantics, or cursing and
recursing.  But the traditional approach to implementing pairs and lists
results in index&ndash;based access (<code>list-ref</code>) requiring time
proportional the index being accessed.  Moreover, indexed&ndash;based
functional update (<code>list-set</code>) becomes so inefficient as to be
nearly unspeakable.  Instead, programmers revert the imperatives of the
state; they use a stateful data structure and imperative algorithms.
</p>
<p>This <acronym>SRFI</acronym> intends to improve the situation by offering an alternative
implementation strategy based on Okasaki&rsquo;s purely functional
random&ndash;access lists [1].  Random&ndash;access pairs and lists can be used as
a replacement for traditional, linear&ndash;access pairs and lists with no
asymptotic loss of efficiency.  In other words, the typical list and
pair operations such as <code>cons</code>, <code>car</code>, and <code>cdr</code>, all
operate in <em>O(1)</em> time as usual.  However, random&ndash;access lists
additionally support index&ndash;based access and functional update
operations that are asymptotically cheaper; <em>O(\log(n))</em> for
random&ndash;access lists versus <em>O(n)</em> for linear&ndash;access lists, where
<em>n</em> is the length of the list being access or updated.  As such,
many purely functional index&ndash;based list algorithms become feasible by
using a random&ndash;access list representation for pairs and lists.
</p>
<p>The requirements of this <acronym>SRFI</acronym> have been designed in such a way as to
admit portable library implementations of this feature, such as the
reference implementation, while at the same time admit more radical
implementations that embrace random&ndash;access pairs as the fundamental
pair representation.
</p>



</body>
</html>
