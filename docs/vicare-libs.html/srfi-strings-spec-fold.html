<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This document describes the libraries distributed along with version
0.4d1 of Vicare Scheme, an R6RS compliant native
compiler for the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library (vicare formations) is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

The documentation of the libraries (vicare parser-tools silex
-) are derived form the documentation of SILex.  Copyright
(C) 2001, 2009 Danny Dube'.

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License version 3 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see
http://www.gnu.org/licenses/.

Trademarks used herein are the property of their respective owners. -->
<!-- Created by GNU Texinfo 6.3, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Libraries for Vicare Scheme: srfi strings spec fold</title>

<meta name="description" content="Libraries for Vicare Scheme: srfi strings spec fold">
<meta name="keywords" content="Libraries for Vicare Scheme: srfi strings spec fold">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="concept-index.html#concept-index" rel="index" title="concept index">
<link href="srfi-strings-spec.html#srfi-strings-spec" rel="up" title="srfi strings spec">
<link href="srfi-strings-spec-replicate.html#srfi-strings-spec-replicate" rel="next" title="srfi strings spec replicate">
<link href="srfi-strings-spec-append.html#srfi-strings-spec-append" rel="prev" title="srfi strings spec append">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="srfi-strings-spec-fold"></a>
<div class="header">
<p>
Next: <a href="srfi-strings-spec-replicate.html#srfi-strings-spec-replicate" accesskey="n" rel="next">srfi strings spec replicate</a>, Previous: <a href="srfi-strings-spec-append.html#srfi-strings-spec-append" accesskey="p" rel="prev">srfi strings spec append</a>, Up: <a href="srfi-strings-spec.html#srfi-strings-spec" accesskey="u" rel="up">srfi strings spec</a> &nbsp; [<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Fold_002c-unfold-and-map-1"></a>
<h4 class="subsubsection">2.8.3.12 Fold, unfold and map</h4>


<dl>
<dt><a name="index-string_002dmap"></a>Function: <strong>string-map</strong> <em><var>proc</var> <var>str</var></em></dt>
<dt><a name="index-string_002dmap-1"></a>Function: <strong>string-map</strong> <em><var>proc</var> <var>str</var> <var>start</var></em></dt>
<dt><a name="index-string_002dmap-2"></a>Function: <strong>string-map</strong> <em><var>proc</var> <var>str</var> <var>start</var> <var>end</var></em></dt>
<dd><p><var>proc</var> is a char&ndash;to&ndash;char procedure and it is mapped over the
selected substring of <var>str</var>; return the result string and does not
alter its <var>str</var> parameter.
</p>
<blockquote>
<p><strong>NOTE</strong> The order in which <var>proc</var> is applied to the elements
of <var>str</var> is not specified.
</p></blockquote>
</dd></dl>


<dl>
<dt><a name="index-string_002dmap_0021"></a>Function: <strong>string-map!</strong> <em><var>proc</var> <var>str</var></em></dt>
<dt><a name="index-string_002dmap_0021-1"></a>Function: <strong>string-map!</strong> <em><var>proc</var> <var>str</var> <var>start</var></em></dt>
<dt><a name="index-string_002dmap_0021-2"></a>Function: <strong>string-map!</strong> <em><var>proc</var> <var>str</var> <var>start</var> <var>end</var></em></dt>
<dd><p>In&ndash;place side&ndash;effecting variant.
</p></dd></dl>


<dl>
<dt><a name="index-string_002dfor_002deach"></a>Function: <strong>string-for-each</strong> <em><var>proc</var> <var>str</var></em></dt>
<dt><a name="index-string_002dfor_002deach-1"></a>Function: <strong>string-for-each</strong> <em><var>proc</var> <var>str</var> <var>start</var></em></dt>
<dt><a name="index-string_002dfor_002deach-2"></a>Function: <strong>string-for-each</strong> <em><var>proc</var> <var>str</var> <var>start</var> <var>end</var></em></dt>
<dd><p>Apply <var>proc</var> to each character in <var>str</var> from start to end in
increasing order.  Return unspecified values.
</p></dd></dl>


<dl>
<dt><a name="index-string_002dfor_002deach_002dindex"></a>Function: <strong>string-for-each-index</strong> <em><var>proc</var> <var>str</var></em></dt>
<dt><a name="index-string_002dfor_002deach_002dindex-1"></a>Function: <strong>string-for-each-index</strong> <em><var>proc</var> <var>str</var> <var>start</var></em></dt>
<dt><a name="index-string_002dfor_002deach_002dindex-2"></a>Function: <strong>string-for-each-index</strong> <em><var>proc</var> <var>str</var> <var>start</var> <var>end</var></em></dt>
<dd><p>Apply <var>proc</var> to each index of the selected substring of <var>str</var>,
in increasing order from start to end.  This is simply a method of
looping over a string that is guaranteed to be safe and correct.
Example:
</p>
<div class="example">
<pre class="example">(let* ((len (string-length s))
       (ans (make-string len)))
  (string-for-each-index
    (lambda (i)
      (string-set! ans (- len i) (string-ref s i)))
    s)
  ans)
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-string_002dfold"></a>Function: <strong>string-fold</strong> <em><var>kons</var> <var>knil</var> <var>str</var></em></dt>
<dt><a name="index-string_002dfold-1"></a>Function: <strong>string-fold</strong> <em><var>kons</var> <var>knil</var> <var>str</var> <var>start</var></em></dt>
<dt><a name="index-string_002dfold-2"></a>Function: <strong>string-fold</strong> <em><var>kons</var> <var>knil</var> <var>str</var> <var>start</var> <var>end</var></em></dt>
<dt><a name="index-string_002dfold_002dright"></a>Function: <strong>string-fold-right</strong> <em><var>kons</var> <var>knil</var> <var>str</var></em></dt>
<dt><a name="index-string_002dfold_002dright-1"></a>Function: <strong>string-fold-right</strong> <em><var>kons</var> <var>knil</var> <var>str</var> <var>start</var></em></dt>
<dt><a name="index-string_002dfold_002dright-2"></a>Function: <strong>string-fold-right</strong> <em><var>kons</var> <var>knil</var> <var>str</var> <var>start</var> <var>end</var></em></dt>
<dd><p>These are the fundamental iterators for strings.
</p>
<p>The left&ndash;fold operator maps the <var>kons</var> procedure across the string
from left to right:
</p>
<div class="example">
<pre class="example">(... (kons s[2] (kons s[1] (kons s[0] knil))))
</pre></div>

<p>in other words, <code>string-fold</code> obeys the (tail) recursion:
</p>
<div class="example">
<pre class="example">(string-fold kons knil s start end)
&equiv; (string-fold kons (kons s[start] knil) start+1 end)
</pre></div>

<p>The right&ndash;fold operator maps the <var>kons</var> procedure across the string
from right to left:
</p>
<div class="example">
<pre class="example">(kons s[0]
      (... (kons s[end-3]
                 (kons s[end-2]
                       (kons s[end-1] knil)))))
</pre></div>

<p>obeying the (tail) recursion:
</p>
<div class="example">
<pre class="example">(string-fold-right kons knil s start end)
&equiv; (string-fold-right kons (kons s[end-1] knil) start end-1)
</pre></div>

<p>Examples:
</p>
<div class="example">
<pre class="example">;;; Convert a string to a list of chars.
(string-fold-right cons '() s)

;;; Count the number of lower-case characters in a string.
(string-fold (lambda (c count)
               (if (char-lower-case? c)
                   (+ count 1)
                 count))
              0
              s)

;;; Double every backslash character in S.
(let* ((ans-len (string-fold (lambda (c sum)
                               (+ sum (if (char=? c #\\)
                                          2
                                        1)))
                             0 s))
       (ans     (make-string ans-len)))
  (string-fold (lambda (c i)
                 (let ((i (if (char=? c #\\)
                              (begin
                                (string-set! ans i #\\)
                                (+ i 1))
                            i)))
                    (string-set! ans i c)
                    (+ i 1)))
               0 s)
  ans)
</pre></div>

<p>The right&ndash;fold combinator is sometimes called a &ldquo;catamorphism&rdquo;.
</p></dd></dl>


<dl>
<dt><a name="index-string_002dunfold"></a>Function: <strong>string-unfold</strong> <em><var>stop?</var> <var>seed-&gt;char</var> <var>make-seed</var> <var>first-seed</var></em></dt>
<dt><a name="index-string_002dunfold-1"></a>Function: <strong>string-unfold</strong> <em><var>stop?</var> <var>seed-&gt;char</var> <var>make-seed</var> <var>first-seed</var> <var>base-str</var></em></dt>
<dt><a name="index-string_002dunfold-2"></a>Function: <strong>string-unfold</strong> <em><var>stop?</var> <var>seed-&gt;char</var> <var>make-seed</var> <var>first-seed</var> <var>base-str</var> <var>make-final</var></em></dt>
<dd><p>This is a fundamental constructor for strings.
</p>
<dl compact="compact">
<dt><var>make-seed</var></dt>
<dd><p>Is used to generate a series of &ldquo;seed&rdquo; values from the initial seed:
</p>
<div class="example">
<pre class="example"><var>first-seed</var>
(<var>make-seed</var> <var>first-seed</var>)      &rArr; seed2
(<var>make-seed</var> seed2)           &rArr; seed3
(<var>make-seed</var> seed3)           &rArr; seed4
...
</pre></div>

</dd>
<dt><var>stop?</var></dt>
<dd><p>Tells us when to stop; when it returns true when applied to one of the
seed values.
</p>
</dd>
<dt><var>seed-&gt;char</var></dt>
<dd><p>Maps each seed value to the corresponding character in the result
string.  These chars are assembled into the string in a left&ndash;to&ndash;right
order.
</p>
</dd>
<dt><var>base-string</var></dt>
<dd><p>Is the optional initial/leftmost portion of the constructed string; it
defaults to the empty string.
</p>
</dd>
<dt><var>make-final</var></dt>
<dd><p>Is applied to the terminal seed value (on which <var>stop?</var> returns
true) to produce the final/rightmost portion of the constructed string.
It defaults to:
</p>
<div class="example">
<pre class="example">(lambda (x) &quot;&quot;)
</pre></div>
</dd>
</dl>

<p>More precisely, the following (simple, inefficient) definitions hold:
</p>
<div class="example">
<pre class="example">;;; Iterative
(define (string-unfold stop? seed-&gt;char make-seed
                       first-seed base-str make-final)
  (let loop ((seed first-seed)
             (ans  base-str))
    (if (stop? seed)
        (string-append ans (make-final seed))
      (loop (make-seed seed)
            (string-append ans (string (seed-&gt;char seed)))))))

;;; Recursive
(define (string-unfold stop? seed-&gt;char make-seed
                       first-seed base-str make-final)
  (string-append
     base-str
     (let recur ((seed first-seed))
       (if (stop? seed)
           (make-final seed)
         (string-append (string (seed-&gt;char seed))
                        (recur  (make-seed  seed)))))))
</pre></div>

<p><code>string-unfold</code> is a fairly powerful string constructor; we can use
it to convert a list to a string, read a port into a string, reverse a
string, copy a string, and so forth.  Examples:
</p>
<div class="example">
<pre class="example">(port-&gt;string p)
&equiv; (string-unfold eof-object? values
             (lambda (x) (read-char p))
             (read-char p))

(list-&gt;string lis)
&equiv; (string-unfold null? car cdr lis)

(string-tabulate f size)
&equiv; (string-unfold
             (lambda (i) (= i size))
             f add1 0)
</pre></div>

<p>to map <var>seed-&gt;char</var> over a list <var>lis</var>, producing a string:
</p>
<div class="example">
<pre class="example">(string-unfold null? (compose f car) cdr lis)
</pre></div>

<p>Interested functional programmers may enjoy noting that
<code>string-fold-right</code> and <code>string-unfold</code> are in some sense
inverses.  That is, given operations <var>knull?</var>, <var>kar</var>, <var>kdr</var>,
<var>kons</var>, and <var>knil</var> satisfying:
</p>
<div class="example">
<pre class="example">(kons (kar x) (kdr x))  &equiv; x
(knull? knil)           &equiv; #t
</pre></div>

<p>then:
</p>
<div class="example">
<pre class="example">(string-fold-right kons knil
   (string-unfold knull? kar kdr x))
&equiv; x
</pre></div>

<p>and:
</p>
<div class="example">
<pre class="example">(string-unfold knull? kar kdr
   (string-fold-right kons knil s))
&equiv; s
</pre></div>

<p>The final string constructed does not share storage with either
<var>base-str</var> or the value produced by <var>make-final</var>.
</p>
<p>This combinator sometimes is called an &ldquo;anamorphism&rdquo;.
</p></dd></dl>


<dl>
<dt><a name="index-string_002dunfold_002dright"></a>Function: <strong>string-unfold-right</strong> <em><var>stop?</var> <var>seed-&gt;char</var> <var>make-seed</var> <var>first-seed</var></em></dt>
<dt><a name="index-string_002dunfold_002dright-1"></a>Function: <strong>string-unfold-right</strong> <em><var>stop?</var> <var>seed-&gt;char</var> <var>make-seed</var> <var>first-seed</var> <var>base-str</var></em></dt>
<dt><a name="index-string_002dunfold_002dright-2"></a>Function: <strong>string-unfold-right</strong> <em><var>stop?</var> <var>seed-&gt;char</var> <var>make-seed</var> <var>first-seed</var> <var>base-str</var> <var>make-final</var></em></dt>
<dd><p>This is a fundamental constructor for strings.
</p>
<dl compact="compact">
<dt><var>make-seed</var></dt>
<dd><p>Is used to generate a series of &ldquo;seed&rdquo; values from the initial
<var>first-seed</var>:
</p>
<div class="example">
<pre class="example"><var>first-seed</var>
(<var>make-seed</var> <var>first-seed</var>)      &rArr; seed2
(<var>make-seed</var> seed2)           &rArr; seed3
(<var>make-seed</var> seed3)           &rArr; seed4
...
</pre></div>

</dd>
<dt><var>stop?</var></dt>
<dd><p>Tells us when to stop; when it returns true when applied to one of these
seed values.
</p>
</dd>
<dt><var>seed-&gt;char</var></dt>
<dd><p>Maps each seed value to the corresponding character in the result
string.  These chars are assembled into the string in a right&ndash;to&ndash;left
order.
</p>
</dd>
<dt><var>base-str</var></dt>
<dd><p>Is the optional initial/rightmost portion of the constructed string; it
defaults to the empty string.
</p>
</dd>
<dt><var>make-final</var></dt>
<dd><p>Is applied to the terminal seed value (on which <var>stop?</var> returns
true) to produce the final/leftmost portion of the constructed string.
It defaults to:
</p>
<div class="example">
<pre class="example">(lambda (x) &quot;&quot;)
</pre></div>
</dd>
</dl>

<p>More precisely, the following (simple, inefficient) definitions hold:
</p>
<div class="example">
<pre class="example">;;; Iterative
(define (string-unfold-right stop? seed-&gt;char make-seed
                             first-seed base-str make-final)
  (let loop ((seed first-seed)
             (ans  base-str))
    (if (stop? seed)
        (string-append (make-final seed) ans)
      (loop (make-seed seed)
            (string-append (string (seed-&gt;char seed)) ans)))))

;;; Recursive
(define (string-unfold-right stop? seed-&gt;char make-seed
                             first-seed base-str make-final)
  (string-append
     (let recur ((seed first-seed))
       (if (stop? seed)
           (make-final seed)
         (string-append (recur  (make-seed  seed))
                        (string (seed-&gt;char seed)))))
     base-str))
</pre></div>

<p>Interested functional programmers may enjoy noting that
<code>string-fold</code> and <code>string-unfold-right</code> are in some sense
inverses.  That is, given operations <var>knull?</var>, <var>kar</var>, <var>kdr</var>,
<var>kons</var>, and <var>knil</var> satisfying:
</p>
<div class="example">
<pre class="example">(kons (kar x) (kdr x))  &equiv; x
(knull? knil)           &equiv; #t
</pre></div>

<p>then:
</p>
<div class="example">
<pre class="example">(string-fold kons knil
  (string-unfold-right knull? kar kdr x))
&equiv; x
</pre></div>

<p>and:
</p>
<div class="example">
<pre class="example">(string-unfold-right knull? kar kdr
  (string-fold kons knil s))
&equiv; s
</pre></div>

<p>The final string constructed does not share storage with either
<var>base-str</var> or the value produced by <code>make-final</code>.
</p></dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="srfi-strings-spec-replicate.html#srfi-strings-spec-replicate" accesskey="n" rel="next">srfi strings spec replicate</a>, Previous: <a href="srfi-strings-spec-append.html#srfi-strings-spec-append" accesskey="p" rel="prev">srfi strings spec append</a>, Up: <a href="srfi-strings-spec.html#srfi-strings-spec" accesskey="u" rel="up">srfi strings spec</a> &nbsp; [<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
