<html lang="en">
<head>
<title>srfi vector spec intro - Libraries for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Libraries for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="srfi-vector-spec.html#srfi-vector-spec" title="srfi vector spec">
<link rel="next" href="srfi-vector-spec-cons.html#srfi-vector-spec-cons" title="srfi vector spec cons">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes the libraries distributed along with version
0.3d6 of Vicare Scheme, an R6RS compliant native
compiler for the Scheme language.

Copyright (C) 2010-2013 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library `(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

The documentation of the libraries `(vicare parser-tools silex
---)' are derived form the documentation of SILex.  Copyright
(C) 2001, 2009 Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="srfi-vector-spec-intro"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="srfi-vector-spec-cons.html#srfi-vector-spec-cons">srfi vector spec cons</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="srfi-vector-spec.html#srfi-vector-spec">srfi vector spec</a>
<hr>
</div>

<h5 class="subsubsection">2.23.4.1 Introduction</h5>

<p>In this section containing specifications of procedures, the following
notation is used to specify parameters and return values:

     <dl>
<dt><code>(f arg1 arg2 иии) -&gt; something</code><dd>Indicates a function <var>f</var> takes the parameters <var>arg1</var>,
<var>arg2</var>, <small class="dots">...</small> and returns a value of the type <var>something</var>. If
<var>something</var> is unspecified, then what <var>f</var> returns is
implementation&ndash;dependant; this <acronym>SRFI</acronym> does not specify what it
returns, and in order to write portable code, the return value should be
ignored.

     <br><dt><code>vec</code><dd>The argument in this place must be a vector, i.e. it must satisfy the
predicate <code>vector?</code>.

     <br><dt><code>i, j, start, size</code><dd>The argument in this place must be a nonnegative integer, i.e. it must
satisfy the predicates <code>integer?</code> and either <code>zero?</code> or
<code>positive?</code>.  The third case of it indicates the index at which
traversal begins; the fourth case of it indicates the size of a vector.

     <br><dt><code>end</code><dd>The argument in this place must be a positive integer, i.e. it must
satisfy the predicates <code>integer?</code> and <code>positive?</code>.  This
indicates the index directly before which traversal will stop;
processing will occur until the the index of the vector is end.  It is
the closed right side of a range.

     <br><dt><code>f</code><dd>The argument in this place must be a function of one or more arguments,
returning exactly one value.

     <br><dt><code>pred?</code><dd>The argument in this place must be a function of one or more arguments
that returns one value, which is treated as a boolean.

     <br><dt><code>x, y, z, seed, knil, fill, key, value</code><dd>The argument in this place may be any Scheme value.

     <br><dt><code>[something]</code><dd>Indicates that <var>something</var> is an optional argument; it needn't
necessarily be applied.  Something needn't necessarily be one thing; for
example, this usage of it is perfectly valid:

     <pre class="example">          [start [end]]
</pre>
     <p class="noindent">and is indeed used quite often.

     <br><dt><code>something иии</code><dd>Indicates that zero or more somethings are allowed to be arguments.

     <br><dt><code>something1 something2 иии</code><dd>Indicates that at least one something must be arguments.

     <br><dt><code>something1 something2 иии somethingn</code><dd>Exactly equivalent to the previous argument notation, but this also
indicates that <var>n</var> will be used later in the procedure description. 
</dl>

   <p>It should be noted that all of the procedures that iterate across
multiple vectors in parallel stop iterating and produce the final result
when the end of the shortest vector is reached.  The sole exception is
<code>vector=</code>, which automatically returns <code>#f</code> if the vectors'
lengths vary.

<!-- page -->
   </body></html>

