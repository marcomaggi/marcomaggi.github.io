<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This document describes the libraries distributed along with version
0.4d1 of Vicare Scheme, an R6RS compliant native
compiler for the Scheme language.

Copyright (C) 2010-2017 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library (vicare formations) is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

The documentation of the libraries (vicare parser-tools silex
-) are derived form the documentation of SILex.  Copyright
(C) 2001, 2009 Danny Dube'.

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License version 3 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see
http://www.gnu.org/licenses/.

Trademarks used herein are the property of their respective owners. -->
<!-- Created by GNU Texinfo 6.3, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Libraries for Vicare Scheme: parser logic operators</title>

<meta name="description" content="Libraries for Vicare Scheme: parser logic operators">
<meta name="keywords" content="Libraries for Vicare Scheme: parser logic operators">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="concept-index.html#concept-index" rel="index" title="concept index">
<link href="parser-logic.html#parser-logic" rel="up" title="parser logic">
<link href="parser-logic-api.html#parser-logic-api" rel="next" title="parser logic api">
<link href="parser-logic-intro.html#parser-logic-intro" rel="prev" title="parser logic intro">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="parser-logic-operators"></a>
<div class="header">
<p>
Next: <a href="parser-logic-api.html#parser-logic-api" accesskey="n" rel="next">parser logic api</a>, Previous: <a href="parser-logic-intro.html#parser-logic-intro" accesskey="p" rel="prev">parser logic intro</a>, Up: <a href="parser-logic.html#parser-logic" accesskey="u" rel="up">parser logic</a> &nbsp; [<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="The-logic-of-parser-operators"></a>
<h3 class="section">11.2 The logic of parser operators</h3>


<p>After all the macros have been expanded, the parser is a set of
<em>operator functions</em> extracting characters from an input device with
the purpose of producing a token.  Some operators are &ldquo;entry points&rdquo;
to the parser: public functions we can call to start parsing; other
operators are for internal use only.  Each operator is meant to either:
tail&ndash;call another operator, terminate parsing by raising an exception,
terminate parsing by returning an error value, terminate parsing
successfully by returning a token value.
</p>
<blockquote>
<p><strong>NOTE</strong> Operator functions are just ordinary Scheme functions
playing a special role in a parser; they are given a name with the only
purpose of letting us talk about them, and it happens that such name is
&ldquo;operator&rdquo;.
</p></blockquote>

<p>Operators are generated by macros from a symbolic expression specifying
an abstract parser:
</p>
<div class="example">
<pre class="example">(define-parser-logic define-parser ch next fail . <var>?operators</var>)
</pre></div>

<p>and containing a subexpression for each operator.  Access to the input
device is specified by another macro which must implement a set of
<code>syntax-rules</code>:
</p>
<div class="example">
<pre class="example">(define-syntax device-logic
  (syntax-rules (:introduce-device-arguments
                 :generate-end-of-input-or-char-tests
                 :unexpected-end-of-input
                 :generate-delimiter-test
                 :invalid-input-char)
    ((_ :introduce-device-arguments          ---) ---)
    ((_ :generate-end-of-input-or-char-tests ---) ---)
    ((_ :unexpected-end-of-input             ---) ---)
    ((_ :generate-delimiter-test             ---) ---)
    ((_ :invalid-input-char                  ---) ---)))
</pre></div>

<p>Concrete parsers are defined by combining the parser logic with the
device logic:
</p>
<div class="example">
<pre class="example">(define-parser device-logic (<var>?operator-name</var> ...))
</pre></div>

<p>we can define any number of concrete parsers using the same parser logic
and different device logics; at the end of the expansion, the input
device forms are hard coded into the operator.  The list of
<var>?operator-name</var> is a list of identifiers bound to the operators
being entry points to the parser.
</p>
<p>To understand the semantics of operators, let&rsquo;s consider one accepting
only the characters &lsquo;<samp>#\X</samp>&rsquo; or &lsquo;<samp>#\Y</samp>&rsquo; and rejecting the
end&ndash;of-input:
</p>
<div class="example">
<pre class="example">(define (operator-1 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((char=? X ch)
           (a-clause-form))
          ((char=? Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
</pre></div>

<p>such operator would be specified by the following <var>?operator</var>
symbolic subexpression:
</p>
<div class="example">
<pre class="example">(operator-1 (parser-state)
  ((#\X)
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
</pre></div>

<p>notice how the end&ndash;of&ndash;input test is automatically generated.  The
operator has some arguments representing the input device state and
other arguments representing the parser state; the list of input device
arguments comes first and is specified by the device logic, discussed
later; the list of parser state arguments comes last and is specified in
the <var>?operator</var> symbolic expression.
</p>
<p>An operator function accepting characters &lsquo;<samp>#\X</samp>&rsquo;, &lsquo;<samp>#\Y</samp>&rsquo; or
&lsquo;<samp>#\Z</samp>&rsquo;, with &lsquo;<samp>#\Y</samp>&rsquo; and &lsquo;<samp>#\Z</samp>&rsquo; to be processed in the same
way, and rejecting the end&ndash;of-input looks like this:
</p>
<div class="example">
<pre class="example">(define (operator-2 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((or (char=? #\Y ch)
               (char=? #\Z ch))
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
</pre></div>

<p>such operator would be specified by the following <var>?operator</var>
symbolic subexpression:
</p>
<div class="example">
<pre class="example">(operator-2 (parser-state)
  ((#\X)
   (a-clause-form))
  ((#\Y #\Z)
   (another-clause-form)))
</pre></div>

<p>An operator function accepting characters &lsquo;<samp>#\X</samp>&rsquo; or &lsquo;<samp>#\Y</samp>&rsquo;, but
also the end&ndash;of&ndash;input from the device, looks like this:
</p>
<div class="example">
<pre class="example">(define (operator-3 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (end-of-input-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((char=? #\Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
</pre></div>

<p>and is specified in the parser logic as the following <var>?operator</var>
symbolic subexpression:
</p>
<div class="example">
<pre class="example">(operator-3 (parser-state)
  ((:end-of-input)
   (end-of-input-form))
  ((#\X)
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
</pre></div>

<p>An operator function accepting characters &lsquo;<samp>#\X</samp>&rsquo; or &lsquo;<samp>#\Y</samp>&rsquo;, the
end&ndash;of&ndash;input from the device, and also a set of end&ndash;of&ndash;lexeme
delimiter characters, looks like this:
</p>
<div class="example">
<pre class="example">(define (operator-4 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (end-of-input-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((char=? #\Y ch)
           (another-clause-form))
          ((end-of-lexeme-delimiter? ch)
           (end-of-input-form))
          (else ;invalid input char
           (error-form)))))
</pre></div>

<p>notice how the <code>end-of-input-form</code> is used for both the proper
end&ndash;of&ndash;input state and the end&ndash;of&ndash;lexeme state; such operator is
specified in the parser logic as the following <var>?operator</var> symbolic
subexpression:
</p>
<div class="example">
<pre class="example">(operator-4 (parser-state)
  ((:end-of-input)
   (end-of-input-form))
  ((X)
   (a-clause-form))
  ((Y)
   (another-clause-form)))
</pre></div>

<p>notice that processing of the end&ndash;of&ndash;lexeme state is not specified in
the parser logic: its generation is completely delegated to the device
logic.
</p>
<p>Sometimes it is useful to apply a test function or macro to an input
character and collect the result for further processing; this can be
done as follows:
</p>
<div class="example">
<pre class="example">(define (the-test ch arg1 arg2 arg3)
  ---)

(define (operator-5 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((the-test ch 1 2 3)
           =&gt; (lambda (result)
                (a-clause-form)))
          ((char=? #\Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
</pre></div>

<p>and is specified in the parser logic as the symbolic subexpression:
</p>
<div class="example">
<pre class="example">(operator-5 (parser-state)
  ((the-test 1 2 3) =&gt; result
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
</pre></div>

<p>where <code>=&gt;</code> is the auxiliary syntax exported by <code>(rnrs base (6))</code>.
</p>
<hr>
<div class="header">
<p>
Next: <a href="parser-logic-api.html#parser-logic-api" accesskey="n" rel="next">parser logic api</a>, Previous: <a href="parser-logic-intro.html#parser-logic-intro" accesskey="p" rel="prev">parser logic intro</a>, Up: <a href="parser-logic.html#parser-logic" accesskey="u" rel="up">parser logic</a> &nbsp; [<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
