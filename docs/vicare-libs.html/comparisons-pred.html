<html lang="en">
<head>
<title>comparisons pred - Libraries for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Libraries for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="comparisons.html#comparisons" title="comparisons">
<link rel="prev" href="comparisons-branch.html#comparisons-branch" title="comparisons branch">
<link rel="next" href="comparisons-minmax.html#comparisons-minmax" title="comparisons minmax">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes the libraries distributed along with version
0.3d7 of Vicare Scheme, an R6RS compliant native
compiler for the Scheme language.

Copyright (C) 2010-2013 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library `(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

The documentation of the libraries `(vicare parser-tools silex
---)' are derived form the documentation of SILex.  Copyright
(C) 2001, 2009 Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="comparisons-pred"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="comparisons-minmax.html#comparisons-minmax">comparisons minmax</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="comparisons-branch.html#comparisons-branch">comparisons branch</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="comparisons.html#comparisons">comparisons</a>
<hr>
</div>

<h4 class="subsection">1.21.10 Predicates</h4>

<div class="defun">
&mdash; Function: <b>=?</b> [<var>compare</var>] [<var>x y</var>]<var><a name="index-g_t_003d_003f-412"></a></var><br>
&mdash; Function: <b>&lt;?</b> [<var>compare</var>] [<var>x y</var>]<var><a name="index-g_t_003c_003f-413"></a></var><br>
&mdash; Function: <b>&gt;?</b> [<var>compare</var>] [<var>x y</var>]<var><a name="index-g_t_003e_003f-414"></a></var><br>
&mdash; Function: <b>&lt;=?</b> [<var>compare</var>] [<var>x y</var>]<var><a name="index-g_t_003c_003d_003f-415"></a></var><br>
&mdash; Function: <b>&gt;=?</b> [<var>compare</var>] [<var>x y</var>]<var><a name="index-g_t_003e_003d_003f-416"></a></var><br>
&mdash; Function: <b>not=?</b> [<var>compare</var>] [<var>x y</var>]<var><a name="index-not_003d_003f-417"></a></var><br>
<blockquote><p>If the values <var>x</var> and <var>y</var> are given, test if <var>x</var> and <var>y</var>
are in the relation specified by the name of the procedure <code>rel?</code>,
with respect to compare procedure <var>compare</var>; otherwise construct a
predicate procedure.

        <p>In the forms:

     <pre class="example">          (rel? [<var>compare</var>] <var>x</var> <var>y</var>)
</pre>
        <p class="noindent">the result is a boolean depending on <code>(</code><var>compare</var> <var>x</var>
<var>y</var><code>)</code> and the test <code>rel?</code> as specified for <code>if&lt;?</code> etc.  If
<var>compare</var> is not supplied, <code>default-compare</code> is used.

        <p>In the form:

     <pre class="example">          (rel? [<var>compare</var>])
</pre>
        <p class="noindent">the predicate procedure:

     <pre class="example">          (lambda (x y)
            (rel? <var>compare</var> <var>x</var> <var>y</var>))
</pre>
        <p class="noindent">is constructed.  Again, if <var>compare</var> is not supplied,
<code>default-compare</code> is used.

        <p>A few examples for illustration:

     <pre class="example">          (&gt;? "laugh" "LOUD")
          &rArr; #t
          
          (&lt;? string-compare-ci "laugh" "LOUD")
          &rArr; #t
          
          (define char&lt;=?
            (&lt;=? char-compare))
          
          (sort-by-less '(1 a "b") (&lt;?))
          &rArr; '("b" a 1)
          
          (sort-by-less '(1 a "b") (&gt;?))
          &rArr; '(1 a "b")
</pre>
        <blockquote>
<em>Warning:</em> A common mistake is writing <code>(&lt;=? x y z)</code> where
<code>(&lt;=/&lt;=? x y z)</code> is meant; this will most likely manifest itself at
the time the expression <code>(x y z)</code> is evaluated. 
</blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: <b>&lt;/&lt;?</b> [<var>compare</var>] [<var>x y z</var>]<var><a name="index-g_t_003c_002f_003c_003f-418"></a></var><br>
&mdash; Function: <b>&lt;/&lt;=?</b> [<var>compare</var>] [<var>x y z</var>]<var><a name="index-g_t_003c_002f_003c_003d_003f-419"></a></var><br>
&mdash; Function: <b>&lt;=/&lt;?</b> [<var>compare</var>] [<var>x y z</var>]<var><a name="index-g_t_003c_003d_002f_003c_003f-420"></a></var><br>
&mdash; Function: <b>&lt;=/&lt;=?</b> [<var>compare</var>] [<var>x y z</var>]<var><a name="index-g_t_003c_003d_002f_003c_003d_003f-421"></a></var><br>
&mdash; Function: <b>&gt;/&gt;?</b> [<var>compare</var>] [<var>x y z</var>]<var><a name="index-g_t_003e_002f_003e_003f-422"></a></var><br>
&mdash; Function: <b>&gt;/&gt;=?</b> [<var>compare</var>] [<var>x y z</var>]<var><a name="index-g_t_003e_002f_003e_003d_003f-423"></a></var><br>
&mdash; Function: <b>&gt;=/&gt;?</b> [<var>compare</var>] [<var>x y z</var>]<var><a name="index-g_t_003e_003d_002f_003e_003f-424"></a></var><br>
&mdash; Function: <b>&gt;=/&gt;=?</b> [<var>compare</var>] [<var>x y z</var>]<var><a name="index-g_t_003e_003d_002f_003e_003d_003f-425"></a></var><br>
<blockquote><p>Test if <var>x</var>, <var>y</var>, and <var>z</var> form a chain with the two
relations specified by the name of the procedure <code>rel1/rel2?</code>, with
respect to the compare procedure <var>compare</var>.

        <p>If <var>compare</var> is not provided, <code>default-compare</code> is used.

        <p>If <var>x</var>, <var>y</var> and <var>z</var> are not provided, a predicate procedure
of three arguments is constructed.  The order in which the values are
compared is unspecified, but each value is compared at least once.

        <blockquote>
<strong>NOTE</strong>

     <pre class="example">          (&lt;=/&lt;? real-compare 0 x 1)
</pre>
        <p class="noindent">tests if <var>x</var> is a real number in the half open interval <code>[0,
1)</code>. 
</blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: <b>chain=?</b><var> compare x1 ...<a name="index-chain_003d_003f-426"></a></var><br>
&mdash; Function: <b>chain&lt;?</b><var> compare x1 ...<a name="index-chain_003c_003f-427"></a></var><br>
&mdash; Function: <b>chain&gt;?</b><var> compare x1 ...<a name="index-chain_003e_003f-428"></a></var><br>
&mdash; Function: <b>chain&lt;=?</b><var> compare x1 ...<a name="index-chain_003c_003d_003f-429"></a></var><br>
&mdash; Function: <b>chain&gt;=?</b><var> compare x1 ...<a name="index-chain_003e_003d_003f-430"></a></var><br>
<blockquote><p>Test if the values <var>x1</var> <small class="dots">...</small> (zero or more values) form a chain
with respect to the relation specified by the name of the procedure, and
with respect to the compare procedure <var>compare</var>.  The result is a
boolean.

        <p>The order in which the values are compared is unspecified, but each
value is compared at least once (even if there is just one).

        <p>A sequence of values <var>x1</var>, <small class="dots">...</small>, <var>xn</var> forms a chain with
respect to the relation <code>rel?</code> if:

     <pre class="example">          (rel? <var>compare</var> <var>xi</var> <var>xj</var>)
</pre>
        <p class="noindent">for all 1 &lt; i &lt; j &lt; n.  In particular, this is the case for
n \in {0, 1}.

        <p>Since the relations <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;</code>, and <code>&gt;</code>
are transitive, it is sufficient to test:

     <pre class="example">          (rel? <var>compare</var> <var>xi</var> <var>xi+1</var>)
</pre>
        <p class="noindent">for 1 &lt; i &lt; n.

        <blockquote>
<strong>NOTE</strong> The reason every <var>xi</var> participates in at least one
comparison is type&ndash;checking: After testing if the values form a chain,
these value may be assumed to be of the type comparable by compare&mdash;
and this holds irrespectively of the number of values, or whether they
form a chain. 
</blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: <b>pairwise-not=?</b><var> compare x1 ...<a name="index-pairwise_002dnot_003d_003f-431"></a></var><br>
<blockquote><p>Tests if the values <var>x1</var> ... (zero or more values) are pairwise
unequal with respect to the compare procedure <var>compare</var>.  The result
is a boolean.

        <p>The order in which the values are compared is unspecified, but each
value is compared at least once (even if there is just one).

        <p>The values <var>x1</var>, ..., <var>xn</var> are pairwise unequal if:

     <pre class="example">          (not=? <var>compare</var> <var>xi</var> <var>xj</var>)
</pre>
        <p class="noindent">for all i different from j.  In particular, this is the
case for n \in {0, 1}.

        <p>Since compare defines a total ordering on the values, the property can
be checked in time O(n log n). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>compare-by&lt;</b><var> lt-pred </var>[<var>x y</var>]<var><a name="index-compare_002dby_003c-432"></a></var><br>
&mdash; Function: <b>compare-by&gt;</b><var> gt-pred </var>[<var>x y</var>]<var><a name="index-compare_002dby_003e-433"></a></var><br>
&mdash; Function: <b>compare-by&lt;=</b><var> le-pred </var>[<var>x y</var>]<var><a name="index-compare_002dby_003c_003d-434"></a></var><br>
&mdash; Function: <b>compare-by&gt;=</b><var> ge-pred </var>[<var>x y</var>]<var><a name="index-compare_002dby_003e_003d-435"></a></var><br>
&mdash; Function: <b>compare-by=/&lt;</b><var> eq-pred lt-pred </var>[<var>x y</var>]<var><a name="index-compare_002dby_003d_002f_003c-436"></a></var><br>
&mdash; Function: <b>compare-by=/&gt;</b><var> eq-pred gt-pred </var>[<var>x y</var>]<var><a name="index-compare_002dby_003d_002f_003e-437"></a></var><br>
<blockquote><p>If optional arguments <var>x</var> and <var>y</var> are present then these are
compared with respect to the total order defined by the predicate(s)
given; the result is in {-1, 0, 1}.  If <var>x</var> and <var>y</var> are
not present then a procedure comparing its two arguments using the
predicate(s) given is constructed and returned.

        <p>The predicate procedures mean the following:

          <dl>
<dt><var>lt-pred</var><dd>Test if x &lt; y.

          <br><dt><var>le-pred</var><dd>Test for &lt;=.

          <br><dt><var>gt-pred</var><dd>Test for &gt;.

          <br><dt><var>ge-pred</var><dd>Test for &gt;=.

          <br><dt><var>eq-pred</var><dd>Test if <var>x</var> and <var>y</var> are equivalent. 
</dl>

        <p>The result returned by a predicate procedure is interpreted as a Scheme
truth value (i.e. <code>#f</code> is false and non&ndash;<code>#f</code> is true).

        <p>The purpose of the procedures compare-by-predicate(s) is to define a
compare procedure from an order predicate, and possibly an additional
equivalence predicate.  If an equivalence predicate eq-pred is given, it
is called before the order predicate because the equivalence may be
coarser than the total ordering, and it may also be cheaper.

        <blockquote>
<strong>NOTE</strong> <code>char-compare</code> could be defined in terms of
<code>char&lt;=?</code> as:

     <pre class="example">          (define char-compare
            (compare-by&lt;= char&lt;=?))
</pre>
        </blockquote>
        </p></blockquote></div>

<!-- page -->
   </body></html>

