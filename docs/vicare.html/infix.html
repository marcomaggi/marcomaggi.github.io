<html lang="en">
<head>
<title>infix - Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="lang.html#lang" title="lang">
<link rel="prev" href="amb.html#amb" title="amb">
<link rel="next" href="simple_002dmatch.html#simple_002dmatch" title="simple-match">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d2 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  _Vicare_ is pronounced
the etruscan way.

The package, including its documentation, is distributed under the terms
of the GNU General Public License (GPL) and can be downloaded
from:

        `http://sourceforge.net/projects/vicare-scheme/files/'


the home page of the project is at:

              `http://marcomaggi.github.com/vicare.html'


development takes place at:

                `http://github.com/marcomaggi/vicare/'


and, as a backup, at:

                     `http://gitorious.org/vicare'


and at:

           `http://sourceforge.net/projects/vicare-scheme/'


this project has a mailing list:

             `http://groups.google.com/group/vicare-users'


Copyright (C) 2010-2013 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton Van Straaten.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors, see the ``History'' appendix for details.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="infix"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="simple_002dmatch.html#simple_002dmatch">simple-match</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="amb.html#amb">amb</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="lang.html#lang">lang</a>
<hr>
</div>

<h3 class="section">15.6 Infix to prefix transformer</h3>

<p><a name="index-Library-_0040library_007bvicare-language_002dextensions-infix_007d-5221"></a><a name="index-g_t_0040library_007bvicare-language_002dextensions-infix_007d_002c-library-5222"></a>

   <p>The library <code>(vicare language-extensions infix)</code> provides the
<code>infix</code> macro which converts the traditional infix notation for
expressions to the equivalent Scheme's prefix notation.

   <p>To use the library just import <code>(vicare infix)</code> and use the
<code>infix</code> macro: it expands to a prefix expression to be evaluated at
runtime, in the lexical context of the macro use; as a special case
<code>(infix)</code> is equivalent to <code>(values)</code>.

   <p>The macro allows us to evaluate forms like:

<pre class="example">     (let ((a 1) (b 2) (c 3))
     
       (infix cos (a) * tan (b) / c)
       ==&gt; (/ (* (cos a) (tan b)) c)
     
       (infix (cos (a) * tan (b) / c))
       ==&gt; (/ (* (cos a) (tan b)) c)
     
       (infix a ? b : c)
       ==&gt; (if a b c)
     
      #f)
</pre>
   <p>Some interpretation rules:

     <ul>
<li>Any Scheme value can be element of the input form.

     <li>The following infix operators are supported; in order of descending
precedence from top to bottom, operators on the same line have equal
precedence:

     <pre class="example">          bitwise-arithmetic-shift-left bitwise-arithmetic-shift-right
          bitwise-not
          bitwise-and bitwise-ior bitwise-xor
          incr! decr!
          (unary +) (unary -)
          expt
          mod mod0
          * / div div0
          + -
          &lt; &gt; &lt;= &gt;= = eq? eqv? equal?
          not
          and or xor
</pre>
     <p class="noindent">remember that the Scheme comparison operators are meant to return a
boolean value, rather than a number object.

     <li>All the operators are left&ndash;associative with the exception of
<code>expt</code> which is right&ndash;associative and of the unary <code>+</code>,
<code>-</code>, <code>incr!</code>, <code>decr!</code>, <code>not</code> and <code>bitwise-not</code>
which are non&ndash;associative:

     <pre class="example">          ;; left-associative
          (infix 10 - 5 - 3) ==&gt; (- (- 10 5) 3)
          (infix 10 - 5 - 3) ==&gt; (- 10 5 3)
          (infix 10 / 5 / 3) ==&gt; (/ (/ 10 5) 3)
          (infix 10 / 5 / 3) ==&gt; (/ 10 5 3)
          
          ;; right-associative
          (infix 10 expt 5 expt 3) ==&gt; (expt 10 (expt 5 3))
</pre>
     <li>The following operators for fixnums are supported with the same
precedence of the corresponding generic operators:

     <pre class="example">          fx+               fx-
          fx*
          fxdiv             fxdiv0
          fxmod             fxmod0
          fx&lt;?              fx&gt;?
          fx&lt;=?             fx&gt;=?
          fx=?
          
          fxand             fxior
          fxxor             fxnot
          fxarithmetic-shift-left
          fxarithmetic-shift-right
</pre>
     <p>All the operators are left-associative with the exception of FXNOT which
is non-associative:

     <pre class="example">          (infix 10 fx- 5 fx- 3)     ==&gt; (fx- (fx- 10 5) 3)
          (infix 10 fxdiv 5 fxdiv 3) ==&gt; (fxdiv (fxdiv 10 5) 3)
</pre>
     <li>The following operators for flonums are supported with the same
precedence of the corresponding generic operators:

     <pre class="example">          fl+               fl-
          fl*               fl/
          flexpt
          fl&lt;?              fl&gt;?
          fl&lt;=?             fl&gt;=?
          fl=?
</pre>
     <p>All the operators are left&ndash;associative with the exception of
<code>flexpt</code> which is right&ndash;associative:

     <pre class="example">          ;; left-associative
          (infix 10. fl- 5. fl- 3.)         ==&gt; (fl- (fl- 10. 5.) 3.))
          (infix 10. fl- 5. fl- 3.)         ==&gt; (fl- 10. 5. 3.))
          (infix 10. fl/ 5. fl/ 3.)         ==&gt; (fl/ (fl/ 10. 5.) 3.))
          (infix 10. fl/ 5. fl/ 3.)         ==&gt; (fl/ 10. 5. 3.))
          
          ;; right-associative
          (infix 10 expt 5 expt 3)          ==&gt; (expt 10 (expt 5 3))
          (infix 10. flexpt 5. flexpt 3.)   ==&gt; (flexpt 10. (flexpt 5. 3.))
</pre>
     <li><code>incr!</code> and <code>decr!</code> are unary operators that can be applied to
expressions both in prefix and suffix positions.  <code>(vicare infix)</code>
exports the identifiers <code>++</code> and <code>--</code> as aliases for
<code>incr!</code> and <code>decr!</code>; such aliases are invalid in <code>#!r6rs</code>
mode, but are allowed by the reader when in <code>#!vicare</code> mode.

     <p>When applied in prefix position to an identifier, <code>incr!</code> expands
to:

     <pre class="example">          (infix incr! ?id) ==&gt; (begin (set! ?id (+ ?id 1)) ?id)
</pre>
     <p class="noindent">and <code>decr!</code> expands to:

     <pre class="example">          (infix decr! ?id) ==&gt; (begin (set! ?id (- ?id 1)) ?id)
</pre>
     <p>When applied in suffix position to an identifier, <code>incr!</code> expands
to:

     <pre class="example">          (infix ?id incr!) ==&gt; (let ((v ?id)) (set! ?id (+ ?id 1)) v)
</pre>
     <p class="noindent">and <code>decr!</code> expands to:

     <pre class="example">          (infix ?id decr!) ==&gt; (let ((v ?id)) (set! ?id (- ?id 1)) v)
</pre>
     <p>When applied to a non&ndash;identifier expression, both in prefix and suffix
position, <code>incr!</code> expands to:

     <pre class="example">          (infix incr! ?expr) ==&gt; (+ ?expr 1)
          (infix ?expr incr!) ==&gt; (+ ?expr 1)
</pre>
     <p class="noindent">and <code>decr!</code> expands to:

     <pre class="example">          (infix decr! ?expr) ==&gt; (- ?expr 1)
          (infix ?expr decr!) ==&gt; (- ?expr 1)
</pre>
     <li>The if-then-else statement involves the identifiers <code>?</code>  and
<code>:</code>.  This statement has the least precedence of all.

     <li>Identifiers which are not operators are interpreted as variable
references; if an identifier is followed by a list, it is a function
call.

     <li>Function calls with one or more arguments require the arguments to be
grouped in a list; there is no special separator in the list of
arguments.

     <pre class="example">          (define (fun a b c)
            (+ a b c))
          
          (infix fun (1 2 3)) ==&gt; (fun 1 2 3)
</pre>
     <p>Notice that grouping the function arguments in a list is a requirement
of the infix expression grammar.

     <li>Numbers and all the other values are just put there as operands.

     <li>As a special exception: the binding <code>begin</code> from <code>(vicare)</code>
is recognised in the input form and allows us to nest prefix&ndash;notation
expressions.

     <pre class="example">          (infix (begin (+ 1 2))) &rArr; 3
          
          (infix (begin
                   (let ((a 3))
                     (/ a 4))))
          &rArr; 3/4
          
          (let ((a 3))
            (infix (begin (/ a 4))))
          &rArr; 3/4
          
          (let ((a 1) (b 2) (c 3))
            (infix (1 + a ? (begin
                              (+ 2 b))
                          : 3 + c - 4))
            ==&gt; (if (+ 1 a)
                    (begin (+ 2 b))
                  (- (+ 3 c) 4))
            #f)
</pre>
     <li>The following binding aliases are exported by the library:

     <pre class="example">          and                               -&gt; &amp;&amp;
          or                                -&gt; !!
          xor                               -&gt; ^^
          not                               -&gt; ~~
          mod                               -&gt; %
          bitwise-and                       -&gt; &amp;
          bitwise-ior                       -&gt; !
          bitwise-xor                       -&gt; ^
          bitwise-not                       -&gt; ~
          bitwise-arithmetic-shift-left     -&gt; &lt;&lt;
          bitwise-arithmetic-shift-right    -&gt; &gt;&gt;
          fxand                             -&gt; fx&amp;
          fxior                             -&gt; fx!
          fxxor                             -&gt; fx^
          fxnot                             -&gt; fx~
          fxarithmetic-shift-left           -&gt; fx&lt;&lt;
          fxarithmetic-shift-right          -&gt; fx&gt;&gt;
</pre>
     </ul>

<!-- page -->
   </body></html>

