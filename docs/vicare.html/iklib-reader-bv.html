<html lang="en">
<head>
<title>iklib reader bv - Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="iklib-reader.html#iklib-reader" title="iklib reader">
<link rel="prev" href="iklib-reader-mode.html#iklib-reader-mode" title="iklib reader mode">
<link rel="next" href="iklib-reader-chars.html#iklib-reader-chars" title="iklib reader chars">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d0 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  _Vicare_ is pronounced
the etruscan way.

The package, including its documentation, is distributed under the terms
of the GNU General Public License (GPL) and can be downloaded
from:

        `http://sourceforge.net/projects/vicare-scheme/files/'


the home page of the project is at:

              `http://marcomaggi.github.com/vicare.html'


development takes place at:

                `http://github.com/marcomaggi/vicare/'


and, as a backup, at:

                     `http://gitorious.org/vicare'


and at:

           `http://sourceforge.net/projects/vicare-scheme/'


this project has a mailing list:

             `http://groups.google.com/group/vicare-users'


Copyright (C) 2010-2013 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors, see the ``History'' appendix for details.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="iklib-reader-bv"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="iklib-reader-chars.html#iklib-reader-chars">iklib reader chars</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="iklib-reader-mode.html#iklib-reader-mode">iklib reader mode</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="iklib-reader.html#iklib-reader">iklib reader</a>
<hr>
</div>

<h4 class="subsection">3.5.2 Additional bytevector syntaxes</h4>

<p>The following syntaxes are available only when the input port mode is
set to <code>vicare</code>.

<div class="defun">
&mdash; Reader Syntax: <b>#vs8(</b><var>byte</var><b> ...)</b><var><a name="index-g_t_0023vs8_0028_0040var_007bbyte_007d-_002e_002e_002e_0029-94"></a></var><br>
<blockquote><p>Read a bytevector as <code>#vu8(</code><var>octect</var><code> ...)</code> would do, but allow
<var>byte</var> to be in the range [-128, 127]. 
</p></blockquote></div>

<div class="defun">
&mdash; Reader Syntax: <b>#vu16l(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vu16l_0028_0040var_007bword_007d-_002e_002e_002e_0029-95"></a></var><br>
&mdash; Reader Syntax: <b>#vu16b(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vu16b_0028_0040var_007bword_007d-_002e_002e_002e_0029-96"></a></var><br>
&mdash; Reader Syntax: <b>#vu16n(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vu16n_0028_0040var_007bword_007d-_002e_002e_002e_0029-97"></a></var><br>
<blockquote><p>Read a bytevector of 16-bit unsigned words stored in little, big and
native endianness. 
</p></blockquote></div>

<div class="defun">
&mdash; Reader Syntax: <b>#vs16l(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vs16l_0028_0040var_007bword_007d-_002e_002e_002e_0029-98"></a></var><br>
&mdash; Reader Syntax: <b>#vs16b(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vs16b_0028_0040var_007bword_007d-_002e_002e_002e_0029-99"></a></var><br>
&mdash; Reader Syntax: <b>#vs16n(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vs16n_0028_0040var_007bword_007d-_002e_002e_002e_0029-100"></a></var><br>
<blockquote><p>Read a bytevector of 16-bit signed words stored in little, big and
native endianness. 
</p></blockquote></div>

<div class="defun">
&mdash; Reader Syntax: <b>#vu32l(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vu32l_0028_0040var_007bword_007d-_002e_002e_002e_0029-101"></a></var><br>
&mdash; Reader Syntax: <b>#vu32b(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vu32b_0028_0040var_007bword_007d-_002e_002e_002e_0029-102"></a></var><br>
&mdash; Reader Syntax: <b>#vu32n(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vu32n_0028_0040var_007bword_007d-_002e_002e_002e_0029-103"></a></var><br>
<blockquote><p>Read a bytevector of 32-bit unsigned words stored in little, big and
native endianness. 
</p></blockquote></div>

<div class="defun">
&mdash; Reader Syntax: <b>#vs32l(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vs32l_0028_0040var_007bword_007d-_002e_002e_002e_0029-104"></a></var><br>
&mdash; Reader Syntax: <b>#vs32b(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vs32b_0028_0040var_007bword_007d-_002e_002e_002e_0029-105"></a></var><br>
&mdash; Reader Syntax: <b>#vs32n(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vs32n_0028_0040var_007bword_007d-_002e_002e_002e_0029-106"></a></var><br>
<blockquote><p>Read a bytevector of 32-bit signed words stored in little, big and
native endianness. 
</p></blockquote></div>

<div class="defun">
&mdash; Reader Syntax: <b>#vu64l(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vu64l_0028_0040var_007bword_007d-_002e_002e_002e_0029-107"></a></var><br>
&mdash; Reader Syntax: <b>#vu64b(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vu64b_0028_0040var_007bword_007d-_002e_002e_002e_0029-108"></a></var><br>
&mdash; Reader Syntax: <b>#vu64n(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vu64n_0028_0040var_007bword_007d-_002e_002e_002e_0029-109"></a></var><br>
<blockquote><p>Read a bytevector of 64-bit unsigned words stored in little, big and
native endianness. 
</p></blockquote></div>

<div class="defun">
&mdash; Reader Syntax: <b>#vs64l(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vs64l_0028_0040var_007bword_007d-_002e_002e_002e_0029-110"></a></var><br>
&mdash; Reader Syntax: <b>#vs64b(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vs64b_0028_0040var_007bword_007d-_002e_002e_002e_0029-111"></a></var><br>
&mdash; Reader Syntax: <b>#vs64n(</b><var>word</var><b> ...)</b><var><a name="index-g_t_0023vs64n_0028_0040var_007bword_007d-_002e_002e_002e_0029-112"></a></var><br>
<blockquote><p>Read a bytevector of 64-bit signed words stored in little, big and
native endianness. 
</p></blockquote></div>

<div class="defun">
&mdash; Reader Syntax: <b>#vf4l(</b><var>flonum</var><b> ...)</b><var><a name="index-g_t_0023vf4l_0028_0040var_007bflonum_007d-_002e_002e_002e_0029-113"></a></var><br>
&mdash; Reader Syntax: <b>#vf4b(</b><var>flonum</var><b> ...)</b><var><a name="index-g_t_0023vf4b_0028_0040var_007bflonum_007d-_002e_002e_002e_0029-114"></a></var><br>
&mdash; Reader Syntax: <b>#vf4n(</b><var>flonum</var><b> ...)</b><var><a name="index-g_t_0023vf4n_0028_0040var_007bflonum_007d-_002e_002e_002e_0029-115"></a></var><br>
<blockquote><p>Read a bytevector of single&ndash;precision flonums stored in little, big and
native endianness. 
</p></blockquote></div>

<div class="defun">
&mdash; Reader Syntax: <b>#vf8l(</b><var>flonum</var><b> ...)</b><var><a name="index-g_t_0023vf8l_0028_0040var_007bflonum_007d-_002e_002e_002e_0029-116"></a></var><br>
&mdash; Reader Syntax: <b>#vf8b(</b><var>flonum</var><b> ...)</b><var><a name="index-g_t_0023vf8b_0028_0040var_007bflonum_007d-_002e_002e_002e_0029-117"></a></var><br>
&mdash; Reader Syntax: <b>#vf8n(</b><var>flonum</var><b> ...)</b><var><a name="index-g_t_0023vf8n_0028_0040var_007bflonum_007d-_002e_002e_002e_0029-118"></a></var><br>
<blockquote><p>Read a bytevector of double&ndash;precision flonums stored in little, big and
native endianness. 
</p></blockquote></div>

<div class="defun">
&mdash; Reader Syntax: <b>#vc4l(</b><var>cflonum</var><b> ...)</b><var><a name="index-g_t_0023vc4l_0028_0040var_007bcflonum_007d-_002e_002e_002e_0029-119"></a></var><br>
&mdash; Reader Syntax: <b>#vc4b(</b><var>cflonum</var><b> ...)</b><var><a name="index-g_t_0023vc4b_0028_0040var_007bcflonum_007d-_002e_002e_002e_0029-120"></a></var><br>
&mdash; Reader Syntax: <b>#vc4n(</b><var>cflonum</var><b> ...)</b><var><a name="index-g_t_0023vc4n_0028_0040var_007bcflonum_007d-_002e_002e_002e_0029-121"></a></var><br>
<blockquote><p>Read a bytevector of single&ndash;precision cflonums stored in little, big
and native endianness, real part first. 
</p></blockquote></div>

<div class="defun">
&mdash; Reader Syntax: <b>#vc8l(</b><var>cflonum</var><b> ...)</b><var><a name="index-g_t_0023vc8l_0028_0040var_007bcflonum_007d-_002e_002e_002e_0029-122"></a></var><br>
&mdash; Reader Syntax: <b>#vc8b(</b><var>cflonum</var><b> ...)</b><var><a name="index-g_t_0023vc8b_0028_0040var_007bcflonum_007d-_002e_002e_002e_0029-123"></a></var><br>
&mdash; Reader Syntax: <b>#vc8n(</b><var>cflonum</var><b> ...)</b><var><a name="index-g_t_0023vc8n_0028_0040var_007bcflonum_007d-_002e_002e_002e_0029-124"></a></var><br>
<blockquote><p>Read a bytevector of double&ndash;precision cflonums stored in little, big
and native endianness, real part first. 
</p></blockquote></div>

<div class="defun">
&mdash; Reader Syntax: <b>#ve(</b><var>encoding</var> <var>data</var><b>)</b><var><a name="index-g_t_0023ve_0028_0040var_007bencoding_007d-_0040var_007bdata_007d_0029-125"></a></var><br>
<blockquote><p>Read a bytevector in some encoding which is supposed to be easy to type
for human beings.  <var>encoding</var> is a symbol representing the encoding
format, <var>data</var> is a datum to convert to bytevector.  At present the
following encodings are supported:

          <dl>
<dt><code>ascii</code><dd>Convert the Scheme string <var>data</var> to a bytevector using the function
<code>string-&gt;ascii</code>.

          <br><dt><code>latin1</code><dd>Convert the Scheme string <var>data</var> to a bytevector using the function
<code>string-&gt;latin1</code>.

          <br><dt><code>utf8</code><dd>Convert the Scheme string <var>data</var> to a bytevector using the function
<code>string-&gt;utf8</code>.

          <br><dt><code>utf16be</code><dd>Convert the Scheme string <var>data</var> to a bytevector using the function
<code>string-&gt;utf16be</code>.

          <br><dt><code>utf16le</code><dd>Convert the Scheme string <var>data</var> to a bytevector using the function
<code>string-&gt;utf16le</code>.

          <br><dt><code>utf16n</code><dd>Convert the Scheme string <var>data</var> to a bytevector using the function
<code>string-&gt;utf16n</code>.

          <br><dt><code>hex</code><dd>Convert the Scheme string <var>data</var> to a bytevector using the function
<code>string-hex-&gt;bytevector</code>.

          <br><dt><code>base64</code><dd>Convert the Scheme string <var>data</var> to a bytevector using the function
<code>string-base64-&gt;bytevector</code>. 
</dl>
        </p></blockquote></div>

<!-- page -->
   </body></html>

