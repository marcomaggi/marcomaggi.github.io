<html lang="en">
<head>
<title>posix shm - Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="posix.html#posix" title="posix">
<link rel="prev" href="posix-mq.html#posix-mq" title="posix mq">
<link rel="next" href="posix-sem.html#posix-sem" title="posix sem">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d19 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  _Vicare_ is pronounced
the etruscan way.

The package is distributed under the terms of the GNU General Public
License (GPL) and can be downloaded from:

               `http://code.google.com/p/vicare-scheme/'


or:

            `http://github.com/marcomaggi/vicare/downloads'


the home page of the project is at:

              `http://marcomaggi.github.com/vicare.html'


development takes place at:

                `http://github.com/marcomaggi/vicare/'


and, as a backup, at:

                     `http://gitorious.org/vicare'


this project has a mailing list:

             `http://groups.google.com/group/vicare-users'


Copyright (C) 2010-2012 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="posix-shm"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="posix-sem.html#posix-sem">posix sem</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="posix-mq.html#posix-mq">posix mq</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="posix.html#posix">posix</a>
<hr>
</div>

<h3 class="section">5.22 Shared memory</h3>

<p>The <acronym>POSIX</acronym> shared memory <acronym>API</acronym> allow processes to communicate
informations by sharing a region of memory.

   <blockquote>
<strong>NOTE</strong> On <acronym>GNU</acronym>+Linux systems, for an introduction to the <acronym>API</acronym>
we must refer to the manual page <code>shm_overview(7)</code>. 
</blockquote>

<div class="defun">
&mdash; Function: <b>shm-open</b><var> name oflag mode<a name="index-shm_002dopen-1180"></a></var><br>
<blockquote><p>Interface to the C function <code>shm_open()</code>, see the manual page
<code>shm_open(3)</code>.  Open, and optionally create, a shared memory object
and return a file descriptor referencing it.  If successful return a
fixnum representing the file descriptor, else raise an exception.

        <p><var>name</var> must be the pathname representing the shared memory object. 
<var>oflag</var> must be the bitwise inclusive OR combination of some of the
following values:

     <pre class="example">          O_RDONLY                O_RDWR
          O_CREAT                 O_EXCL
          O_TRUNC
</pre>
        <p class="noindent"><var>mode</var> must be the bitwise inclusive OR combination of some of the
following values:

     <pre class="example">          S_IRUSR   S_IWUSR   S_IXUSR
          S_IRGRP   S_IWGRP   S_IXGRP
          S_IROTH   S_IWOTH   S_IXOTH
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: <b>shm-unlink</b><var> name<a name="index-shm_002dunlink-1181"></a></var><br>
<blockquote><p>Interface to the C function <code>shm_unlink()</code>, see the manual page
<code>shm_unlink(3)</code>.  Remove the shared memory object selected by the
pathname <var>name</var>.  If successful return unspecified values, else
raise an exception. 
</p></blockquote></div>

   <p>The following example shows how two processes can exchange a signed
integer; notice how the only information shared at the beginning is the
pathname of the shared memory object and the dimension of the mapped
memory.  Also notice that the correct way of synchronising two processes
for shared memory access is with <acronym>POSIX</acronym> semaphores, <a href="posix-sem.html#posix-sem">posix sem</a>
for details.

<pre class="example">     #!r6rs
     (import (vicare)
       (prefix (vicare posix) px.)
       (vicare platform constants)
       (only (vicare syntactic-extensions)
             unwind-protect
             callet)
     
     (define shm.pathname
       "/vicare-posix-shm.test")
     (define shm.dim
       (px.sysconf _SC_PAGESIZE))
     
     (define (parent child-pid)
       (let ((shm.fd (callet px.shm-open shm.pathname
                             (oflags (fxior O_CREAT O_RDWR))
                             (mode   (fxior S_IRUSR S_IWUSR)))))
         (px.ftruncate shm.fd shm.dim)
         (unwind-protect
             (unwind-protect
                 (let ((shm.base (callet px.mmap
                                   (address #f)
                                   (size    shm.dim)
                                   (prot    (fxior PROT_READ
                                                   PROT_WRITE))
                                   (flags   MAP_SHARED)
                                   (fd      shm.fd)
                                   (offset  0))))
                   (unwind-protect
                       (begin
                         (px.waitpid child-pid 0)
                         (pointer-ref-c-signed-int shm.base 0))
                     (px.munmap shm.base shm.dim)))
               (px.close shm.fd))
           (px.shm-unlink shm.pathname))))
     
     (define (child)
       ;; Give the parent some time to create and open the
       ;; shared memory object.
       (px.nanosleep 1 0)
       (let ((shm.fd (callet px.shm-open shm.pathname
                             (oflags (fxior O_CREAT O_RDWR))
                             (mode   (fxior S_IRUSR S_IWUSR)))))
         (unwind-protect
             (let ((shm.base (callet px.mmap
                               (address #f)
                               (size    shm.dim)
                               (prot    (fxior PROT_READ
                                               PROT_WRITE))
                               (flags   MAP_SHARED)
                               (fd      shm.fd)
                               (offset  0))))
               (unwind-protect
                   (pointer-set-c-signed-int! shm.base 0 123)
                 (px.munmap shm.base shm.dim)))
           (px.close shm.fd)))
       (exit 0))
     
     (px.fork parent child)
     &rArr; 123
</pre>
   <!-- page -->
   </body></html>

