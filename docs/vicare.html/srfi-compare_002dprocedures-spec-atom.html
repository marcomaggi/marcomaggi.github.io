<html lang="en">
<head>
<title>srfi compare-procedures spec atom - Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="srfi-compare_002dprocedures-spec.html#srfi-compare_002dprocedures-spec" title="srfi compare-procedures spec">
<link rel="next" href="srfi-compare_002dprocedures-spec-seq.html#srfi-compare_002dprocedures-spec-seq" title="srfi compare-procedures spec seq">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d20 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  _Vicare_ is pronounced
the etruscan way.

The package is distributed under the terms of the GNU General Public
License (GPL) and can be downloaded from:

               `http://code.google.com/p/vicare-scheme/'


the home page of the project is at:

              `http://marcomaggi.github.com/vicare.html'


development takes place at:

                `http://github.com/marcomaggi/vicare/'


and, as a backup, at:

                     `http://gitorious.org/vicare'


this project has a mailing list:

             `http://groups.google.com/group/vicare-users'


Copyright (C) 2010-2012 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="srfi-compare-procedures-spec-atom"></a>
<a name="srfi-compare_002dprocedures-spec-atom"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="srfi-compare_002dprocedures-spec-seq.html#srfi-compare_002dprocedures-spec-seq">srfi compare-procedures spec seq</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="srfi-compare_002dprocedures-spec.html#srfi-compare_002dprocedures-spec">srfi compare-procedures spec</a>
<hr>
</div>

<h5 class="subsubsection">10.28.5.1 Comparing atoms</h5>

<p>In this section, compare procedures for most of the atomic types of
<acronym>R5RS</acronym> are defined: Booleans, characters, strings, symbols, and
numbers.

   <p>As a general naming convention, a procedure named

<pre class="example">     <var>type</var>-compare-<var>order</var>
</pre>
   <p class="noindent">compares two object of the type <var>type</var> with respect to a total order
for which <var>order</var> is a mnemonic hint (e.g. <code>-ci</code> for
case&ndash;insensitive).  Of course, <code>-</code><var>order</var> may be absent if
there is just one order or the order is obvious.  It is an error if a
compare procedure accepting objects of a certain type is called with one
or two arguments not of that type.

<div class="defun">
&mdash; Function: <b>boolean-compare</b><var> bool1 bool2<a name="index-boolean_002dcompare-3370"></a></var><br>
<blockquote><p>Compare two booleans, ordered by <code>#f &lt; #t</code>.

        <blockquote>
<strong>NOTE</strong> A non&ndash;<code>#f</code> value is not interpreted as a &ldquo;true
value,&rdquo; but rather an error will be signalled. 
</blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: <b>char-compare</b><var> char1 char2<a name="index-char_002dcompare-3371"></a></var><br>
&mdash; Function: <b>char-compare-ci</b><var> char1 char2<a name="index-char_002dcompare_002dci-3372"></a></var><br>
<blockquote><p>Compare characters as <code>char&lt;=?</code> and <code>char-ci&lt;=?</code> respectively. 
The suffix <code>-ci</code> means &ldquo;case insensitive.&rdquo;
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>string-compare</b><var> string1 string2<a name="index-string_002dcompare-3373"></a></var><br>
&mdash; Function: <b>string-compare-ci</b><var> string1 string2<a name="index-string_002dcompare_002dci-3374"></a></var><br>
<blockquote><p>Compare strings as <code>string&lt;=</code> and <code>string-ci&lt;=?</code>.  The suffix
<code>-ci</code> means &ldquo;case insensitive.&rdquo;

        <blockquote>
<strong>NOTE</strong> <code>string-compare</code> could be defined as:

     <pre class="example">          (define (string-compare string1 string2)
            (vector-compare-as-list char-compare
                                    string1 string2
                                    string-length string-ref))
</pre>
        </blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: <b>symbol-compare</b><var> symbol1 symbol2<a name="index-symbol_002dcompare-3375"></a></var><br>
<blockquote><p>Compare symbols as <code>string&lt;=</code> on the names returned by
<code>symbol-&gt;string</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>integer-compare</b><var> x y<a name="index-integer_002dcompare-3376"></a></var><br>
&mdash; Function: <b>rational-compare</b><var> x y<a name="index-rational_002dcompare-3377"></a></var><br>
&mdash; Function: <b>real-compare</b><var> x y<a name="index-real_002dcompare-3378"></a></var><br>
&mdash; Function: <b>complex-compare</b><var> x y<a name="index-complex_002dcompare-3379"></a></var><br>
&mdash; Function: <b>number-compare</b><var> x y<a name="index-number_002dcompare-3380"></a></var><br>
<blockquote><p>Compare two numbers.  It is an error if an argument is not of the type
specified by the name of the procedure.

        <p>Complex numbers are ordered lexicographically on pairs <code>(re, im)</code>. 
For objects representing real numbers <code>sign(x - y)</code> is computed. 
The ordering for values satisfying <code>real?</code> or <code>complex?</code> but
not representing a real or complex number should be consistent with
procedures <code>=</code> and <code>&lt;</code> of <acronym>R5RS</acronym>, and apart from that it is
unspecified.

        <p>Numerical compare procedures are compatible with the <acronym>R5RS</acronym> numerical
tower in the following sense: If <var>S</var> is a subtype of the numerical
type <var>T</var> and <var>x</var>, <var>y</var> can be represented both in <var>S</var> and
in <var>T</var>, then <code>compare-</code><var>S</var> and <code>compare-</code><var>T</var>
compute the same result.

        <blockquote>
<strong>NOTE</strong> Floating point formats usually include several symbolic
values not simply representing rational numbers.  For example, the
<acronym>IEEE</acronym> 754 standard defines <code>-0</code>, <code>-Inf</code>, <code>+Inf</code>, and
<code>NaN</code> (&ldquo;not a number&rdquo;) for continuing a calculation in the
presence of error conditions.  The behavior of the numerical comparison
operation is unspecified in case an argument is one of the special
symbols. 
</blockquote>

        <blockquote>
<strong>WARNING</strong> The propagation of inexactness can lead to surprises. 
In a Scheme system propagating inexactness in complex numbers (such as
PLT, version 208):

     <pre class="example">          (complex-compare (make-rectangular (/ 1 3)  1.)
                           (make-rectangular (/ 1 3) -1))
          &rArr; -1
</pre>
        <p>At first glance, one might expect the first complex number to be larger,
because the numbers are equal on their real parts and the first
imaginary part (<code>1.</code>) is larger than the second (<code>-1</code>).

        <p>Closer inspection reveals that the decimal dot causes the first real
part to be made inexact upon construction of the complex number, and
since:

     <pre class="example">          (exact-&gt;inexact (/ 1 3))
</pre>
        <p class="noindent">is less than <code>(/ 1 3)</code> in the underlying floating point format
used, the real parts decide the comparison of the complex numbers. 
</blockquote>
        </p></blockquote></div>

<!-- page -->
   </body></html>

