<html lang="en">
<head>
<title>objects pointers - Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="objects.html#objects" title="objects">
<link rel="prev" href="objects-transcoders.html#objects-transcoders" title="objects transcoders">
<link rel="next" href="objects-misc.html#objects-misc" title="objects misc">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d15 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  _Vicare_ is pronounced
the etruscan way.

The package is distributed under the terms of the GNU General Public
License (GPL) and can be downloaded from:

               `http://code.google.com/p/vicare-scheme/'


or:

            `http://github.com/marcomaggi/vicare/downloads'


the home page of the project is at:

              `http://marcomaggi.github.com/vicare.html'


development takes place at:

                `http://github.com/marcomaggi/vicare/'


and, as a backup, at:

                     `http://gitorious.org/vicare'


this project has a mailing list:

             `http://groups.google.com/group/vicare-users'


Copyright (C) 2010-2012 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="objects-pointers"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="objects-misc.html#objects-misc">objects misc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="objects-transcoders.html#objects-transcoders">objects transcoders</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="objects.html#objects">objects</a>
<hr>
</div>

<h3 class="section">11.18 Pointer objects</h3>

<p>A pointer is a fixed length memory block, two words wide, referenced by
machine words tagged as vectors.  The first machine word of a pointer
block is tagged has pointer in its least significant bits and it has the
most significant bits set to zero.  The second machine word of a pointer
block holds the actual pointer value.

<pre class="example">     |------------------------|-------------| reference to pointer
           heap pointer         vector tag
     
     |------------------------|-------------| pointer first word
        all set to zero         pointer tag
     
     |--------------------------------------| pointer second word
                 pointer value
</pre>
   <!--  -->
<h5 class="subsubheading">Basic operations</h5>

<p>Pointers are allocated on the Scheme heap as follows:

<pre class="example">     ikpcb * pcb   = ik_the_pcb();
     ikptr   s_ptr;
     
     s_ptr = ik_safe_alloc(pcb, pointer_size) | vector_tag;
     IK_REF(s_ptr, off_pointer_tag) = pointer_tag;
</pre>
   <p class="noindent">to identify an object as pointer we do:

<pre class="example">     ikptr  X = the_object;
     
     if ((vector_tag  == IK_TAGOF(X)) &amp;&amp;
         (pointer_tag == IK_REF(X, -vector_tag)))
       it_is_a_pointer();
     else
       it_is_not();
</pre>
   <p class="noindent">to set or retrieve the pointer value we do:

<pre class="example">     ikptr  s_ptr = the_pointer;
     void * ptr;
     
     ptr = (void *)IK_REF((X), off_pointer_data);
     IK_REF((X), off_pointer_data) = (ikptr)ptr;
</pre>
   <div class="defun">
&mdash; Preprocessor Symbol: <b>pointer_size</b><var><a name="index-pointer_005fsize-2042"></a></var><br>
<blockquote><p>The number of bytes to allocate to hold a pointer memory block. 
</p></blockquote></div>

<div class="defun">
&mdash; Preprocessor Symbol: <b>pointer_tag</b><var><a name="index-pointer_005ftag-2043"></a></var><br>
<blockquote><p>The tag of <code>ikptr</code> values used as first words in pointer memory blocks. 
</p></blockquote></div>

<div class="defun">
&mdash; Preprocessor Symbol: <b>disp_pointer_tag</b><var><a name="index-disp_005fpointer_005ftag-2044"></a></var><br>
<blockquote><p>Displacement of secondary tag word.  The number of bytes to add to an
untagged pointer to pointer object to get the pointer to the first byte
in the word holding the pointer tag. 
</p></blockquote></div>

<div class="defun">
&mdash; Preprocessor Symbol: <b>disp_pointer_data</b><var><a name="index-disp_005fpointer_005fdata-2045"></a></var><br>
<blockquote><p>Displacement of data area.  The number of bytes to add to an untagged
pointer to pointer object to get the pointer to the first byte of the
data area. 
</p></blockquote></div>

<div class="defun">
&mdash; Preprocessor Symbol: <b>off_pointer_tag</b><var><a name="index-off_005fpointer_005ftag-2046"></a></var><br>
<blockquote><p>An integer to add to add to a tagged <code>ikptr</code> pointer to pointer object
to get the pointer to the first byte in the word holding the pointer
tag. 
</p></blockquote></div>

<div class="defun">
&mdash; Preprocessor Symbol: <b>off_pointer_data</b><var><a name="index-off_005fpointer_005fdata-2047"></a></var><br>
<blockquote><p>An integer to add to a tagged <code>ikptr</code> pointer to pointer object to get
the pointer to the first byte of the word holding the pointer value. 
</p></blockquote></div>

<!--  -->
<h5 class="subsubheading">Convenience preprocessor macros</h5>

<div class="defun">
&mdash; Preprocessor Macro: ikptr <b>IK_POINTER_DATA</b> (<var>ikptr X</var>)<var><a name="index-IK_005fPOINTER_005fDATA-2048"></a></var><br>
<blockquote><p>Return the value of the pointer as <code>ikptr</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Preprocessor Macro: void * <b>IK_POINTER_DATA_VOIDP</b> (<var>ikptr X</var>)<var><a name="index-IK_005fPOINTER_005fDATA_005fVOIDP-2049"></a></var><br>
&mdash; Preprocessor Macro: char * <b>IK_POINTER_DATA_CHARP</b> (<var>ikptr X</var>)<var><a name="index-IK_005fPOINTER_005fDATA_005fCHARP-2050"></a></var><br>
&mdash; Preprocessor Macro: uint8_t * <b>IK_POINTER_DATA_UINT8P</b> (<var>ikptr X</var>)<var><a name="index-IK_005fPOINTER_005fDATA_005fUINT8P-2051"></a></var><br>
&mdash; Preprocessor Macro: long * <b>IK_POINTER_DATA_LONG</b> (<var>ikptr X</var>)<var><a name="index-IK_005fPOINTER_005fDATA_005fLONG-2052"></a></var><br>
&mdash; Preprocessor Macro: ik_llong * <b>IK_POINTER_DATA_LLONG</b> (<var>ikptr X</var>)<var><a name="index-IK_005fPOINTER_005fDATA_005fLLONG-2053"></a></var><br>
&mdash; Preprocessor Macro: ik_ulong * <b>IK_POINTER_DATA_ULONG</b> (<var>ikptr X</var>)<var><a name="index-IK_005fPOINTER_005fDATA_005fULONG-2054"></a></var><br>
&mdash; Preprocessor Macro: ik_ullong * <b>IK_POINTER_DATA_ULLONG</b> (<var>ikptr X</var>)<var><a name="index-IK_005fPOINTER_005fDATA_005fULLONG-2055"></a></var><br>
<blockquote><p>Return the value of the pointer cast to a specific type. 
</p></blockquote></div>

<div class="defun">
&mdash; Preprocessor Macro: ikptr <b>IK_POINTER_SET_NULL</b> (<var>ikptr X</var>)<var><a name="index-IK_005fPOINTER_005fSET_005fNULL-2056"></a></var><br>
<blockquote><p>Reset to <code>NULL</code> the value of the pointer. 
</p></blockquote></div>

<div class="defun">
&mdash; Preprocessor Macro: int <b>IK_POINTER_IS_NULL</b> (<var>ikptr X</var>)<var><a name="index-IK_005fPOINTER_005fIS_005fNULL-2057"></a></var><br>
<blockquote><p>Evaluate to true if the pointer value is <code>NULL</code>. 
</p></blockquote></div>

<!--  -->
<h5 class="subsubheading">Operations on pointers</h5>

<div class="defun">
&mdash; Function: ikptr <b>ika_pointer_alloc</b> (<var>ikpcb * pcb, ik_ulong memory</var>)<var><a name="index-ika_005fpointer_005falloc-2058"></a></var><br>
<blockquote><p>Allocate a pointer object using <code>ik_safe_alloc()</code> and return a
tagged reference to it.  The pointer is initialised to <var>memory</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: ikptr <b>iku_pointer_alloc</b> (<var>ikpcb* pcb, ik_ulong memory</var>)<var><a name="index-iku_005fpointer_005falloc-2059"></a></var><br>
<blockquote><p>Allocate a pointer object using <code>ik_unsafe_alloc()</code> and return a
tagged reference to it.  The pointer is initialised to <var>memory</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>ik_is_pointer</b> (<var>ikptr X</var>)<var><a name="index-ik_005fis_005fpointer-2060"></a></var><br>
<blockquote><p>Return true if <var>X</var> is a pointer object. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: ikptr <b>ikrt_is_pointer</b> (<var>ikptr X</var>)<var><a name="index-ikrt_005fis_005fpointer-2061"></a></var><br>
<blockquote><p>Return <code>IK_TRUE_OBJECT</code> if <var>X</var> is a pointer object, else return
<code>IK_FALSE_OBJECT</code>. 
</p></blockquote></div>

<!-- page -->
   </body></html>

