<html lang="en">
<head>
<title>coroutines examples - Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="coroutines.html#coroutines" title="coroutines">
<link rel="next" href="coroutines-api.html#coroutines-api" title="coroutines api">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d0 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  _Vicare_ is pronounced
the etruscan way.

The package, including its documentation, is distributed under the terms
of the GNU General Public License (GPL) and can be downloaded
from:

        `http://sourceforge.net/projects/vicare-scheme/files/'


the home page of the project is at:

              `http://marcomaggi.github.com/vicare.html'


development takes place at:

                `http://github.com/marcomaggi/vicare/'


and, as a backup, at:

                     `http://gitorious.org/vicare'


and at:

           `http://sourceforge.net/projects/vicare-scheme/'


this project has a mailing list:

             `http://groups.google.com/group/vicare-users'


Copyright (C) 2010-2013 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors, see the ``History'' appendix for details.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="coroutines-examples"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="coroutines-api.html#coroutines-api">coroutines api</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="coroutines.html#coroutines">coroutines</a>
<hr>
</div>

<h4 class="subsection">12.4.1 Usage examples for coroutines</h4>

<p>Coroutines are created by the function <code>coroutine</code>; a coroutine in
execution can yield control to the next coroutine with the function
<code>yield</code>.  It is possible to enter a loop that runs all the
coroutines until all of them are finished with the function
<code>finish-coroutines</code>.

   <p>All the examples in this section are to be considered as Scheme programs
after the prelude:

<pre class="example">     #!r6rs
     (import (vicare)
       (vicare language-extensions coroutines))
     
     (set-port-buffer-mode! (current-output-port)
                            (buffer-mode line))
</pre>
   <p class="noindent">which allows the intertwining of coroutines to be seen by displaying
strings on the current output port.

<!--  -->
<h5 class="subsubheading">Two coroutines</h5>

<p>The following example runs two coroutines and waits for them to finish:

<pre class="example">     (coroutine
         (lambda ()
           (display "one 1\n")
           (yield)
           (display "one 2\n")
           (yield)
           (display "one 3\n")))
     
     (coroutine
         (lambda ()
           (display "two 1\n")
           (yield)
           (display "two 2\n")
           (yield)
           (display "two 3\n")))
     
     (finish-coroutines)
</pre>
   <p class="noindent">the output is:

<pre class="example">     one 1
     two 1
     one 2
     two 2
     one 3
     two 3
</pre>
   <p>We see that to exit a coroutine we just return from its start function.

<!--  -->
<h5 class="subsubheading">The main routine and a subroutine</h5>

<p>We can always consider the ordinary control flow of a program as a
coroutine, the <dfn>main routine</dfn>; so the following program produces
output similar to the one above:

<pre class="example">     (coroutine
         (lambda ()
           (display "sub 1\n")
           (yield)
           (display "sub 2\n")
           (yield)
           (display "sub 3\n")))
     
     ;;This runs in the main routine.
     (display "main 1\n")
     (yield)
     (display "main 2\n")
     (yield)
     (display "main 3\n")
     
     (finish-coroutines)
</pre>
   <p class="noindent">the output is:

<pre class="example">     sub 1
     main 1
     sub 2
     main 2
     sub 3
     main 3
</pre>
   <!--  -->
<h5 class="subsubheading">Main routine alone</h5>

<p>It is perfectly all right to call <code>yield</code> and
<code>finish-coroutines</code> from the main routine even when there are no
subroutines:

<pre class="example">     (display "main 1\n")
     (yield)
     (display "main 2\n")
     (yield)
     (display "main 3\n")
     (finish-coroutines)
</pre>
   <p class="noindent">the output of this program is just:

<pre class="example">     main 1
     main 2
     main 3
</pre>
   <!--  -->
<h5 class="subsubheading">Finishing coroutines</h5>

<p>It is possible to call <code>finish-coroutines</code> from any coroutine, but
we must be careful because if we let the main routine exit before all
the routines are finished some computation will not take place.  In the
following program the subroutine has more steps than the main routine:

<pre class="example">     (coroutine
         (lambda ()
           (display "sub 1\n")
           (yield)
           (display "sub 2\n")
           (yield)
           (display "sub 3\n")
           (yield)
           (display "sub 4\n")
           (yield)
           (display "sub 5\n")
           (finish-coroutines)))
     
     ;; This runs in the main routine.
     (display "main 1\n")
     (yield)
     (display "main 2\n")
     (yield)
     (display "main 3\n")
</pre>
   <p class="noindent">and its output is:

<pre class="example">     sub 1
     main 1
     sub 2
     main 2
     sub 3
     main 3
</pre>
   <p class="noindent">we see that &lsquo;<samp><span class="samp">sub 4</span></samp>&rsquo; and &lsquo;<samp><span class="samp">sub 5</span></samp>&rsquo; are not displayed.

<!--  -->
<h5 class="subsubheading">Finish coroutines as exit hook</h5>

<p>It can be useful to register <code>finish-coroutines</code> as exit hook, so
that upon exiting the process all the pending coroutines are correctly
terminated.

<pre class="example">     (coroutine
         (lambda ()
           (display "one 1\n")
           (yield)
           (display "one 2\n")
           (yield)
           (display "one 3\n")))
     
     (coroutine
         (lambda ()
           (display "two 1\n")
           (yield)
           (display "two 2\n")
           (yield)
           (display "two 3\n")))
     
     (exit-hooks (cons finish-coroutines (exit-hooks)))
     (exit)
</pre>
   <!-- page -->
   </body></html>

