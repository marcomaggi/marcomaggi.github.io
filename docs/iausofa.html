<html lang="en">
<head>
<title>Standards of Fundamental Astronomy</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Standards of Fundamental Astronomy">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.1d6 of ATSOFA, the
International Astronomical Union's SOFA Collection of libraries
repackaged using the GNU Autotools.

ATSOFA is neither distributed, nor supported, nor endorsed by
the International Astronomical Union.  Any use of this pacakge should
comply with SOFA's license and terms of use.  Especially, but not
exclusively, any published work or commercial products which includes
results achieved by using ATSOFA shall acknowledge that the
SOFA software was used in obtaining those results.

The package is distributed under the terms of the International
Astronomical Union's SOFA license and its development takes place at:

                 `http://github.com/marcomaggi/atsofa'


and as backup at:

               `http://sourceforge.net/projects/atsofa'


proper release tarballs are available from:

            `http://sourceforge.net/projects/atsofa/files/'


the International Astronomical Union's SOFA project home page is at:

                       `http://www.iausofa.org/'


Copyright (C) International Astronomical Union Standards of
Fundamental Astronomy (`http://www.iausofa.org').

The repackaging into ATSOFA is by Marco Maggi
<marco.maggi-ipsu@poste.it>.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">Standards of Fundamental Astronomy</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#overview">overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Standards of Fundamental Astronomy</h2>

<p>This document describes version 0.1d6 of ATSOFA, the
International Astronomical Union's <acronym>SOFA</acronym> Collection of libraries
repackaged using the <acronym>GNU</acronym> Autotools.

   <p>ATSOFA is neither distributed, nor supported, nor endorsed by
the International Astronomical Union.  Any use of this pacakge should
comply with <acronym>SOFA</acronym>'s license and terms of use.  Especially, but not
exclusively, any published work or commercial products which includes
results achieved by using ATSOFA shall acknowledge that the
<acronym>SOFA</acronym> software was used in obtaining those results.

   <p>The package is distributed under the terms of the International
Astronomical Union's <acronym>SOFA</acronym> license and its development takes place at:

<div align="center"><a href="http://github.com/marcomaggi/atsofa">http://github.com/marcomaggi/atsofa</a></div>

<p class="noindent">and as backup at:

<div align="center"><a href="http://sourceforge.net/projects/atsofa">http://sourceforge.net/projects/atsofa</a></div>

<p class="noindent">proper release tarballs are available from:

<div align="center"><a href="http://sourceforge.net/projects/atsofa/files/">http://sourceforge.net/projects/atsofa/files/</a></div>

<p class="noindent">the International Astronomical Union's <acronym>SOFA</acronym> project home page is at:

<div align="center"><a href="http://www.iausofa.org/">http://www.iausofa.org/</a></div>

<p class="noindent">Copyright &copy; International Astronomical Union Standards of
Fundamental Astronomy (<a href="http://www.iausofa.org">http://www.iausofa.org</a>).

   <p>The repackaging into ATSOFA is by Marco Maggi
<a href="mailto:marco.maggi-ipsu@poste.it">marco.maggi-ipsu@poste.it</a>.

<ul class="menu">
<li><a accesskey="1" href="#overview">overview</a>:                     Overview of the package. 
<li><a accesskey="2" href="#intro">intro</a>:                        The <acronym>IAU</acronym> <acronym>SOFA</acronym> software libraries. 
<li><a accesskey="3" href="#astronomy">astronomy</a>:                    <acronym>SOFA</acronym> Astronomy Library. 
<li><a accesskey="4" href="#vector-matrix">vector matrix</a>:                <acronym>SOFA</acronym> Vector/Matrix Library. 
<li><a accesskey="5" href="#api">api</a>:                          Functions.

</li></ul>
<p>Appendices

</p>
<ul class="menu">
<li><a accesskey="6" href="#board">board</a>:                        <acronym>IAU</acronym> Standards of Fundamental
                                Astronomy Board. 
<li><a accesskey="7" href="#license">license</a>:                      Package license. 
<li><a accesskey="8" href="#references">references</a>:                   Bibliography and references.

</li></ul>
<p>Indexes

</p>
<ul class="menu">
<li><a accesskey="9" href="#concept-index">concept index</a>:                An entry for each concept. 
<li><a href="#function-index">function index</a>:               An entry for each function. 
<li><a href="#variable-index">variable index</a>:               An entry for each variable. 
<li><a href="#type-index">type index</a>:                   An entry for each type. 
</ul>

<!-- page -->
<div class="node">
<a name="overview"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#intro">intro</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Overview of the package</h2>

<p>The International Astronomical Union's <acronym>SOFA</acronym> Collection consists of
two libraries of routines, one coded in Fortran 77 the other in
<acronym>ANSI</acronym> C.  There is a suite of vector/matrix routines and
various utilities that underpin the astronomy algorithms, which include
routines for the following:

     <ul>
<li>Calendars.

     <li>Time Scales.

     <li>Earth rotation and sidereal time.

     <li>Ephemerides (medium precision).

     <li>Geocentric/geodetic transformations.

     <li>Precession, nutation, polar motion.

     <li>Star space motion.

     <li>Star catalogue conversion. 
</ul>

   <p>This package makes use of the <acronym>GNU</acronym> Autotools to allow easy
distribution and installation of <acronym>SOFA</acronym>.

   <p>ATSOFA is neither distributed, nor supported, nor endorsed by
the International Astronomical Union.  Any use of this pacakge should
comply with <acronym>SOFA</acronym>'s license and terms of use.  Especially, but not
exclusively, any published work or commercial products which includes
results achieved by using ATSOFA shall acknowledge that the
<acronym>SOFA</acronym> software was used in obtaining those results.

<!-- page -->
<div class="node">
<a name="intro"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#astronomy">astronomy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#overview">overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 The <acronym>IAU</acronym> <acronym>SOFA</acronym> software libraries</h2>

<p><acronym>SOFA</acronym> stands for &ldquo;Standards Of Fundamental Astronomy&rdquo;.  The <acronym>SOFA</acronym>
software libraries are a collection of subprograms, in source code form,
which implement official <acronym>IAU</acronym> algorithms for fundamental astronomy
computations.  The subprograms at present comprise 131 &rdquo;astronomy&rdquo;
routines supported by 55 &ldquo;vector/matrix&rdquo; routines, available in both
Fortran77 and C implementations.

<!--  -->
<h3 class="section">2.1 The <acronym>SOFA</acronym> initiative</h3>

<p><acronym>SOFA</acronym> is an <acronym>IAU</acronym> Service which operates under Division 1
(Fundamental Astronomy) and reports through Commission 19 (Rotation of
the Earth).

   <p>The <acronym>IAU</acronym> set up the <acronym>SOFA</acronym> initiative at the 1994 General Assembly,
to promulgate an authoritative set of fundamental astronomy constants
and algorithms.  At the subsequent General Assembly, in 1997, the
appointment of a <acronym>SOFA</acronym> Review Board and the selection of a site for
the <acronym>SOFA</acronym> Center (the outlet for <acronym>SOFA</acronym> products) were announced.

   <p>The <acronym>SOFA</acronym> initiative was originally proposed by the <acronym>IAU</acronym> Working
Group on Astronomical Standards (<acronym>WGAS</acronym>), under the chairmanship
of Toshio Fukushima.  The proposal was for &ldquo;<small class="dots">...</small>new arrangements to
establish and maintain an accessible and authoritative set of constants,
algorithms and procedures that implement standard models used in
fundamental astronomy&rdquo;.  The <acronym>SOFA</acronym> Software Libraries implement the
&ldquo;algorithms&rdquo; part of the <acronym>SOFA</acronym> initiative.  They were developed
under the supervision of an international panel called the <acronym>SOFA</acronym>
Review Board.  The current membership of this panel is listed in an
appendix.

   <p>A feature of the original <acronym>SOFA</acronym> software proposals was that the
products would be self&ndash;contained and not depend on other software. 
This includes basic documentation, which, like the present file, will
mostly be plain <acronym>ASCII</acronym> text.  It should also be noted that
there is no assumption that the software will be used on a particular
computer and Operating System.  Although OS&ndash;related facilities may be
present (Unix make files for instance, use by the <acronym>SOFA</acronym> Center of
automatic code management systems, <acronym>HTML</acronym> versions of some
documentation), the routines themselves will be visible as individual
text files and will run on a variety of platforms.

<!--  -->
<h3 class="section">2.2 Algorithms</h3>

<p>The <acronym>SOFA</acronym> Review Board's initial goal has been to create a set of
callable subprograms.  Whether &ldquo;subroutines&rdquo; or &ldquo;functions&rdquo;, they
are all referred to simply as &ldquo;routines&rdquo;.  They are designed for use
by software developers wishing to write complete applications; no
runnable, free&ndash;standing applications are included in <acronym>SOFA</acronym>'s present
plans.

   <p>The algorithms are drawn from a variety of sources.  Because most of the
routines so far developed have either been standard &ldquo;text&ndash;book&rdquo;
operations or implement well&ndash;documented standard algorithms, it has not
been necessary to invite the whole community to submit algorithms,
though consultation with authorities has occurred where necessary.  It
should also be noted that consistency with the conventions published by
the International Earth Rotation Service was a stipulation in the
original <acronym>SOFA</acronym> proposals, further constraining the software designs. 
This state of affairs will continue to exist for some time, as there is
a large backlog of agreed extensions to work on.  However, in the future
the Board may decide to call for proposals, and is in the meantime
willing to look into any suggestions that are received by the <acronym>SOFA</acronym>
Center.

<!--  -->
<h3 class="section">2.3 Scope</h3>

<p>The routines currently available are listed in the next two chapters of
this document.

   <p>The &ldquo;astronomy&rdquo; library comprises 131 routines (plus one obsolete
Fortran routine that now appears under a revised name).  The areas
addressed include calendars, time scales, ephemerides,
precession&ndash;nutation, star space&ndash;motion, star catalog transformations
and geodetic/geocentric transformations.

   <p>The &ldquo;vector&ndash;matrix&rdquo; library, comprising 55 routines, contains a
collection of simple tools for manipulating the vectors, matrices and
angles used by the astronomy routines.

   <p>There is no explicit commitment by <acronym>SOFA</acronym> to support historical models,
though as time goes on a legacy of superseded models will naturally
accumulate.  There is, for example, no support of B1950/FK4 star
coordinates, or pre-1976 precession models, though these capabilities
could be added were there significant demand.

   <p>Though the <acronym>SOFA</acronym> software libraries are rather limited in scope, and
are likely to remain so for a considerable time, they do offer distinct
advantages to prospective users.  In particular, the routines are:

     <ul>
<li>authoritative: they are <acronym>IAU</acronym>&ndash;backed and have been constructed with
great care;

     <li>practical: they are straightforward to use in spite of being precise and
rigorous (to some stated degree);

     <li>accessible and supported: they are downloadable from an easy&ndash;to&ndash;find
place, they are in an integrated and consistent form, they come with
adequate internal documentation, and help for users is available. 
</ul>

<!--  -->
<h3 class="section">2.4 Versions</h3>

<p>Once it has been published, an issue is never revised or updated, and
remains accessible indefinitely.  Subsequent issues may, however,
include corrected versions under the original routine name and
filenames.  However, where a different model is introduced, it will have
a different name.

   <p>The issues will be referred to by the date when they were announced. 
The frequency of re&ndash;issue will be decided by the Board, taking into
account the importance of the changes and the impact on the user
community.

<!--  -->
<h3 class="section">2.5 Documentation</h3>

<p>At present there is little free&ndash;standing documentation about individual
routines.  However, each routine has preamble comments which specify in
detail what the routine does and how it is used.

   <p>The file <samp><span class="file">sofa_pn.pdf</span></samp> describes the <acronym>SOFA</acronym> tools for
precession&ndash;nutation and other aspects of Earth attitude and includes
example code and (see the appendix) diagrams showing the
interrelationships between the routines supporting the latest (<acronym>IAU</acronym>
2006/2000A) models.

<!--  -->
<h3 class="section">2.6 Programming languages and standards</h3>

<p>The <acronym>SOFA</acronym> routines are available in two programming languages at
present: Fortran77 and ANSI C.  Related software in other languages is
under consideration.

   <p>The Fortran code conforms to <acronym>ANSI</acronym> X3.9-1978 in all but two
minor respects: each has an <code>IMPLICIT NONE</code> declaration, and its
name has a prefix of <code>iau_</code> and may be longer than 6 characters.  A
global edit to erase both of these will produce <code>ANSI</code>&ndash;compliant
code with no change in its function.

   <p>Coding style, and restrictions on the range of language features, have
been much debated by the Board, and the results comply with the majority
view.  There is (at present) no document that defines the standards, but
the code itself offers a wide range of examples of what is acceptable.

   <p>The Fortran routines contain explicit numerical constants (the
<code>INCLUDE</code> statement is not part of <acronym>ANSI</acronym> Fortran77). 
These are drawn from the file <samp><span class="file">consts.lis</span></samp>, which is listed in an
appendix.  Constants for the <acronym>SOFA</acronym>/C functions are defined in a header
file <samp><span class="file">sofam.h</span></samp>.

   <p>The naming convention is such that a <acronym>SOFA</acronym> routine referred to
generically as <code>EXAMPL</code> exists as a Fortran subprogram
<code>iau_EXAMPL</code> and a C function <code>iauExampl</code>.  The calls for the
two versions are very similar, with the same arguments in the same
order.  In a few cases, the C equivalent of a Fortran <code>SUBROUTINE</code>
subprogram uses a return value rather than an argument.

   <p>Each language version includes a &ldquo;testbed&rdquo; main&ndash;program that can be
used to verify that the <acronym>SOFA</acronym> routines have been correctly compiled on
the end user's system.  The Fortran and C versions are called
<samp><span class="file">t_sofa_f.for</span></samp> and <samp><span class="file">t_sofa_c.c</span></samp> respectively.  The testbeds
execute every <acronym>SOFA</acronym> routine and check that the results are within
expected accuracy margins.  It is not possible to guarantee that all
platforms will meet the rather stringent criteria that have been used,
and an occasional warning message may be encountered on some systems.

<!--  -->
<h3 class="section">2.7 Copyright issues</h3>

<p>Copyright for all of the <acronym>SOFA</acronym> software and documentation is owned by
the <acronym>IAU</acronym> <acronym>SOFA</acronym> Review Board.  The Software is made available free of
charge for all classes of user, including commercial.  However, there
are strict rules designed to avoid unauthorized variants coming into
circulation.  It is permissible to distribute derived works and other
modifications, but they must be clearly marked to avoid confusion with
the <acronym>SOFA</acronym> originals.

   <p>Further details are included in the block of comments which concludes
every routine.  The text is also set out in an appendix to the present
document.

<!--  -->
<h3 class="section">2.8 Accuracy</h3>

<p>The <acronym>SOFA</acronym> policy is to organize the calculations so that the machine
accuracy is fully exploited.  The gap between the precision of the
underlying model or theory and the computational resolution has to be
kept as large as possible, hopefully leaving several orders of magnitude
of headroom.

   <p>The <acronym>SOFA</acronym> routines in some cases involve design compromises between
rigor and ease of use (and also speed, though nowadays this is seldom a
major concern).

<!--  -->
<h3 class="section">2.9 Acknowledgements</h3>

<p>The Board is indebted to a number of contributors, who are acknowledged
in the preamble comments of the routines concerned.

   <p>The Board's effort is provided by the members' individual institutes.

   <p>Resources for operating the <acronym>SOFA</acronym> Center are provided by Her Majesty's
Nautical Almanac Office, operated by the United Kingdom Hydrographic
Office.

<!-- page -->
<div class="node">
<a name="astronomy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#vector-matrix">vector matrix</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#intro">intro</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 <acronym>SOFA</acronym> Astronomy Library</h2>

<h3 class="section">3.1 Preface</h3>

<p>The routines described here comprise the <acronym>SOFA</acronym> astronomy library. 
Their general appearance and coding style conforms to conventions agreed
by the <acronym>SOFA</acronym> Review Board, and their functions, names and algorithms
have been ratified by the Board.  Procedures for soliciting and agreeing
additions to the library are still evolving.

<!--  -->
<h3 class="section">3.2 Programming languages</h3>

<p>The <acronym>SOFA</acronym> routines are available in two programming languages at
present: Fortran 77 and <acronym>ANSI</acronym> C.

   <p>Except for a single obsolete Fortran routine, which has no C equivalent,
there is a one&ndash;to&ndash;one relationship between the two language versions. 
The naming convention is such that a <acronym>SOFA</acronym> routine referred to
generically as <code>EXAMPL</code> exists as a Fortran subprogram
<code>iau_EXAMPL</code> and a C function <code>iauExampl</code>.  The calls for the
two versions are very similar, with the same arguments in the same
order.  In a few cases, the C equivalent of a Fortran <code>SUBROUTINE</code>
subprogram uses a return value rather than an argument.

<!--  -->
<h3 class="section">3.3 General principles</h3>

<p>The principal function of the <acronym>SOFA</acronym> Astronomy Library is to provide
definitive algorithms.  A secondary function is to provide software
suitable for convenient direct use by writers of astronomical
applications.

   <p>The astronomy routines call on the <acronym>SOFA</acronym> vector/matrix library
routines, which are separately listed.

   <p>The routines are designed to exploit the full floating&ndash;point accuracy
of the machines on which they run, and not to rely on compiler
optimizations.  Within these constraints, the intention is that the code
corresponds to the published formulation (if any).

   <p>Dates are always Julian Dates (except in calendar conversion routines)
and are expressed as two double precision numbers which sum to the
required value.

   <p>A distinction is made between routines that implement <acronym>IAU</acronym>&ndash;approved
models and those that use those models to create other results.  The
former are referred to as &ldquo;canonical models&rdquo; in the preamble comments;
the latter are described as &ldquo;support routines&rdquo;.

   <p>Using the library requires knowledge of positional astronomy and
time&ndash;scales.  These topics are covered in &ldquo;Explanatory Supplement to
the Astronomical Almanac&rdquo;, P. Kenneth Seidelmann (ed.), University
Science Books, 1992.  Recent developments are documented in the
journals, and references to the relevant papers are given in the <acronym>SOFA</acronym>
code as required.  The <acronym>IERS</acronym> Conventions are also an essential
reference.  The routines concerned with Earth attitude
(precession&ndash;nutation etc.)  are described in the <acronym>SOFA</acronym> document
<samp><span class="file">sofa_pn.pdf</span></samp>.

<!--  -->
<h3 class="section">3.4 Routines</h3>

<p>Calendars:

     <dl>
<dt><code>CAL2JD</code><dd>Gregorian calendar to Julian Day number.

     <br><dt><code>EPB</code><dd>Julian Date to Besselian Epoch.

     <br><dt><code>EPB2JD</code><dd>Besselian Epoch to Julian Date.

     <br><dt><code>EPJ</code><dd>Julian Date to Julian Epoch.

     <br><dt><code>EPJ2JD</code><dd>Julian Epoch to Julian Date.

     <br><dt><code>JD2CAL</code><dd>Julian Date to Gregorian year, month, day, fraction.

     <br><dt><code>JDCALF</code><dd>Julian Date to Gregorian date for formatted output. 
</dl>

   <p>Time scales:

     <dl>
<dt><code>D2DTF</code><dd>Format 2-part JD for output.

     <br><dt><code>DAT</code><dd>Delta(AT) (=TAI-UTC) for a given UTC date.

     <br><dt><code>DTDB</code><dd>TDB-TT.

     <br><dt><code>DTF2D</code><dd>Encode time and date fields into 2-part JD.

     <br><dt><code>TAITT</code><dd>TAI to TT.

     <br><dt><code>TAIUT1</code><dd>TAI to UT1.

     <br><dt><code>TAIUTC</code><dd>TAI to UTC.

     <br><dt><code>TCBTDB</code><dd>TCB to TDB.

     <br><dt><code>TCGTT</code><dd>TCG to TT.

     <br><dt><code>TDBTCB</code><dd>TDB to TCB.

     <br><dt><code>TDBTT</code><dd>TDB to TT.

     <br><dt><code>TTTAI</code><dd>TT to TAI.

     <br><dt><code>TTTCG</code><dd>TT to TCG.

     <br><dt><code>TTTDB</code><dd>TT to TDB.

     <br><dt><code>TTUT1</code><dd>TT to UT1.

     <br><dt><code>UT1TAI</code><dd>UT1 to TAI.

     <br><dt><code>UT1TT</code><dd>UT1 to TT.

     <br><dt><code>UT1UTC</code><dd>UT1 to UTC.

     <br><dt><code>UTCTAI</code><dd>UTC to TAI.

     <br><dt><code>UTCUT1</code><dd>UTC to UT1. 
</dl>

   <p>Earth rotation angle and sidereal time:

     <dl>
<dt><code>EE00</code><dd>equation of the equinoxes, IAU 2000.

     <br><dt><code>EE00A</code><dd>equation of the equinoxes, IAU 2000A.

     <br><dt><code>EE00B</code><dd>equation of the equinoxes, IAU 2000B.

     <br><dt><code>EE06A</code><dd>equation of the equinoxes, IAU 2006/2000A.

     <br><dt><code>EECT00</code><dd>equation of the equinoxes complementary terms, IAU 2000.

     <br><dt><code>EQEQ94</code><dd>equation of the equinoxes, IAU 1994.

     <br><dt><code>ERA00</code><dd>Earth rotation angle, IAU 2000.

     <br><dt><code>GMST00</code><dd>Greenwich mean sidereal time, IAU 2000.

     <br><dt><code>GMST06</code><dd>Greenwich mean sidereal time, IAU 2006.

     <br><dt><code>GMST82</code><dd>Greenwich mean sidereal time, IAU 1982.

     <br><dt><code>GST00A</code><dd>Greenwich apparent sidereal time, IAU 2000A.

     <br><dt><code>GST00B</code><dd>Greenwich apparent sidereal time, IAU 2000B.

     <br><dt><code>GST06</code><dd>Greenwich apparent ST, IAU 2006, given NPB matrix.

     <br><dt><code>GST06A</code><dd>Greenwich apparent sidereal time, IAU 2006/2000A.

     <br><dt><code>GST94</code><dd>Greenwich apparent sidereal time, IAU 1994.

   </dl>

   <p>Ephemerides (limited precision):

     <dl>
<dt><code>EPV00</code><dd>Earth position and velocity.

     <br><dt><code>PLAN94</code><dd>major-planet position and velocity. 
</dl>

   <p>Precession, nutation, polar motion:

     <dl>
<dt><code>BI00</code><dd>frame bias components, IAU 2000.

     <br><dt><code>BP00</code><dd>frame bias and precession matrices, IAU 2000.

     <br><dt><code>BP06</code><dd>frame bias and precession matrices, IAU 2006.

     <br><dt><code>BPN2XY</code><dd>extract CIP X,Y coordinates from NPB matrix.

     <br><dt><code>C2I00A</code><dd>celestial-to-intermediate matrix, IAU 2000A.

     <br><dt><code>C2I00B</code><dd>celestial-to-intermediate matrix, IAU 2000B.

     <br><dt><code>C2I06A</code><dd>celestial-to-intermediate matrix, IAU 2006/2000A.

     <br><dt><code>C2IBPN</code><dd>celestial-to-intermediate matrix, given NPB matrix, IAU 2000.

     <br><dt><code>C2IXY</code><dd>celestial-to-intermediate matrix, given X,Y, IAU 2000.

     <br><dt><code>C2IXYS</code><dd>celestial-to-intermediate matrix, given X,Y and s.

     <br><dt><code>C2T00A</code><dd>celestial-to-terrestrial matrix, IAU 2000A.

     <br><dt><code>C2T00B</code><dd>celestial-to-terrestrial matrix, IAU 2000B.

     <br><dt><code>C2T06A</code><dd>celestial-to-terrestrial matrix, IAU 2006/2000A.

     <br><dt><code>C2TCIO</code><dd>form CIO-based celestial-to-terrestrial matrix.

     <br><dt><code>C2TEQX</code><dd>form equinox-based celestial-to-terrestrial matrix.

     <br><dt><code>C2TPE</code><dd>celestial-to-terrestrial matrix given nutation, IAU 2000.

     <br><dt><code>C2TXY</code><dd>celestial-to-terrestrial matrix given CIP, IAU 2000.

     <br><dt><code>EO06A</code><dd>equation of the origins, IAU 2006/2000A.

     <br><dt><code>EORS</code><dd>equation of the origins, given NPB matrix and s.

     <br><dt><code>FW2M</code><dd>Fukushima-Williams angles to r-matrix.

     <br><dt><code>FW2XY</code><dd>Fukushima-Williams angles to X,Y.

     <br><dt><code>NUM00A</code><dd>nutation matrix, IAU 2000A.

     <br><dt><code>NUM00B</code><dd>nutation matrix, IAU 2000B.

     <br><dt><code>NUM06A</code><dd>nutation matrix, IAU 2006/2000A.

     <br><dt><code>NUMAT</code><dd>form nutation matrix.

     <br><dt><code>NUT00A</code><dd>nutation, IAU 2000A.

     <br><dt><code>NUT00B</code><dd>nutation, IAU 2000B.

     <br><dt><code>NUT06A</code><dd>nutation, IAU 2006/2000A.

     <br><dt><code>NUT80</code><dd>nutation, IAU 1980.

     <br><dt><code>NUTM80</code><dd>nutation matrix, IAU 1980.

     <br><dt><code>OBL06</code><dd>mean obliquity, IAU 2006.

     <br><dt><code>OBL80</code><dd>mean obliquity, IAU 1980.

     <br><dt><code>PB06</code><dd>zeta,z,theta precession angles, IAU 2006, including bias.

     <br><dt><code>PFW06</code><dd>bias-precession Fukushima-Williams angles, IAU 2006.

     <br><dt><code>PMAT00</code><dd>precession matrix (including frame bias), IAU 2000.

     <br><dt><code>PMAT06</code><dd>PB matrix, IAU 2006.

     <br><dt><code>PMAT76</code><dd>precession matrix, IAU 1976.

     <br><dt><code>PN00</code><dd>bias/precession/nutation results, IAU 2000.

     <br><dt><code>PN00A</code><dd>bias/precession/nutation, IAU 2000A.

     <br><dt><code>PN00B</code><dd>bias/precession/nutation, IAU 2000B.

     <br><dt><code>PN06</code><dd>bias/precession/nutation results, IAU 2006.

     <br><dt><code>PN06A</code><dd>bias/precession/nutation results, IAU 2006/2000A.

     <br><dt><code>PNM00A</code><dd>classical NPB matrix, IAU 2000A.

     <br><dt><code>PNM00B</code><dd>classical NPB matrix, IAU 2000B.

     <br><dt><code>PNM06A</code><dd>classical NPB matrix, IAU 2006/2000A.

     <br><dt><code>PNM80</code><dd>precession/nutation matrix, IAU 1976/1980.

     <br><dt><code>P06E</code><dd>precession angles, IAU 2006, equinox based.

     <br><dt><code>POM00</code><dd>polar motion matrix.

     <br><dt><code>PR00</code><dd>IAU 2000 precession adjustments.

     <br><dt><code>PREC76</code><dd>accumulated precession angles, IAU 1976.

     <br><dt><code>S00</code><dd>the CIO locator s, given X,Y, IAU 2000A.

     <br><dt><code>S00A</code><dd>the CIO locator s, IAU 2000A.

     <br><dt><code>S00B</code><dd>the CIO locator s, IAU 2000B.

     <br><dt><code>S06</code><dd>the CIO locator s, given X,Y, IAU 2006.

     <br><dt><code>S06A</code><dd>the CIO locator s, IAU 2006/2000A.

     <br><dt><code>SP00</code><dd>the TIO locator s', IERS 2003.

     <br><dt><code>XY06</code><dd>CIP, IAU 2006/2000A, from series.

     <br><dt><code>XYS00A</code><dd>CIP and s, IAU 2000A.

     <br><dt><code>XYS00B</code><dd>CIP and s, IAU 2000B.

     <br><dt><code>XYS06A</code><dd>CIP and s, IAU 2006/2000A. 
</dl>

   <p>Fundamental arguments for nutation etc.

     <dl>
<dt><code>FAD03</code><dd>mean elongation of the Moon from the Sun.

     <br><dt><code>FAE03</code><dd>mean longitude of Earth.

     <br><dt><code>FAF03</code><dd>mean argument of the latitude of the Moon.

     <br><dt><code>FAJU03</code><dd>mean longitude of Jupiter.

     <br><dt><code>FAL03</code><dd>mean anomaly of the Moon.

     <br><dt><code>FALP03</code><dd>mean anomaly of the Sun.

     <br><dt><code>FAMA03</code><dd>mean longitude of Mars.

     <br><dt><code>FAME03</code><dd>mean longitude of Mercury.

     <br><dt><code>FANE03</code><dd>mean longitude of Neptune.

     <br><dt><code>FAOM03</code><dd>mean longitude of the Moon's ascending node.

     <br><dt><code>FAPA03</code><dd>general accumulated precession in longitude.

     <br><dt><code>FASA03</code><dd>mean longitude of Saturn.

     <br><dt><code>FAUR03</code><dd>mean longitude of Uranus.

     <br><dt><code>FAVE03</code><dd>mean longitude of Venus.

   </dl>

   <p>Star space motion:

     <dl>
<dt><code>PVSTAR</code><dd>space motion pv-vector to star catalog data.

     <br><dt><code>STARPV</code><dd>star catalog data to space motion pv-vector. 
</dl>

   <p>Star catalog conversions:

     <dl>
<dt><code>FK52H</code><dd>transform FK5 star data into the Hipparcos system.

     <br><dt><code>FK5HIP</code><dd>FK5 to Hipparcos rotation and spin.

     <br><dt><code>FK5HZ</code><dd>FK5 to Hipparcos assuming zero Hipparcos proper motion.

     <br><dt><code>H2FK5</code><dd>transform Hipparcos star data into the FK5 system.

     <br><dt><code>HFK5Z</code><dd>Hipparcos to FK5 assuming zero Hipparcos proper motion.

     <br><dt><code>STARPM</code><dd>proper motion between two epochs. 
</dl>

   <p>Geodetic/geocentric:

     <dl>
<dt><code>EFORM</code><dd>a,f for a nominated Earth reference ellipsoid.

     <br><dt><code>GC2GD</code><dd>geocentric to geodetic for a nominated ellipsoid.

     <br><dt><code>GC2GDE</code><dd>geocentric to geodetic given ellipsoid a,f.

     <br><dt><code>GD2GC</code><dd>geodetic to geocentric for a nominated ellipsoid.

     <br><dt><code>GD2GCE</code><dd>geodetic to geocentric given ellipsoid a,f.

   </dl>

   <p>Obsolete:

     <dl>
<dt><code>C2TCEO</code><dd>former name of C2TCIO. 
</dl>

   <p>Calls: Fortran version:

<pre class="smallexample">     CALL iau_BI00   ( DPSIBI, DEPSBI, DRA )
     CALL iau_BP00   ( DATE1, DATE2, RB, RP, RBP )
     CALL iau_BP06   ( DATE1, DATE2, RB, RP, RBP )
     CALL iau_BPN2XY ( RBPN, X, Y )
     CALL iau_C2I00A ( DATE1, DATE2, RC2I )
     CALL iau_C2I00B ( DATE1, DATE2, RC2I )
     CALL iau_C2I06A ( DATE1, DATE2, RC2I )
     CALL iau_C2IBPN ( DATE1, DATE2, RBPN, RC2I )
     CALL iau_C2IXY  ( DATE1, DATE2, X, Y, RC2I )
     CALL iau_C2IXYS ( X, Y, S, RC2I )
     CALL iau_C2T00A ( TTA, TTB, UTA, UTB, XP, YP, RC2T )
     CALL iau_C2T00B ( TTA, TTB, UTA, UTB, XP, YP, RC2T )
     CALL iau_C2T06A ( TTA, TTB, UTA, UTB, XP, YP, RC2T )
     CALL iau_C2TCEO ( RC2I, ERA, RPOM, RC2T )
     CALL iau_C2TCIO ( RC2I, ERA, RPOM, RC2T )
     CALL iau_C2TEQX ( RBPN, GST, RPOM, RC2T )
     CALL iau_C2TPE  ( TTA, TTB, UTA, UTB, DPSI, DEPS, XP, YP, RC2T )
     CALL iau_C2TXY  ( TTA, TTB, UTA, UTB, X, Y, XP, YP, RC2T )
     CALL iau_CAL2JD ( IY, IM, ID, DJM0, DJM, J )
     CALL iau_D2DTF  ( SCALE, NDP, D1, D2, IY, IM, ID, IHMSF, J )
     CALL iau_DAT    ( IY, IM, ID, FD, DELTAT, J )
     D =  iau_DTDB   ( DATE1, DATE2, UT, ELONG, U, V )
     CALL iau_DTF2D  ( SCALE, IY, IM, ID, IHR, IMN, SEC, D1, D2, J )
     D =  iau_EE00   ( DATE1, DATE2, EPSA, DPSI )
     D =  iau_EE00A  ( DATE1, DATE2 )
     D =  iau_EE00B  ( DATE1, DATE2 )
     D =  iau_EE06A  ( DATE1, DATE2 )
     D =  iau_EECT00 ( DATE1, DATE2 )
     CALL iau_EFORM  ( N, A, F, J )
     D =  iau_EO06A  ( DATE1, DATE2 )
     D =  iau_EORS   ( RNPB, S )
     D =  iau_EPB    ( DJ1, DJ2 )
     CALL iau_EPB2JD ( EPB, DJM0, DJM )
     D =  iau_EPJ    ( DJ1, DJ2 )
     CALL iau_EPJ2JD ( EPJ, DJM0, DJM )
     CALL iau_EPV00  ( DJ1, DJ2, PVH, PVB, J )
     D =  iau_EQEQ94 ( DATE1, DATE2 )
     D =  iau_ERA00  ( DJ1, DJ2 )
     D =  iau_FAD03  ( T )
     D =  iau_FAE03  ( T )
     D =  iau_FAF03  ( T )
     D =  iau_FAJU03 ( T )
     D =  iau_FAL03  ( T )
     D =  iau_FALP03 ( T )
     D =  iau_FAMA03 ( T )
     D =  iau_FAME03 ( T )
     D =  iau_FANE03 ( T )
     D =  iau_FAOM03 ( T )
     D =  iau_FAPA03 ( T )
     D =  iau_FASA03 ( T )
     D =  iau_FAUR03 ( T )
     D =  iau_FAVE03 ( T )
     CALL iau_FK52H  ( R5, D5, DR5, DD5, PX5, RV5,
                        RH, DH, DRH, DDH, PXH, RVH )
     CALL iau_FK5HIP ( R5H, S5H )
     CALL iau_FK5HZ  ( R5, D5, DATE1, DATE2, RH, DH )
     CALL iau_FW2M   ( GAMB, PHIB, PSI, EPS, R )
     CALL iau_FW2XY  ( GAMB, PHIB, PSI, EPS, X, Y )
     CALL iau_GC2GD  ( N, XYZ, ELONG, PHI, HEIGHT, J )
     CALL iau_GC2GDE ( A, F, XYZ, ELONG, PHI, HEIGHT, J )
     CALL iau_GD2GC  ( N, ELONG, PHI, HEIGHT, XYZ, J )
     CALL iau_GD2GCE ( A, F, ELONG, PHI, HEIGHT, XYZ, J )
     D =  iau_GMST00 ( UTA, UTB, TTA, TTB )
     D =  iau_GMST06 ( UTA, UTB, TTA, TTB )
     D =  iau_GMST82 ( UTA, UTB )
     D =  iau_GST00A ( UTA, UTB, TTA, TTB )
     D =  iau_GST00B ( UTA, UTB )
     D =  iau_GST06  ( UTA, UTB, TTA, TTB, RNPB )
     D =  iau_GST06A ( UTA, UTB, TTA, TTB )
     D =  iau_GST94  ( UTA, UTB )
     CALL iau_H2FK5  ( RH, DH, DRH, DDH, PXH, RVH,
                        R5, D5, DR5, DD5, PX5, RV5 )
     CALL iau_HFK5Z  ( RH, DH, DATE1, DATE2, R5, D5, DR5, DD5 )
     CALL iau_JD2CAL ( DJ1, DJ2, IY, IM, ID, FD, J )
     CALL iau_JDCALF ( NDP, DJ1, DJ2, IYMDF, J )
     CALL iau_NUM00A ( DATE1, DATE2, RMATN )
     CALL iau_NUM00B ( DATE1, DATE2, RMATN )
     CALL iau_NUM06A ( DATE1, DATE2, RMATN )
     CALL iau_NUMAT  ( EPSA, DPSI, DEPS, RMATN )
     CALL iau_NUT00A ( DATE1, DATE2, DPSI, DEPS )
     CALL iau_NUT00B ( DATE1, DATE2, DPSI, DEPS )
     CALL iau_NUT06A ( DATE1, DATE2, DPSI, DEPS )
     CALL iau_NUT80  ( DATE1, DATE2, DPSI, DEPS )
     CALL iau_NUTM80 ( DATE1, DATE2, RMATN )
     D =  iau_OBL06  ( DATE1, DATE2 )
     D =  iau_OBL80  ( DATE1, DATE2 )
     CALL iau_PB06   ( DATE1, DATE2, BZETA, BZ, BTHETA )
     CALL iau_PFW06  ( DATE1, DATE2, GAMB, PHIB, PSIB, EPSA )
     CALL iau_PLAN94 ( DATE1, DATE2, NP, PV, J )
     CALL iau_PMAT00 ( DATE1, DATE2, RBP )
     CALL iau_PMAT06 ( DATE1, DATE2, RBP )
     CALL iau_PMAT76 ( DATE1, DATE2, RMATP )
     CALL iau_PN00   ( DATE1, DATE2, DPSI, DEPS,
                        EPSA, RB, RP, RBP, RN, RBPN )
     CALL iau_PN00A  ( DATE1, DATE2,
                        DPSI, DEPS, EPSA, RB, RP, RBP, RN, RBPN )
     CALL iau_PN00B  ( DATE1, DATE2,
                        DPSI, DEPS, EPSA, RB, RP, RBP, RN, RBPN )
     CALL iau_PN06   ( DATE1, DATE2, DPSI, DEPS,
                        EPSA, RB, RP, RBP, RN, RBPN )
     CALL iau_PN06A  ( DATE1, DATE2,
     DPSI, DEPS, RB, RP, RBP, RN, RBPN )
     CALL iau_PNM00A ( DATE1, DATE2, RBPN )
     CALL iau_PNM00B ( DATE1, DATE2, RBPN )
     CALL iau_PNM06A ( DATE1, DATE2, RNPB )
     CALL iau_PNM80  ( DATE1, DATE2, RMATPN )
     CALL iau_P06E   ( DATE1, DATE2,
                        EPS0, PSIA, OMA, BPA, BQA, PIA, BPIA,
                        EPSA, CHIA, ZA, ZETAA, THETAA, PA, GAM, PHI, PSI )
     CALL iau_POM00  ( XP, YP, SP, RPOM )
     CALL iau_PR00   ( DATE1, DATE2, DPSIPR, DEPSPR )
     CALL iau_PREC76 ( EP01, EP02, EP11, EP12, ZETA, Z, THETA )
     CALL iau_PVSTAR ( PV, RA, DEC, PMR, PMD, PX, RV, J )
     D =  iau_S00    ( DATE1, DATE2, X, Y )
     D =  iau_S00A   ( DATE1, DATE2 )
     D =  iau_S00B   ( DATE1, DATE2 )
     D =  iau_S06    ( DATE1, DATE2, X, Y )
     D =  iau_S06A   ( DATE1, DATE2 )
     D =  iau_SP00   ( DATE1, DATE2 )
     CALL iau_STARPM ( RA1, DEC1, PMR1, PMD1, PX1, RV1,
                        EP1A, EP1B, EP2A, EP2B,
                        RA2, DEC2, PMR2, PMD2, PX2, RV2, J )
     CALL iau_STARPV ( RA, DEC, PMR, PMD, PX, RV, PV, J )
     CALL iau_TAITT  ( TAI1, TAI2, TT1, TT2, J )
     CALL iau_TAIUT1 ( TAI1, TAI2, DTA, UT11, UT12, J )
     CALL iau_TAIUTC ( TAI1, TAI2, UTC1, UTC2, J )
     CALL iau_TCBTDB ( TCB1, TCB2, TDB1, TDB2, J )
     CALL iau_TCGTT  ( TCG1, TCG2, TT1, TT2, J )
     CALL iau_TDBTCB ( TDB1, TDB2, TCB1, TCB2, J )
     CALL iau_TDBTT  ( TDB1, TDB2, DTR, TT1, TT2, J )
     CALL iau_TTTAI  ( TT1, TT2, TAI1, TAI2, J )
     CALL iau_TTTCG  ( TT1, TT2, TCG1, TCG2, J )
     CALL iau_TTTDB  ( TT1, TT2, DTR, TDB1, TDB2, J )
     CALL iau_TTUT1  ( TT1, TT2, DT, UT11, UT12, J )
     CALL iau_UT1TAI ( UT11, UT12, TAI1, TAI2, J )
     CALL iau_UT1TT  ( UT11, UT12, DT, TT1, TT2, J )
     CALL iau_UT1UTC ( UT11, UT12, DUT, UTC1, UTC2, J )
     CALL iau_UTCTAI ( UTC1, UTC2, DTA, TAI1, TAI2, J )
     CALL iau_UTCUT1 ( UTC1, UTC2, DUT, UT11, UT12, J )
     CALL iau_XY06   ( DATE1, DATE2, X, Y )
     CALL iau_XYS00A ( DATE1, DATE2, X, Y, S )
     CALL iau_XYS00B ( DATE1, DATE2, X, Y, S )
     CALL iau_XYS06A ( DATE1, DATE2, X, Y, S )
</pre>
   <p>Calls: C version:

<pre class="smallexample">         iauBi00   ( &amp;dpsibi, &amp;depsbi, &amp;dra );
         iauBp00   ( date1, date2, rb, rp, rbp );
         iauBp06   ( date1, date2, rb, rp, rbp );
         iauBpn2xy ( rbpn, &amp;x, &amp;y );
         iauC2i00a ( date1, date2, rc2i );
         iauC2i00b ( date1, date2, rc2i );
         iauC2i06a ( date1, date2, rc2i );
         iauC2ibpn ( date1, date2, rbpn, rc2i );
         iauC2ixy  ( date1, date2, x, y, rc2i );
         iauC2ixys ( x, y, s, rc2i );
         iauC2t00a ( tta, ttb, uta, utb, xp, yp, rc2t );
         iauC2t00b ( tta, ttb, uta, utb, xp, yp, rc2t );
         iauC2t06a ( tta, ttb, uta, utb, xp, yp, rc2t );
         iauC2tcio ( rc2i, era, rpom, rc2t );
         iauC2teqx ( rbpn, gst, rpom, rc2t );
         iauC2tpe  ( tta, ttb, uta, utb, dpsi, deps, xp, yp, rc2t );
         iauC2txy  ( tta, ttb, uta, utb, x, y, xp, yp, rc2t );
     i = iauCal2jd ( iy, im, id, &amp;djm0, &amp;djm );
     i = iauD2dtf  ( scale, ndp, d1, d2, &amp;iy, &amp;im, &amp;id, ihmsf );
     
     i = iauDat    ( iy, im, id, fd, &amp;deltat );
     d = iauDtdb   ( date1, date2, ut, elong, u, v );
     i = iauDtf2d  ( scale, iy, im, id, ihr, imn, sec, &amp;d1, &amp;d2 );
     d = iauEe00   ( date1, date2, epsa, dpsi );
     d = iauEe00a  ( date1, date2 );
     d = iauEe00b  ( date1, date2 );
     d = iauEe06   ( date1, date2 );
     d = iauEect00 ( date1, date2 );
     i = iauEform  ( n, &amp;a, &amp;f );
     d = iauEo06   ( date1, date2 );
     d = iauEors   ( rnpb, s );
     d = iauEpb    ( dj1, dj2 );
         iauEpb2jd ( epb, &amp;djm0, &amp;djm );
     d = iauEpj    ( dj1, dj2 );
         iauEpj2jd ( epj, &amp;djm0, &amp;djm );
     i = iauEpv00  ( dj1, dj2, pvh, pvb );
     d = iauEqeq94 ( date1, date2 );
     d = iauEra00  ( dj1, dj2 );
     d = iauFad03  ( t );
     d = iauFae03  ( t );
     d = iauFaf03  ( t );
     d = iauFaju03 ( t );
     d = iauFal03  ( t );
     d = iauFalp03 ( t );
     d = iauFama03 ( t );
     d = iauFame03 ( t );
     d = iauFane03 ( t );
     d = iauFaom03 ( t );
     d = iauFapa03 ( t );
     d = iauFasa03 ( t );
     d = iauFaur03 ( t );
     d = iauFave03 ( t );
         iauFk52h  ( r5, d5, dr5, dd5, px5, rv5,
                     &amp;rh, &amp;dh, &amp;drh, &amp;ddh, &amp;pxh, &amp;rvh );
         iauFk5hip ( r5h, s5h );
         iauFk5hz  ( r5, d5, date1, date2, &amp;rh, &amp;dh );
         iauFw2m   ( gamb, phib, psi, eps, r );
         iauFw2xy  ( gamb, phib, psi, eps, &amp;x, &amp;y );
     i = iauGc2gd  ( n, xyz, &amp;elong, &amp;phi, &amp;height );
     i = iauGc2gde ( a, f, xyz, &amp;elong, &amp;phi, &amp;height );
     i = iauGd2gc  ( n, elong, phi, height, xyz );
     i = iauGd2gce ( a, f, elong, phi, height, xyz );
     d = iauGmst00 ( uta, utb, tta, ttb );
     d = iauGmst06 ( uta, utb, tta, ttb );
     d = iauGmst82 ( uta, utb );
     d = iauGst00a ( uta, utb, tta, ttb );
     d = iauGst00b ( uta, utb );
     d = iauGst06  ( uta, utb, tta, ttb, rnpb );
     d = iauGst06a ( uta, utb, tta, ttb );
     d = iauGst94  ( uta, utb );
         iauH2fk5  ( rh, dh, drh, ddh, pxh, rvh,
                     &amp;r5, &amp;d5, &amp;dr5, &amp;dd5, &amp;px5, &amp;rv5 );
         iauHfk5z  ( rh, dh, date1, date2,
                     &amp;r5, &amp;d5, &amp;dr5, &amp;dd5 );
     i = iauJd2cal ( dj1, dj2, &amp;iy, &amp;im, &amp;id, &amp;fd );
     i = iauJdcalf ( ndp, dj1, dj2, iymdf );
         iauNum00a ( date1, date2, rmatn );
         iauNum00b ( date1, date2, rmatn );
         iauNum06a ( date1, date2, rmatn );
         iauNumat  ( epsa, dpsi, deps, rmatn );
         iauNut00a ( date1, date2, &amp;dpsi, &amp;deps );
         iauNut00b ( date1, date2, &amp;dpsi, &amp;deps );
         iauNut06a ( date1, date2, &amp;dpsi, &amp;deps );
         iauNut80  ( date1, date2, &amp;dpsi, &amp;deps );
         iauNutm80 ( date1, date2, rmatn );
     d = iauObl06  ( date1, date2 );
     d = iauObl80  ( date1, date2 );
         iauPb06   ( date1, date2, &amp;bzeta, &amp;bz, &amp;btheta );
         iauPfw06  ( date1, date2, &amp;gamb, &amp;phib, &amp;psib, &amp;epsa );
     i = iauPlan94 ( date1, date2, np, pv );
         iauPmat00 ( date1, date2, rbp );
         iauPmat06 ( date1, date2, rbp );
         iauPmat76 ( date1, date2, rmatp );
         iauPn00   ( date1, date2, dpsi, deps,
                     &amp;epsa, rb, rp, rbp, rn, rbpn );
         iauPn00a  ( date1, date2,
                     &amp;dpsi, &amp;deps, &amp;epsa, rb, rp, rbp, rn, rbpn );
         iauPn00b  ( date1, date2,
                     &amp;dpsi, &amp;deps, &amp;epsa, rb, rp, rbp, rn, rbpn );
         iauPn06   ( date1, date2, dpsi, deps,
                     &amp;epsa, rb, rp, rbp, rn, rbpn );
         iauPn06a  ( date1, date2,
                     &amp;dpsi, &amp;deps, &amp;epsa, rb, rp, rbp, rn, rbpn );
         iauPnm00a ( date1, date2, rbpn );
         iauPnm00b ( date1, date2, rbpn );
         iauPnm06a ( date1, date2, rnpb );
         iauPnm80  ( date1, date2, rmatpn );
         iauP06e   ( date1, date2,
                     &amp;eps0, &amp;psia, &amp;oma, &amp;bpa, &amp;bqa, &amp;pia, &amp;bpia,
                     &amp;epsa, &amp;chia, &amp;za, &amp;zetaa, &amp;thetaa, &amp;pa,
                     &amp;gam, &amp;phi, &amp;psi );
         iauPom00  ( xp, yp, sp, rpom );
         iauPr00   ( date1, date2, &amp;dpsipr, &amp;depspr );
         iauPrec76 ( ep01, ep02, ep11, ep12, &amp;zeta, &amp;z, &amp;theta );
     i = iauPvstar ( pv, &amp;ra, &amp;dec, &amp;pmr, &amp;pmd, &amp;px, &amp;rv );
     d = iauS00    ( date1, date2, x, y );
     d = iauS00a   ( date1, date2 );
     d = iauS00b   ( date1, date2 );
     d = iauS06    ( date1, date2, x, y );
     d = iauS06a   ( date1, date2 );
     d = iauSp00   ( date1, date2 );
     i = iauStarpm ( ra1, dec1, pmr1, pmd1, px1, rv1,
                     ep1a, ep1b, ep2a, ep2b,
                     &amp;ra2, &amp;dec2, &amp;pmr2, &amp;pmd2, &amp;px2, &amp;rv2 );
     i = iauStarpv ( ra, dec, pmr, pmd, px, rv, pv );
     i = iauTaitt  ( tai1, tai2, &amp;tt1, &amp;tt2 );
     i = iauTaiut1 ( tai1, tai2, dta, &amp;ut11, &amp;ut12 );
     i = iauTaiutc ( tai1, tai2, &amp;utc1, &amp;utc2 );
     i = iauTcbtdb ( tcb1, tcb2, &amp;tdb1, &amp;tdb2 );
     i = iauTcgtt  ( tcg1, tcg2, &amp;tt1, &amp;tt2 );
     i = iauTdbtcb ( tdb1, tdb2, &amp;tcb1, &amp;tcb2 );
     i = iauTdbtt  ( tdb1, tdb2, dtr, &amp;tt1, &amp;tt2 );
     i = iauTttai  ( tt1, tt2, &amp;tai1, &amp;tai2 );
     i = iauTttcg  ( tt1, tt2, &amp;tcg1, &amp;tcg2 );
     i = iauTttdb  ( tt1, tt2, dtr, &amp;tdb1, &amp;tdb2 );
     i = iauTtut1  ( tt1, tt2, dt, &amp;ut11, &amp;ut12 );
     i = iauUt1tai ( ut11, ut12, &amp;tai1, &amp;tai2 );
     i = iauUt1tt  ( ut11, ut12, dt, &amp;tt1, &amp;tt2 );
     i = iauUt1utc ( ut11, ut12, dut, &amp;utc1, &amp;utc2 );
     i = iauUtctai ( utc1, utc2, dta, &amp;tai1, &amp;tai2 );
     i = iauUtcut1 ( utc1, utc2, dut, &amp;ut11, &amp;ut12 );
         iauXy06   ( date1, date2, &amp;x, &amp;y );
         iauXys00a ( date1, date2, &amp;x, &amp;y, &amp;s );
         iauXys00b ( date1, date2, &amp;x, &amp;y, &amp;s );
         iauXys06a ( date1, date2, &amp;x, &amp;y, &amp;s );
</pre>
   <!-- page -->
<div class="node">
<a name="vector-matrix"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api">api</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#astronomy">astronomy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 <acronym>SOFA</acronym> Vector/Matrix Library</h2>

<h3 class="section">4.1 Preface</h3>

<p>The routines described here comprise the <acronym>SOFA</acronym> vector/matrix library. 
Their general appearance and coding style conforms to conventions agreed
by the <acronym>SOFA</acronym> Review Board, and their functions, names and algorithms
have been ratified by the Board.  Procedures for soliciting and agreeing
additions to the library are still evolving.

<!--  -->
<h3 class="section">4.2 Programming languages</h3>

<p>The <acronym>SOFA</acronym> routines are available in two programming languages at
present: Fortran 77 and ANSI C.

   <p>There is a one&ndash;to&ndash;one relationship between the two language versions. 
The naming convention is such that a <acronym>SOFA</acronym> routine referred to
generically as <code>EXAMPL</code> exists as a Fortran subprogram
<code>iau_EXAMPL</code> and a C function <code>iauExampl</code>.  The calls for the
two versions are very similar, with the same arguments in the same
order.  In a few cases, the C equivalent of a Fortran <code>SUBROUTINE</code>
subprogram uses a return value rather than an argument.

<!--  -->
<h3 class="section">4.3 General principles</h3>

<p>The library consists mostly of routines which operate on ordinary
Cartesian vectors (x, y, z) and 3x3 rotation matrices.  However,
there is also support for vectors which represent velocity as well as
position and vectors which represent rotation instead of position.  The
vectors which represent both position and velocity may be considered
still to have dimensions <code>(3)</code>, but to comprise elements each of
which is two numbers, representing the value itself and the time
derivative.  Thus:

     <ul>
<li>&ldquo;Position&rdquo; or <code>p</code> vectors (or just plain 3-vectors) have
dimension <code>(3)</code> in Fortran and <code>[3]</code> in C.

     <li>&ldquo;Position/velocity&rdquo; or <code>pv</code> vectors have dimensions <code>(3,2)</code>
in Fortran and <code>[2][3]</code> in C.

     <li>&ldquo;Rotation&rdquo; or <code>r</code> matrices have dimensions <code>(3,3)</code> in
Fortran and <code>[3][3]</code> in C.  When used for rotation, they are
&ldquo;orthogonal&rdquo;; the inverse of such a matrix is equal to the transpose. 
Most of the routines in this library do not assume that
<code>r</code>-matrices are necessarily orthogonal and in fact work on any 3x3
matrix.

     <li>&ldquo;Rotation&rdquo; or <code>r</code> vectors have dimensions <code>(3)</code> in Fortran
and <code>[3]</code> in C.  Such vectors are a combination of the Euler axis
and angle and are convertible to and from <code>r</code>-matrices.  The
direction is the axis of rotation and the magnitude is the angle of
rotation, in radians.  Because the amount of rotation can be scaled up
and down simply by multiplying the vector by a scalar, <code>r</code>-vectors
are useful for representing spins about an axis which is fixed.

     <li>The above rules mean that in terms of memory address, the three velocity
components of a <code>pv</code>-vector follow the three position components. 
Application code is permitted to exploit this and all other knowledge of
the internal layouts: that x, y and z appear in
that order and are in a right&ndash;handed Cartesian coordinate system etc. 
For example, the <code>cp</code> function (copy a <code>p</code>-vector) can be used
to copy the velocity component of a <code>pv</code>-vector (indeed, this is
how the <code>CPV</code> routine is coded).

     <li>The routines provided do not completely fill the range of operations
that link all the various vector and matrix options, but are confined to
functions that are required by other parts of the <acronym>SOFA</acronym> software or
which are likely to prove useful. 
</ul>

   <p>In addition to the vector/matrix routines, the library contains some
routines related to spherical angles, including conversions to and from
sexagesimal format.

   <p>Using the library requires knowledge of vector/matrix methods, spherical
trigonometry, and methods of attitude representation.  These topics are
covered in many textbooks, including &ldquo;Spacecraft Attitude Determination
and Control&rdquo;, James R. Wertz (ed.), Astrophysics and Space Science
Library, Vol. 73, D. Reidel Publishing Company, 1986.

<!--  -->
<h3 class="section">4.4 Operations involving <code>p</code>-vectors and <code>r</code>-matrices</h3>

<p>Initialize:

     <dl>
<dt><code>ZP</code><dd>zero <code>p</code>-vector.

     <br><dt><code>ZR</code><dd>initialize <code>r</code>-matrix to null.

     <br><dt><code>IR</code><dd>initialize <code>r</code>-matrix to identity. 
</dl>

   <p>Copy/extend/extract:

     <dl>
<dt><code>CP</code><dd>copy <code>p</code>-vector.

     <br><dt><code>CR</code><dd>copy <code>r</code>-matrix. 
</dl>

   <p>Build rotations:

     <dl>
<dt><code>RX</code><dd>rotate <code>r</code>-matrix about x.

     <br><dt><code>RY</code><dd>rotate <code>r</code>-matrix about y.

     <br><dt><code>RZ</code><dd>rotate <code>r</code>-matrix about z. 
</dl>

   <p>Spherical/Cartesian conversions:

     <dl>
<dt><code>S2C</code><dd>spherical to unit vector.

     <br><dt><code>C2S</code><dd>unit vector to spherical.

     <br><dt><code>S2P</code><dd>spherical to <code>p</code>-vector.

     <br><dt><code>P2S</code><dd><code>p</code>-vector to spherical. 
</dl>

   <p>Operations on vectors:

     <dl>
<dt><code>PPP</code><dd><code>p</code>-vector plus <code>p</code>-vector.

     <br><dt><code>PMP</code><dd><code>p</code>-vector minus <code>p</code>-vector.

     <br><dt><code>PPSP</code><dd><code>p</code>-vector plus scaled <code>p</code>-vector.

     <br><dt><code>PDP</code><dd>inner (=scalar=dot) product of two <code>p</code>-vectors.

     <br><dt><code>PXP</code><dd>outer (=vector=cross) product of two <code>p</code>-vectors.

     <br><dt><code>PM</code><dd>modulus of <code>p</code>-vector.

     <br><dt><code>PN</code><dd>normalize <code>p</code>-vector returning modulus.

     <br><dt><code>SXP</code><dd>multiply <code>p</code>-vector by scalar. 
</dl>

   <p>Operations on matrices:

     <dl>
<dt><code>RXR</code><dd><code>r</code>-matrix multiply.

     <br><dt><code>TR</code><dd>transpose <code>r</code>-matrix. 
</dl>

   <p>Matrix&ndash;vector products:

     <dl>
<dt><code>RXP</code><dd>product of <code>r</code>-matrix and <code>p</code>-vector.

     <br><dt><code>TRXP</code><dd>product of transpose of <code>r</code>-matrix and <code>p</code>-vector. 
</dl>

   <p>Separation and position&ndash;angle:

     <dl>
<dt><code>SEPP</code><dd>angular separation from <code>p</code>-vectors.

     <br><dt><code>SEPS</code><dd>angular separation from spherical coordinates.

     <br><dt><code>PAP</code><dd>position&ndash;angle from <code>p</code>-vectors.

     <br><dt><code>PAS</code><dd>position&ndash;angle from spherical coordinates. 
</dl>

   <p>Rotation vectors:

     <dl>
<dt><code>RV2M</code><dd><code>r</code>-vector to <code>r</code>-matrix.

     <br><dt><code>RM2V</code><dd><code>r</code>-matrix to <code>r</code>-vector. 
</dl>

<!--  -->
<h3 class="section">4.5 Operations involving <code>pv</code>-vectors</h3>

<p>Initialize:

     <dl>
<dt><code>ZPV</code><dd>zero <code>pv</code>-vector. 
</dl>

   <p>Copy/extend/extract:

     <dl>
<dt><code>CPV</code><dd>copy <code>pv</code>-vector.

     <br><dt><code>P2PV</code><dd>append zero velocity to <code>p</code>-vector.

     <br><dt><code>PV2P</code><dd>discard velocity component of <code>pv</code>-vector. 
</dl>

   <p>Spherical/Cartesian conversions:

     <dl>
<dt><code>S2PV</code><dd>spherical to <code>pv</code>-vector.

     <br><dt><code>PV2S</code><dd><code>pv</code>-vector to spherical. 
</dl>

   <p>Operations on vectors:

     <dl>
<dt><code>PVPPV</code><dd><code>pv</code>-vector plus <code>pv</code>-vector.

     <br><dt><code>PVMPV</code><dd><code>pv</code>-vector minus <code>pv</code>-vector.

     <br><dt><code>PVDPV</code><dd>inner (=scalar=dot) product of two <code>pv</code>-vectors.

     <br><dt><code>PVXPV</code><dd>outer (=vector=cross) product of two <code>pv</code>-vectors.

     <br><dt><code>PVM</code><dd>modulus of <code>pv</code>-vector.

     <br><dt><code>SXPV</code><dd>multiply <code>pv</code>-vector by scalar.

     <br><dt><code>S2XPV</code><dd>multiply <code>pv</code>-vector by two scalars.

     <br><dt><code>PVU</code><dd>update <code>pv</code>-vector.

     <br><dt><code>PVUP</code><dd>update <code>pv</code>-vector discarding velocity. 
</dl>

   <p>Matrix&ndash;vector products:

     <dl>
<dt><code>RXPV</code><dd>product of <code>r</code>-matrix and <code>pv</code>-vector.

     <br><dt><code>TRXPV</code><dd>product of transpose of <code>r</code>-matrix and <code>pv</code>-vector. 
</dl>

   <p>Operations on angles:

     <dl>
<dt><code>ANP</code><dd>normalize radians to range <code>0</code> to <code>2pi</code>.

     <br><dt><code>ANPM</code><dd>normalize radians to range <code>-pi</code> to <code>+pi</code>.

     <br><dt><code>A2TF</code><dd>decompose radians into hours, minutes, seconds.

     <br><dt><code>A2AF</code><dd>decompose radians into degrees, arcminutes, arcseconds.

     <br><dt><code>AF2A</code><dd>degrees, arcminutes, arcseconds to radians.

     <br><dt><code>D2TF</code><dd>decompose days into hours, minutes, seconds.

     <br><dt><code>TF2A</code><dd>hours, minutes, seconds to radians.

     <br><dt><code>TF2D</code><dd>hours, minutes, seconds to days. 
</dl>

   <p>Calls: Fortran version

<pre class="smallexample">     CALL iau_A2AF  ( NDP, ANGLE, SIGN, IDMSF )
     CALL iau_A2TF  ( NDP, ANGLE, SIGN, IHMSF )
     CALL iau_AF2A  ( S, IDEG, IAMIN, ASEC, RAD, J )
     D =  iau_ANP   ( A )
     D =  iau_ANPM  ( A )
     CALL iau_C2S   ( P, THETA, PHI )
     CALL iau_CP    ( P, C )
     CALL iau_CPV   ( PV, C )
     CALL iau_CR    ( R, C )
     CALL iau_D2TF  ( NDP, DAYS, SIGN, IHMSF )
     CALL iau_IR    ( R )
     CALL iau_P2PV  ( P, PV )
     CALL iau_P2S   ( P, THETA, PHI, R )
     CALL iau_PAP   ( A, B, THETA )
     CALL iau_PAS   ( AL, AP, BL, BP, THETA )
     CALL iau_PDP   ( A, B, ADB )
     CALL iau_PM    ( P, R )
     CALL iau_PMP   ( A, B, AMB )
     CALL iau_PN    ( P, R, U )
     CALL iau_PPP   ( A, B, APB )
     CALL iau_PPSP  ( A, S, B, APSB )
     CALL iau_PV2P  ( PV, P )
     CALL iau_PV2S  ( PV, THETA, PHI, R, TD, PD, RD )
     CALL iau_PVDPV ( A, B, ADB )
     CALL iau_PVM   ( PV, R, S )
     CALL iau_PVMPV ( A, B, AMB )
     CALL iau_PVPPV ( A, B, APB )
     CALL iau_PVU   ( DT, PV, UPV )
     CALL iau_PVUP  ( DT, PV, P )
     CALL iau_PVXPV ( A, B, AXB )
     CALL iau_PXP   ( A, B, AXB )
     CALL iau_RM2V  ( R, P )
     CALL iau_RV2M  ( P, R )
     CALL iau_RX    ( PHI, R )
     CALL iau_RXP   ( R, P, RP )
     CALL iau_RXPV  ( R, PV, RPV )
     CALL iau_RXR   ( A, B, ATB )
     CALL iau_RY    ( THETA, R )
     CALL iau_RZ    ( PSI, R )
     CALL iau_S2C   ( THETA, PHI, C )
     CALL iau_S2P   ( THETA, PHI, R, P )
     CALL iau_S2PV  ( THETA, PHI, R, TD, PD, RD, PV )
     CALL iau_S2XPV ( S1, S2, PV )
     CALL iau_SEPP  ( A, B, S )
     CALL iau_SEPS  ( AL, AP, BL, BP, S )
     CALL iau_SXP   ( S, P, SP )
     CALL iau_SXPV  ( S, PV, SPV )
     CALL iau_TF2A  ( S, IHOUR, IMIN, SEC, RAD, J )
     CALL iau_TF2D  ( S, IHOUR, IMIN, SEC, DAYS, J )
     CALL iau_TR    ( R, RT )
     CALL iau_TRXP  ( R, P, TRP )
     CALL iau_TRXPV ( R, PV, TRPV )
     CALL iau_ZP    ( P )
     CALL iau_ZPV   ( PV )
     CALL iau_ZR    ( R )
</pre>
   <p>Calls: C version:

<pre class="smallexample">         iauA2af  ( ndp, angle, &amp;sign, idmsf );
         iauA2tf  ( ndp, angle, &amp;sign, ihmsf );
     i = iauAf2a  ( s, ideg, iamin, asec, &amp;rad );
     d = iauAnp   ( a );
     d = iauAnpm  ( a );
         iauC2s   ( p, &amp;theta, &amp;phi );
         iauCp    ( p, c );
         iauCpv   ( pv, c );
         iauCr    ( r, c );
         iauD2tf  ( ndp, days, &amp;sign, ihmsf );
         iauIr    ( r );
         iauP2pv  ( p, pv );
         iauP2s   ( p, &amp;theta, &amp;phi, &amp;r );
     d = iauPap   ( a, b );
     d = iauPas   ( al, ap, bl, bp );
     d = iauPdp   ( a, b );
     d = iauPm    ( p );
         iauPmp   ( a, b, amb );
         iauPn    ( p, &amp;r, u );
         iauPpp   ( a, b, apb );
         iauPpsp  ( a, s, b, apsb );
         iauPv2p  ( pv, p );
         iauPv2s  ( pv, &amp;theta, &amp;phi, &amp;r, &amp;td, &amp;pd, &amp;rd );
         iauPvdpv ( a, b, adb );
         iauPvm   ( pv, &amp;r, &amp;s );
         iauPvmpv ( a, b, amb );
         iauPvppv ( a, b, apb );
         iauPvu   ( dt, pv, upv );
         iauPvup  ( dt, pv, p );
         iauPvxpv ( a, b, axb );
         iauPxp   ( a, b, axb );
         iauRm2v  ( r, p );
         iauRv2m  ( p, r );
         iauRx    ( phi, r );
         iauRxp   ( r, p, rp );
         iauRxpv  ( r, pv, rpv );
         iauRxr   ( a, b, atb );
         iauRy    ( theta, r );
         iauRz    ( psi, r );
         iauS2c   ( theta, phi, c );
         iauS2p   ( theta, phi, r, p );
         iauS2pv  ( theta, phi, r, td, pd, rd, pV );
         iauS2xpv ( s1, s2, pv );
     d = iauSepp  ( a, b );
     d = iauSeps  ( al, ap, bl, bp );
         iauSxp   ( s, p, sp );
         iauSxpv  ( s, pv, spv );
     i = iauTf2a  ( s, ihour, imin, sec, &amp;rad );
     i = iauTf2d  ( s, ihour, imin, sec, &amp;days );
         iauTr    ( r, rt );
         iauTrxp  ( r, p, trp );
         iauTrxpv ( r, pv, trpv );
         iauZp    ( p );
         iauZpv   ( pv );
         iauZr    ( r );
</pre>
   <!-- page -->
<div class="node">
<a name="api"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#board">board</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#vector-matrix">vector matrix</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Functions</h2>

<ul class="menu">
<li><a accesskey="1" href="#api-astronomy">api astronomy</a>:                Astronomy functions. 
<li><a accesskey="2" href="#api-vector-matrix">api vector matrix</a>:            Vector and matrix functions. 
<li><a accesskey="3" href="#api-consts-fortran">api consts fortran</a>:           Fortran language constants. 
<li><a accesskey="4" href="#api-consts-c">api consts c</a>:                 C language constants. 
</ul>

<!-- page -->
<div class="node">
<a name="api-astronomy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-vector-matrix">api vector matrix</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">5.1 Astronomy functions</h3>

<ul class="menu">
<li><a accesskey="1" href="#api-Calendars">api Calendars</a>:                Calendars. 
<li><a accesskey="2" href="#api-Ephemerides">api Ephemerides</a>:              Ephemerides. 
<li><a accesskey="3" href="#api-FundamentalArgs">api FundamentalArgs</a>:          Fundamental args. 
<li><a accesskey="4" href="#api-PrecNutPolar">api PrecNutPolar</a>:             Prec nut polar. 
<li><a accesskey="5" href="#api-RotationAndTime">api RotationAndTime</a>:          Rotation and time. 
<li><a accesskey="6" href="#api-SpaceMotion">api SpaceMotion</a>:              Space motion. 
<li><a accesskey="7" href="#api-StarCatalogs">api StarCatalogs</a>:             Star catalogs. 
<li><a accesskey="8" href="#api-Geodetic_002fGeocentric">api Geodetic/Geocentric</a>:      Geodetic geocentric. 
<li><a accesskey="9" href="#api-Timescales">api Timescales</a>:               Timescales. 
</ul>

<!-- page -->
<div class="node">
<a name="api-Calendars"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-Ephemerides">api Ephemerides</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-astronomy">api astronomy</a>

</div>

<h4 class="subsection">5.1.1 Calendars</h4>

<div class="defun">
&mdash; Function: int <b>iauCal2jd</b> (<var>int iy, int im, int id, double * djm0, double * djm</var>)<var><a name="index-iauCal2jd-1"></a></var><br>
<blockquote><p>Gregorian Calendar to Julian Date.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          iy,im,id  int     year, month, day in Gregorian calendar (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          djm0      double  MJD zero-point: always 2400000.5
          djm       double  Modified Julian Date for 0 hrs
</pre>
        <p>Returned (function value):

     <pre class="example">          int     status:
                      0 = OK
                     -1 = bad year   (Note 3: JD not computed)
                     -2 = bad month  (JD not computed)
                     -3 = bad day    (JD computed)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The algorithm used is valid from -4800 March 1, but this implementation
rejects dates before -4799 January 1.

          <li>The Julian Date is returned in two pieces, in the usual SOFA manner,
which is designed to preserve time resolution.  The Julian Date is
available as a single number by adding <var>djm0</var> and <var>djm</var>.

          <li>In early eras the conversion is from the &ldquo;Proleptic Gregorian
Calendar&rdquo;; no account is taken of the date(s) of adoption of the
Gregorian Calendar, nor is the AD/BC numbering convention observed.
             </ol>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 12.92 (p604). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauEpb</b> (<var>double dj1, double dj2</var>)<var><a name="index-iauEpb-2"></a></var><br>
<blockquote><p>Julian Date to Besselian Epoch.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          dj1,dj2    double     Julian Date (see note)
</pre>
        <p>Returned (function value):

     <pre class="example">                     double     Besselian Epoch.
</pre>
        <p>Note:

          <ol type=1 start=1>
<li>The Julian Date is supplied in two pieces, in the usual <acronym>SOFA</acronym> manner,
which is designed to preserve time resolution.  The Julian Date is
available as a single number by adding <var>dj1</var> and <var>dj2</var>.  The
maximum resolution is achieved if <var>dj1</var> is 2451545D0 (J2000.0).
             </ol>

        <p>Reference:

          <ul>
<li>Lieske,J.H., 1979. Astron.Astrophys.,73,282. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauEpb2jd</b> (<var>double epb, double * djm0, double * djm</var>)<var><a name="index-iauEpb2jd-3"></a></var><br>
<blockquote><p>Besselian Epoch to Julian Date.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          epb      double    Besselian Epoch (e.g. 1957.3D0)
</pre>
        <p>Returned:

     <pre class="example">          djm0     double    MJD zero-point: always 2400000.5
          djm      double    Modified Julian Date
</pre>
        <p>Note:

          <ol type=1 start=1>
<li>The Julian Date is returned in two pieces, in the usual <acronym>SOFA</acronym> manner,
which is designed to preserve time resolution.  The Julian Date is
available as a single number by adding <var>djm0</var> and <var>djm</var>.
             </ol>

        <p>Reference:

          <ul>
<li>Lieske, J.H., 1979, Astron.Astrophys. 73, 282. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauEpj</b> (<var>double dj1, double dj2</var>)<var><a name="index-iauEpj-4"></a></var><br>
<blockquote><p>Julian Date to Julian Epoch.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          dj1,dj2    double     Julian Date (see note)
</pre>
        <p>Returned (function value):

     <pre class="example">                     double     Julian Epoch
</pre>
        <p>Note:

          <ol type=1 start=1>
<li>The Julian Date is supplied in two pieces, in the usual <acronym>SOFA</acronym> manner,
which is designed to preserve time resolution.  The Julian Date is
available as a single number by adding <var>dj1</var> and <var>dj2</var>.  The
maximum resolution is achieved if <var>dj1</var> is 2451545D0 (J2000.0).
             </ol>

        <p>Reference:

          <ul>
<li>Lieske, J.H., 1979, Astron.Astrophys. 73, 282. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauEpj2jd</b> (<var>double epj, double * djm0, double * djm</var>)<var><a name="index-iauEpj2jd-5"></a></var><br>
<blockquote><p>Julian Epoch to Julian Date.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          epj      double    Julian Epoch (e.g. 1996.8D0)
</pre>
        <p>Returned:

     <pre class="example">          djm0     double    MJD zero-point: always 2400000.5
          djm      double    Modified Julian Date
</pre>
        <p>Note:

          <ol type=1 start=1>
<li>The Julian Date is returned in two pieces, in the usual SOFA manner,
which is designed to preserve time resolution.  The Julian Date is
available as a single number by adding <var>djm0</var> and <var>djm</var>.
             </ol>

        <p>Reference:

          <ul>
<li>Lieske, J.H., 1979, Astron.Astrophys. 73, 282. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauJd2cal</b> (<var>double dj1, double dj2, int * iy, int * im, int * id, double * fd</var>)<var><a name="index-iauJd2cal-6"></a></var><br>
<blockquote><p>Julian Date to Gregorian year, month, day, and fraction of a day.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          dj1,dj2   double   Julian Date (Notes 1, 2)
</pre>
        <p>Returned (arguments):

     <pre class="example">          iy        int      year
          im        int      month
          id        int      day
          fd        double   fraction of day
</pre>
        <p>Returned (function value):

     <pre class="example">          int      status:
                      0 = OK
                     -1 = unacceptable date (Note 3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The earliest valid date is -68569.5 (-4900 March 1).  The largest value
accepted is 10^9.

          <li>The Julian Date is apportioned in any convenient way between the
arguments <var>dj1</var> and <var>dj2</var>.  For example, <code>JD = 2450123.7</code>
could be expressed in any of these ways, among others:

          <pre class="example">                  dj1             dj2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <li>In early eras the conversion is from the &ldquo;proleptic Gregorian
calendar&rdquo;; no account is taken of the date(s) of adoption of the
Gregorian calendar, nor is the AD/BC numbering convention observed.
             </ol>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 12.92 (p604). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauJdcalf</b> (<var>int ndp, double dj1, double dj2, int iymdf</var>[<var>4</var>])<var><a name="index-iauJdcalf-7"></a></var><br>
<blockquote><p>Julian Date to Gregorian Calendar, expressed in a form convenient for
formatting messages: rounded to a specified precision.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          ndp       int      number of decimal places of days in fraction
          dj1,dj2   double   dj1+dj2 = Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          iymdf     int[4]   year, month, day, fraction in Gregorian
                             calendar
</pre>
        <p>Returned (function value):

     <pre class="example">          int      status:
                     -1 = date out of range
                      0 = OK
                     +1 = NDP not 0-9 (interpreted as 0)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The Julian Date is apportioned in any convenient way between the
arguments <var>dj1</var> and <var>dj2</var>.  For example, <code>JD = 2450123.7</code>
could be expressed in any of these ways, among others:

          <pre class="example">                   dj1            dj2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <li>In early eras the conversion is from the &ldquo;Proleptic Gregorian
Calendar&rdquo;; no account is taken of the date(s) of adoption of the
Gregorian Calendar, nor is the AD/BC numbering convention observed.

          <li>Refer to the function iauJd2cal.

          <li>NDP should be 4 or less if internal overflows are to be avoided on
machines which use 16-bit integers.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauJd2cal</code><dd>JD to Gregorian calendar. 
</dl>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 12.92 (p604). 
</ul>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-Ephemerides"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-FundamentalArgs">api FundamentalArgs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-Calendars">api Calendars</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-astronomy">api astronomy</a>

</div>

<h4 class="subsection">5.1.2 Ephemerides</h4>

<div class="defun">
&mdash; Function: int <b>iauEpv00</b> (<var>double date1, double date2, double pvh</var>[<var>2</var>][<var>3</var>]<var>, double pvb</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauEpv00-8"></a></var><br>
<blockquote><p>Earth position and velocity, heliocentric and barycentric, with respect
to the Barycentric Celestial Reference System.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double        TDB date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          pvh          double[2][3]  heliocentric Earth position/velocity
          pvb          double[2][3]  barycentric Earth position/velocity
</pre>
        <p>Returned (function value):

     <pre class="example">          int           status: 0 = OK
                               +1 = warning: date outside
                                    the range 1900-2100 AD
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TDB date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TDB) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.  However, the accuracy of the result is more likely to be
limited by the algorithm itself than the way the date has been
expressed.

          <blockquote>
n.b. TT can be used instead of TDB in most applications. 
</blockquote>

          <li>On return, the arrays <var>pvh</var> and <var>pvb</var> contain the following:

          <pre class="example">               pvh[0][0]  x       }
               pvh[0][1]  y       } heliocentric position, AU
               pvh[0][2]  z       }
               
               pvh[1][0]  xdot    }
               pvh[1][1]  ydot    } heliocentric velocity, AU/d
               pvh[1][2]  zdot    }
               
               pvb[0][0]  x       }
               pvb[0][1]  y       } barycentric position, AU
               pvb[0][2]  z       }
               
               pvb[1][0]  xdot    }
               pvb[1][1]  ydot    } barycentric velocity, AU/d
               pvb[1][2]  zdot    }
</pre>
          <p>The vectors are with respect to the Barycentric Celestial Reference
System.  The time unit is one day in TDB.

          <li>The function is a <strong>simplified solution</strong> from the planetary theory
VSOP2000 (X. Moisson, P. Bretagnon, 2001, Celes. Mechanics &amp;
Dyn. Astron., 80, 3/4, 205-213) and is an adaptation of original Fortran
code supplied by P. Bretagnon (private comm., 2000).

          <li>Comparisons over the time span 1900-2100 with this simplified solution
and the JPL DE405 ephemeris give the following results:

          <pre class="example">                                    RMS    max
               Heliocentric:
                  position error    3.7   11.2   km
                  velocity error    1.4    5.0   mm/s
               
               Barycentric:
                  position error    4.6   13.4   km
                  velocity error    1.4    4.9   mm/s
</pre>
          <p>Comparisons with the JPL DE406 ephemeris show that by 1800 and 2200 the
position errors are approximately double their 1900-2100 size.  By 1500
and 2500 the deterioration is a factor of 10 and by 1000 and 3000 a
factor of 60.  The velocity accuracy falls off at about half that rate.

          <li>It is permissible to use the same array for pvh and pvb, which will
receive the barycentric values.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauPlan94</b> (<var>double date1, double date2, int np, double pv</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauPlan94-9"></a></var><br>
<blockquote><p>Approximate heliocentric position and velocity of a nominated major
planet: Mercury, Venus, EMB, Mars, Jupiter, Saturn, Uranus or Neptune
(but not the Earth itself).

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1  double       TDB date part A (Note 1)
          date2  double       TDB date part B (Note 1)
          np     int          planet (1=Mercury, 2=Venus, 3=EMB, 4=Mars,
                              5=Jupiter, 6=Saturn, 7=Uranus, 8=Neptune)
</pre>
        <p>Returned (argument):

     <pre class="example">          pv     double[2][3] planet p,v (heliocentric, J2000.0, AU,AU/d)
</pre>
        <p>Returned (function value):

     <pre class="example">          int          status: -1 = illegal NP (outside 1-8)
                                0 = OK
                               +1 = warning: year outside 1000-3000
                               +2 = warning: failed to converge
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The date <var>date1</var><code> + </code><var>date2</var> is in the TDB time scale (in
practice TT can be used) and is a Julian Date, apportioned in any
convenient way between the two arguments.  For example, <code>JD(TDB) =
2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.  The limited accuracy of the present algorithm is such that
any of the methods is satisfactory.

          <li>If an <var>np</var> value outside the range 1-8 is supplied, an error status
(function value -1) is returned and the pv vector set to zeroes.

          <li>For <var>np</var><code> = 3</code> the result is for the Earth&ndash;Moon Barycenter. 
To obtain the heliocentric position and velocity of the Earth, use
instead the <acronym>SOFA</acronym> function <code>iauEpv00</code>.

          <li>On successful return, the array <var>pv</var> contains the following:

          <pre class="example">               pv[0][0]   x      }
               pv[0][1]   y      } heliocentric position, AU
               pv[0][2]   z      }
               
               pv[1][0]   xdot   }
               pv[1][1]   ydot   } heliocentric velocity, AU/d
               pv[1][2]   zdot   }
</pre>
          <p>The reference frame is equatorial and is with respect to the mean
equator and equinox of epoch J2000.0.

          <li>The algorithm is due to J.L. Simon, P. Bretagnon, J. Chapront,
M. Chapront-Touze, G. Francou and J. Laskar (Bureau des Longitudes,
Paris, France).  From comparisons with JPL ephemeris DE102, they quote
the following maximum errors over the interval 1800-2050:

          <pre class="example">                            L (arcsec)    B (arcsec)      R (km)
               
               Mercury          4             1             300
               Venus            5             1             800
               EMB              6             1            1000
               Mars            17             1            7700
               Jupiter         71             5           76000
               Saturn          81            13          267000
               Uranus          86             7          712000
               Neptune         11             1          253000
</pre>
          <p>Over the interval 1000-3000, they report that the accuracy is no worse
than 1.5 times that over 1800-2050.  Outside 1000-3000 the accuracy
declines.

          <p>Comparisons of the present function with the JPL DE200 ephemeris give
the following RMS errors over the interval 1960-2025:

          <pre class="example">                             position (km)     velocity (m/s)
               
               Mercury            334               0.437
               Venus             1060               0.855
               EMB               2010               0.815
               Mars              7690               1.98
               Jupiter          71700               7.70
               Saturn          199000              19.4
               Uranus          564000              16.4
               Neptune         158000              14.4
</pre>
          <p>Comparisons against DE200 over the interval 1800-2100 gave the following
maximum absolute differences.  (The results using DE406 were essentially
the same.)

          <pre class="example">                          L (arcsec)   B (arcsec)     R (km)   Rdot (m/s)
               
               Mercury        7            1            500       0.7
               Venus          7            1           1100       0.9
               EMB            9            1           1300       1.0
               Mars          26            1           9000       2.5
               Jupiter       78            6          82000       8.2
               Saturn        87           14         263000      24.6
               Uranus        86            7         661000      27.4
               Neptune       11            2         248000      21.4
</pre>
          <li>The present <acronym>SOFA</acronym> re-implementation of the original Simon et al. 
Fortran code differs from the original in the following respects:

               <ul>
<li>C instead of Fortran.

               <li>The date is supplied in two parts.

               <li>The result is returned only in equatorial Cartesian form; the ecliptic
longitude, latitude and radius vector are not returned.

               <li>The result is in the J2000.0 equatorial frame, not ecliptic.

               <li>More is done in&ndash;line: there are fewer calls to subroutines.

               <li>Different error/warning status values are used.

               <li>A different Kepler's&ndash;equation&ndash;solver is used (avoiding use of double
precision complex).

               <li>Polynomials in t are nested to minimize rounding errors.

               <li>Explicit double constants are used to avoid mixed&ndash;mode expressions. 
</ul>

          <p>None of the above changes affects the result significantly.

          <li>The returned status indicates the most serious condition encountered
during execution of the function.  Illegal np is considered the most
serious, overriding failure to converge, which in turn takes precedence
over the remote date warning.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi. 
</dl>

        <p>Reference:

          <ul>
Simon, J.L, Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., and Laskar, J., Astron. Astrophys. 282, 663 (1994). 
</ul>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-FundamentalArgs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-PrecNutPolar">api PrecNutPolar</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-Ephemerides">api Ephemerides</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-astronomy">api astronomy</a>

</div>

<h4 class="subsection">5.1.3 Fundamental args</h4>

<div class="defun">
&mdash; Function: double <b>iauFad03</b> (<var>double t</var>)<var><a name="index-iauFad03-10"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean elongation of the
Moon from the Sun.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    D, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003) and is from
Simon et al. (1994).
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFae03</b> (<var>double t</var>)<var><a name="index-iauFae03-11"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean longitude of Earth.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    mean longitude of Earth, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

          <li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFaf03</b> (<var>double t</var>)<var><a name="index-iauFaf03-12"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean longitude of the
Moon minus mean longitude of the ascending node.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    F, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003) and is from
Simon et al. (1994).
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFaju03</b> (<var>double t</var>)<var><a name="index-iauFaju03-13"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean longitude of
Jupiter.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    mean longitude of Jupiter, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.

          <li>The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

          <li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFal03</b> (<var>double t</var>)<var><a name="index-iauFal03-14"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean anomaly of the Moon.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    l, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.

          <li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFalp03</b> (<var>double t</var>)<var><a name="index-iauFalp03-15"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean anomaly of the Sun.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    l', radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003) and is from
Simon et al. (1994).
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFama03</b> (<var>double t</var>)<var><a name="index-iauFama03-16"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean longitude of Mars.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    mean longitude of Mars, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
             </ol>

        <p>References:

          <ol type=1 start=1>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

          <li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFame03</b> (<var>double t</var>)<var><a name="index-iauFame03-17"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean longitude of
Mercury.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    mean longitude of Mercury, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

          <li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFane03</b> (<var>double t</var>)<var><a name="index-iauFane03-18"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003):
mean longitude of Neptune.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    mean longitude of Neptune, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003) and is
adapted from Simon et al. (1994).
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFaom03</b> (<var>double t</var>)<var><a name="index-iauFaom03-19"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean longitude of the
Moon's ascending node.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    Omega, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003) and is from
Simon et al. (1994).
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFapa03</b> (<var>double t</var>)<var><a name="index-iauFapa03-20"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): general accumulated
precession in longitude.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    general precession in longitude, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003).  It is
taken from Kinoshita &amp; Souchay (1990) and comes originally from Lieske
et al. (1977).
             </ol>

        <p>References:

          <ul>
<li>Kinoshita, H. and Souchay J. 1990, Celest.Mech. and Dyn.Astron.  48, 187.

          <li>Lieske, J.H., Lederle, T., Fricke, W. &amp; Morando, B. 1977,
Astron.Astrophys. 58, 1-16.

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFasa03</b> (<var>double t</var>)<var><a name="index-iauFasa03-21"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean longitude of Saturn.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    mean longitude of Saturn, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

          <li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFaur03</b> (<var>double t</var>)<var><a name="index-iauFaur03-22"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean longitude of Uranus.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned  (function value):

     <pre class="example">                double    mean longitude of Uranus, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003) and is
adapted from Simon et al. (1994).
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauFave03</b> (<var>double t</var>)<var><a name="index-iauFave03-23"></a></var><br>
<blockquote><p>Fundamental argument, IERS Conventions (2003): mean longitude of Venus.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          t     double    TDB, Julian centuries since J2000.0 (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                double    mean longitude of Venus, radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Though <var>t</var> is strictly TDB, it is usually more convenient to use TT,
which makes no significant difference.

          <li>The expression used is as adopted in IERS Conventions (2003) and comes
from Souchay et al. (1999) after Simon et al. (1994).
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

          <li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111. 
</ul>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-PrecNutPolar"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-RotationAndTime">api RotationAndTime</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-FundamentalArgs">api FundamentalArgs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-astronomy">api astronomy</a>

</div>

<h4 class="subsection">5.1.4 Prec nut polar</h4>

<div class="defun">
&mdash; Function: void <b>iauBi00</b> (<var>double * dpsibi, double * depsbi, double * dra</var>)<var><a name="index-iauBi00-24"></a></var><br>
<blockquote><p>Frame bias components of IAU 2000 precession&ndash;nutation models (part of
MHB2000 with additions).

        <p>Status: canonical model.

        <p>Returned:

     <pre class="example">          dpsibi,depsbi  double  longitude and obliquity corrections
          dra            double  the ICRS RA of the J2000.0 mean equinox
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The frame bias corrections in longitude and obliquity (radians) are
required in order to correct for the offset between the GCRS pole and
the mean J2000.0 pole.  They define, with respect to the GCRS frame, a
J2000.0 mean pole that is consistent with the rest of the IAU 2000A
precession&ndash;nutation model.

          <li>In addition to the displacement of the pole, the complete description of
the frame bias requires also an offset in right ascension.  This is not
part of the IAU 2000A model, and is from Chapront et al. (2002).  It is
returned in radians.

          <li>This is a supplemented implementation of one aspect of the IAU 2000A
nutation model, formally adopted by the IAU General Assembly in 2000,
namely MHB2000 (Mathews et al. 2002).
             </ol>

        <p>References:

          <ul>
<li>Chapront, J., Chapront-Touze, M. &amp; Francou, G., Astron. 
Astrophys., 387, 700, 2002.

          <li>Mathews, P.M., Herring, T.A., Buffet, B.A., &ldquo;Modeling of nutation and
precession New nutation series for nonrigid Earth and insights into the
Earth's interior&rdquo;, J.Geophys.Res., 107, B4, 2002.  The MHB2000 code
itself was obtained on 9th September 2002 from:

          <div align="center"><a href="ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A">ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A</a></div>
        </ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauBp00</b> (<var>double date1, double date2, double rb</var>[<var>3</var>][<var>3</var>]<var>, double rp</var>[<var>3</var>][<var>3</var>]<var>, double rbp</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauBp00-25"></a></var><br>
<blockquote><p>Frame bias and precession, IAU 2000.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2  double         TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:
     <pre class="example">          rb           double[3][3]   frame bias matrix (Note 2)
          rp           double[3][3]   precession matrix (Note 3)
          rbp          double[3][3]   bias-precession matrix (Note 4)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                   date1         date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix <var>rb</var> transforms vectors from GCRS to mean J2000.0 by
applying frame bias.

          <li>The matrix <var>rp</var> transforms vectors from J2000.0 mean equator and
equinox to mean equator and equinox of date by applying precession.

          <li>The matrix <var>rbp</var> transforms vectors from GCRS to mean equator and
equinox of date by applying frame bias then precession.  It is the
product <var>rp</var><code> * </code><var>rb</var>.

          <li>It is permissible to reuse the same array in the returned arguments. 
The arrays are filled in the order given.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauBi00</code><dd>Frame bias components, IAU 2000.

          <br><dt><code>iauPr00</code><dd>IAU 2000 precession adjustments.

          <br><dt><code>iauIr</code><dd>Initialize <code>r</code>-matrix to identity.

          <br><dt><code>iauRx</code><dd>Rotate around x-axis.

          <br><dt><code>iauRy</code><dd>Rotate around y-axis.

          <br><dt><code>iauRz</code><dd>Rotate around z-axis.

          <br><dt><code>iauCr</code><dd>Copy <code>r</code>-matrix.

          <br><dt><code>iauRxr</code><dd>Product of two <code>r</code>-matrices. 
</dl>

        <p>Reference:

          <ul>
<li>&ldquo;Expressions for the Celestial Intermediate Pole and Celestial
Ephemeris Origin consistent with the IAU 2000A precession&ndash;nutation
model&rdquo;, Astron.Astrophys. 400, 1145-1154 (2003).

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed &ldquo;celestial
intermediate origin&rdquo; (CIO) by IAU 2006 Resolution 2. 
</blockquote>
          </ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauBp06</b> (<var>double date1, double date2, double rb</var>[<var>3</var>][<var>3</var>]<var>, double rp</var>[<var>3</var>][<var>3</var>]<var>, double rbp</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauBp06-26"></a></var><br>
<blockquote><p>Frame bias and precession, IAU 2006.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double         TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rb           double[3][3]   frame bias matrix (Note 2)
          rp           double[3][3]   precession matrix (Note 3)
          rbp          double[3][3]   bias-precession matrix (Note 4)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                   date1         date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix <var>rb</var> transforms vectors from GCRS to mean J2000.0 by
applying frame bias.

          <li>The matrix <var>rp</var> transforms vectors from mean J2000.0 to mean of date
by applying precession.

          <li>The matrix <var>rbp</var> transforms vectors from GCRS to mean of date by
applying frame bias then precession.  It is the product <var>rp</var><code> *
</code><var>rb</var>.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPfw06</code><dd>Bias&ndash;precession F-W angles, IAU 2006.

          <br><dt><code>iauFw2m</code><dd>F-W angles to <code>r</code>-matrix.

          <br><dt><code>iauPmat06</code><dd>PB matrix, IAU 2006.

          <br><dt><code>iauTr</code><dd>Transpose <code>r</code>-matrix.

          <br><dt><code>iauRxr</code><dd>Product of two <code>r</code>-matrices. 
</dl>

        <p>References:

          <ul>
Capitaine, N. &amp; Wallace, P.T., 2006, Astron.Astrophys. 450, 855.

          <li>Wallace, P.T. &amp; Capitaine, N., 2006, Astron.Astrophys. 459, 981. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauBpn2xy</b> (<var>double rbpn</var>[<var>3</var>][<var>3</var>]<var>, double * x, double * y</var>)<var><a name="index-iauBpn2xy-27"></a></var><br>
<blockquote><p>Extract from the bias&ndash;precession&ndash;nutation matrix the x,
y coordinates of the Celestial Intermediate Pole.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          rbpn      double[3][3]  celestial-to-true matrix (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          x,y       double        Celestial Intermediate Pole (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The matrix rbpn transforms vectors from GCRS to true equator (and CIO or
equinox) of date, and therefore the Celestial Intermediate Pole unit
vector is the bottom row of the matrix.

          <li>The arguments <var>x</var>, <var>y</var> are components of the Celestial
Intermediate Pole unit vector in the Geocentric Celestial Reference
System.
             </ol>

        <p>Reference:

          <ul>
<li>&ldquo;Expressions for the Celestial Intermediate Pole and Celestial
Ephemeris Origin consistent with the IAU 2000A precession&ndash;nutation
model&rdquo;, Astron.Astrophys. 400, 1145-1154 (2003)

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed "celestial
intermediate origin" (CIO) by IAU 2006 Resolution 2. 
</blockquote>
          </ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2i00a</b> (<var>double date1, double date2, double rc2i</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2i00a-28"></a></var><br>
<blockquote><p>Form the celestial&ndash;to&ndash;intermediate matrix for a given date using the
IAU 2000A precession-nutation model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2 double       TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rc2i        double[3][3] celestial-to-intermediate matrix (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix <var>rc2i</var> is the first stage in the transformation from
celestial to terrestrial coordinates:

          <pre class="example">               [TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
                     = rc2t * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), ERA is the Earth Rotation
Angle and RPOM is the polar motion matrix.

          <li>A faster, but slightly less accurate result (about 1 mas), can be
obtained by using instead the <code>iauC2i00b</code> function.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPnm00a</code><dd>Classical NPB matrix, IAU 2000A.

          <br><dt><code>iauC2ibpn</code><dd>Celestial&ndash;to&ndash;intermediate matrix, given NPB matrix. 
</dl>

        <p>References:

          <ul>
<li>&ldquo;Expressions for the Celestial Intermediate Pole and Celestial
Ephemeris Origin consistent with the IAU 2000A precession&ndash;nutation
model&rdquo;, Astron.Astrophys. 400, 1145-1154 (2003)

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed &ldquo;celestial
intermediate originW&rdquo; (CIO) by IAU 2006 Resolution 2. 
</blockquote>

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2i00b</b> (<var>double date1, double date2, double rc2i</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2i00b-29"></a></var><br>
<blockquote><p>Form the celestial&ndash;to&ndash;intermediate matrix for a given date using the
IAU 2000B precession-nutation model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2 double       TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rc2i        double[3][3] celestial-to-intermediate matrix (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date date1+date2 is a Julian Date, apportioned in any convenient
way between the two arguments.  For example, <code>JD(TT) = 2450123.7</code>
could be expressed in any of these ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix <var>rc2i</var> is the first stage in the transformation from
celestial to terrestrial coordinates:

          <pre class="example">               [TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
                     = rc2t * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), ERA is the Earth Rotation
Angle and RPOM is the polar motion matrix.

          <li>The present function is faster, but slightly less accurate (about
1 mas), than the <code>iauC2i00a</code> function.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPnm00b</code><dd>Classical NPB matrix, IAU 2000B.

          <br><dt><code>iauC2ibpn</code><dd>Celestial&ndash;to&ndash;intermediate matrix, given NPB matrix. 
</dl>

        <p>References:

          <ul>
<li>&ldquo;Expressions for the Celestial Intermediate Pole and Celestial
Ephemeris Origin consistent with the IAU 2000A precession-nutation
model&rdquo;, Astron.Astrophys. 400, 1145-1154 (2003)

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed &ldquo;celestial
intermediate origin&rdquo; (CIO) by IAU 2006 Resolution 2. 
</blockquote>

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2i06a</b> (<var>double date1, double date2, double rc2i</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2i06a-30"></a></var><br>
<blockquote><p>Form the celestial&ndash;to&ndash;intermediate matrix for a given date using the
IAU 2006 precession and IAU 2000A nutation models.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2 double       TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rc2i        double[3][3] celestial-to-intermediate matrix (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix <var>rc2i</var> is the first stage in the transformation from
celestial to terrestrial coordinates:

          <pre class="example">               [TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
                     = RC2T * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), ERA is the Earth Rotation
Angle and RPOM is the polar motion matrix.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPnm06a</code><dd>Classical NPB matrix, IAU 2006/2000A.

          <br><dt><code>iauBpn2xy</code><dd>Extract CIP X,Y coordinates from NPB matrix.

          <br><dt><code>iauS06</code><dd>The CIO locator s, Given X,Y, IAU 2006.

          <br><dt><code>iauC2ixys</code><dd>Celestial&ndash;to&ndash;intermediate matrix, Given X,Y and s. 
</dl>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2ibpn</b> (<var>double date1, double date2, double rbpn</var>[<var>3</var>][<var>3</var>]<var>, double rc2i</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2ibpn-31"></a></var><br>
<blockquote><p>Form the celestial&ndash;to&ndash;intermediate matrix for a given date given the
bias&ndash;precession&ndash;nutation matrix.  IAU 2000.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2 double       TT as a 2-part Julian Date (Note 1)
          rbpn        double[3][3] celestial-to-true matrix (Note 2)
</pre>
        <p>Returned:

     <pre class="example">          rc2i        double[3][3] celestial-to-intermediate matrix (Note 3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix <var>rbpn</var> transforms vectors from <acronym>GCRS</acronym> to true
equator (and CIO or equinox) of date.  Only the CIP (bottom row) is
used.

          <li>The matrix <var>rc2i</var> is the first stage in the transformation from
celestial to terrestrial coordinates:

          <pre class="example">               [TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
                     = RC2T * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), <code>ERA</code> is the Earth
Rotation Angle and <code>RPOM</code> is the polar motion matrix.

          <li>Although its name does not include "00", This function is in fact
specific to the IAU 2000 models.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauBpn2xy</code><dd>Extract CIP X,Y coordinates from NPB matrix.

          <br><dt><code>iauC2ixy</code><dd>Celestial&ndash;to&ndash;intermediate matrix, given X,Y. 
</dl>

        <p>References:

          <ul>
<li>&ldquo;Expressions for the Celestial Intermediate Pole and Celestial
Ephemeris Origin consistent with the IAU 2000A precession-nutation
model&rdquo;, Astron.Astrophys. 400, 1145-1154 (2003).

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed &ldquo;celestial
intermediate origin&rdquo; (CIO) by IAU 2006 Resolution 2. 
</blockquote>

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2ixy</b> (<var>double date1, double date2, double x, double y, double rc2i</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2ixy-32"></a></var><br>
<blockquote><p>Form the celestial to intermediate&ndash;frame&ndash;of&ndash;date matrix for a given
date when the CIP X,Y coordinates are known.  IAU 2000.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2 double       TT as a 2-part Julian Date (Note 1)
          x,y         double       Celestial Intermediate Pole (Note 2)
</pre>
        <p>Returned:

     <pre class="example">          rc2i        double[3][3] celestial-to-intermediate matrix (Note 3)
</pre>
        <p>Notes:

          <ul>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The Celestial Intermediate Pole coordinates are the <var>x</var>, <var>y</var>
components of the unit vector in the Geocentric Celestial Reference
System.

          <li>The matrix <var>rc2i</var> is the first stage in the transformation from
celestial to terrestrial coordinates:

          <pre class="example">               [TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
                     = RC2T * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), <code>ERA</code> is the Earth
Rotation Angle and <code>RPOM</code> is the polar motion matrix.

          <li>Although its name does not include <code>00</code>, this function is in fact
specific to the IAU 2000 models. 
</ul>

        <p>Called:

          <dl>
<dt><code>iauC2ixys</code><dd>Celestial&ndash;to&ndash;intermediate matrix, given X,Y and s.

          <br><dt><code>iauS00</code><dd>The CIO locator s, given X,Y, IAU 2000A. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2ixys</b> (<var>double x, double y, double s, double rc2i</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2ixys-33"></a></var><br>
<blockquote><p>Form the celestial to intermediate&ndash;frame&ndash;of&ndash;date matrix given the CIP
<var>x</var>, <var>y</var> and the CIO locator <var>s</var>.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          x,y      double         Celestial Intermediate Pole (Note 1)
          s        double         the CIO locator s (Note 2)
</pre>
        <p>Returned:

     <pre class="example">          rc2i     double[3][3]   celestial-to-intermediate matrix (Note 3)
</pre>
        <p>Notes:

          <ul>
<li>The Celestial Intermediate Pole coordinates are the <var>x</var>, <var>y</var>
components of the unit vector in the Geocentric Celestial Reference
System.

          <li>The CIO locator <var>s</var> (in radians) positions the Celestial
Intermediate Origin on the equator of the CIP.

          <li>The matrix <var>rc2i</var> is the first stage in the transformation from
celestial to terrestrial coordinates:

          <pre class="example">               [TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
                     = RC2T * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), <code>ERA</code> is the Earth
Rotation Angle and <code>RPOM</code> is the polar motion matrix. 
</ul>

        <p>Called:

          <dl>
<dt><code>iauIr</code><dd>Initialize <code>r</code>-matrix to identity.

          <br><dt><code>iauRz</code><dd>Rotate around Z-axis.

          <br><dt><code>iauRy</code><dd>Rotate around Y-axis. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2t00a</b> (<var>double tta, double ttb, double uta, double utb, double xp, double yp, double rc2t</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2t00a-34"></a></var><br>
<blockquote><p>Form the celestial to terrestrial matrix given the date, the UT1 and the
polar motion, using the IAU 2000A nutation model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          tta,ttb  double         TT as a 2-part Julian Date (Note 1)
          uta,utb  double         UT1 as a 2-part Julian Date (Note 1)
          xp,yp    double         coordinates of the pole (radians, Note 2)
</pre>
        <p>Returned:

     <pre class="example">          rc2t     double[3][3]   celestial-to-terrestrial matrix (Note 3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT and UT1 dates <var>tta</var><code> + </code><var>ttb</var> and <var>uta</var><code> +
</code><var>utb</var> are Julian Dates, apportioned in any convenient way between
the arguments <var>uta</var> and <var>utb</var>.  For example, <code>JD(UT1) =
2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                   uta            utb
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  In the case of <var>uta</var>, <var>utb</var>, the date &amp; time
method is best matched to the Earth rotation angle algorithm used:
maximum precision is delivered when the uta argument is for 0hrs UT1 on
the day in question and the <var>utb</var> argument lies in the range
0 to 1, or vice versa.

          <li>The arguments <var>xp</var> and <var>yp</var> are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to 0 and 90 deg west respectively.

          <li>The matrix <var>rc2t</var> transforms from celestial to terrestrial
coordinates:

          <pre class="example">               [TRS] = RPOM * R_3(ERA) * RC2I * [CRS]
                     = rc2t * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), <code>RC2I</code> is the
celestial&ndash;to&ndash;intermediate matrix, <code>ERA</code> is the Earth rotation
angle and <code>RPOM</code> is the polar motion matrix.

          <li>A faster, but slightly less accurate result (about 1 mas), can be
obtained by using instead the <code>iauC2t00b</code> function.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauC2i00a</code><dd>Celestial&ndash;to&ndash;intermediate matrix, IAU 2000A.

          <br><dt><code>iauEra00</code><dd>Earth rotation angle, IAU 2000.

          <br><dt><code>iauSp00</code><dd>The TIO locator s', IERS 2000.

          <br><dt><code>iauPom00</code><dd>Polar motion matrix.

          <br><dt><code>iauC2tcio</code><dd>Form CIO-based celestial&ndash;to&ndash;terrestrial matrix. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2t00b</b> (<var>double tta, double ttb, double uta, double utb, double xp, double yp, double rc2t</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2t00b-35"></a></var><br>
<blockquote><p>Form the celestial to terrestrial matrix given the date, the UT1 and the
polar motion, using the IAU 2000B nutation model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          tta,ttb  double         TT as a 2-part Julian Date (Note 1)
          uta,utb  double         UT1 as a 2-part Julian Date (Note 1)
          xp,yp    double         coordinates of the pole (radians, Note 2)
</pre>
        <p>Returned:

     <pre class="example">          rc2t     double[3][3]   celestial-to-terrestrial matrix (Note 3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT and UT1 dates <var>tta</var><code> + </code><var>ttb</var> and <var>uta</var><code> +
</code><var>utb</var> are Julian Dates, apportioned in any convenient way between
the arguments <var>uta</var> and <var>utb</var>.  For example, <code>JD(UT1) =
2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                   uta            utb
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  In the case of <var>uta</var>, <var>utb</var>, the date &amp; time
method is best matched to the Earth rotation angle algorithm used:
maximum precision is delivered when the uta argument is for 0hrs UT1 on
the day in question and the <var>utb</var> argument lies in the range
0 to 1, or vice versa.

          <li>The arguments <var>xp</var> and <var>yp</var> are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to 0 and 90 deg west respectively.

          <li>The matrix <var>rc2t</var> transforms from celestial to terrestrial
coordinates:

          <pre class="example">               [TRS] = RPOM * R_3(ERA) * RC2I * [CRS]
                     = rc2t * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), <code>RC2I</code> is the
celestial&ndash;to&ndash;intermediate matrix, <code>ERA</code> is the Earth rotation
angle and <code>RPOM</code> is the polar motion matrix.

          <li>The present function is faster, but slightly less accurate (about
1 mas), than the <code>iauC2t00a</code> function.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauC2i00b</code><dd>Celestial&ndash;to&ndash;intermediate matrix, IAU 2000B.

          <br><dt><code>iauEra00</code><dd>Earth rotation angle, IAU 2000.

          <br><dt><code>iauPom00</code><dd>Polar motion matrix.

          <br><dt><code>iauC2tcio</code><dd>Form CIO-based celestial&ndash;to&ndash;terrestrial matrix. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2t06a</b> (<var>double tta, double ttb, double uta, double utb, double xp, double yp, double rc2t</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2t06a-36"></a></var><br>
<blockquote><p>Form the celestial to terrestrial matrix given the date, the UT1 and the
polar motion, using the IAU 2006 precession and IAU 2000A nutation
models.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          tta,ttb  double         TT as a 2-part Julian Date (Note 1)
          uta,utb  double         UT1 as a 2-part Julian Date (Note 1)
          xp,yp    double         coordinates of the pole (radians, Note 2)
</pre>
        <p>Returned:

     <pre class="example">          rc2t     double[3][3]   celestial-to-terrestrial matrix (Note 3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT and UT1 dates <var>tta</var><code> + </code><var>ttb</var> and <var>uta</var><code> +
</code><var>utb</var> are Julian Dates, apportioned in any convenient way between
the arguments <var>uta</var> and <var>utb</var>.  For example, <code>JD(UT1) =
2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                   uta            utb
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  In the case of <var>uta</var>, <var>utb</var>, the date &amp; time
method is best matched to the Earth rotation angle algorithm used:
maximum precision is delivered when the uta argument is for 0hrs UT1 on
the day in question and the <var>utb</var> argument lies in the range
0 to 1, or vice versa.

          <li>The arguments <var>xp</var> and <var>yp</var> are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to 0 and 90 deg west respectively.

          <li>The matrix <var>rc2t</var> transforms from celestial to terrestrial
coordinates:

          <pre class="example">               [TRS] = RPOM * R_3(ERA) * RC2I * [CRS]
                     = rc2t * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), <code>RC2I</code> is the
celestial&ndash;to&ndash;intermediate matrix, <code>ERA</code> is the Earth rotation
angle and <code>RPOM</code> is the polar motion matrix.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauC2i06a</code><dd>Celestial&ndash;to&ndash;intermediate matrix, IAU 2006/2000A.

          <br><dt><code>iauEra00</code><dd>Earth rotation angle, IAU 2000.

          <br><dt><code>iauSp00</code><dd>The TIO locator s', IERS 2000.

          <br><dt><code>iauPom00</code><dd>Polar motion matrix.

          <br><dt><code>iauC2tcio</code><dd>Form CIO-based celestial&ndash;to&ndash;terrestrial matrix. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2tcio</b> (<var>double rc2i</var>[<var>3</var>][<var>3</var>]<var>, double era, double rpom</var>[<var>3</var>][<var>3</var>]<var>, double rc2t</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2tcio-37"></a></var><br>
<blockquote><p>Assemble the celestial to terrestrial matrix from CIO-based components
(the celestial&ndash;to&ndash;intermediate matrix, the Earth Rotation Angle and
the polar motion matrix).

        <p>Status: support function.

        <p>Given:

     <pre class="example">          rc2i     double[3][3]    celestial-to-intermediate matrix
          era      double          Earth rotation angle
          rpom     double[3][3]    polar-motion matrix
</pre>
        <p>Returned:

     <pre class="example">          rc2t     double[3][3]    celestial-to-terrestrial matrix
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>This function constructs the rotation matrix that transforms vectors in
the celestial system into vectors in the terrestrial system.  It does so
starting from precomputed components, namely the matrix which rotates
from celestial coordinates to the intermediate frame, the Earth rotation
angle and the polar motion matrix.  One use of the present function is
when generating a series of celestial&ndash;to&ndash;terrestrial matrices where
only the Earth Rotation Angle changes, avoiding the considerable
overhead of recomputing the precession&ndash;nutation more often than
necessary to achieve given accuracy objectives.

          <li>The relationship between the arguments is as follows:

          <pre class="example">               [TRS] = RPOM * R_3(ERA) * rc2i * [CRS]
                     = rc2t * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003).
             </ol>

        <p>Called:

          <dl>
<dt><code>iauCr</code><dd>Copy <code>r</code>-matrix.

          <br><dt><code>iauRz</code><dd>Rotate around Z-axis.

          <br><dt><code>iauRxr</code><dd>Product of two <code>r</code>-matrices. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2teqx</b> (<var>double rbpn</var>[<var>3</var>][<var>3</var>]<var>, double gst, double rpom</var>[<var>3</var>][<var>3</var>]<var>, double rc2t</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2teqx-38"></a></var><br>
<blockquote><p>Assemble the celestial to terrestrial matrix from equinox-based
components (the celestial&ndash;to&ndash;true matrix, the Greenwich Apparent
Sidereal Time and the polar motion matrix).

        <p>Status: support function.

        <p>Given:

     <pre class="example">          rbpn     double[3][3]    celestial-to-true matrix
          gst      double          Greenwich (apparent) Sidereal Time
          rpom     double[3][3]    polar-motion matrix
</pre>
        <p>Returned:

     <pre class="example">          rc2t     double[3][3]    celestial-to-terrestrial matrix (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>This function constructs the rotation matrix that transforms vectors in
the celestial system into vectors in the terrestrial system.  It does so
starting from precomputed components, namely the matrix which rotates
from celestial coordinates to the true equator and equinox of date, the
Greenwich Apparent Sidereal Time and the polar motion matrix.  One use
of the present function is when generating a series of
celestial&ndash;to&ndash;terrestrial matrices where only the Sidereal Time
changes, avoiding the considerable overhead of recomputing the
precession-nutation more often than necessary to achieve given accuracy
objectives.

          <li>The relationship between the arguments is as follows:

          <pre class="example">               [TRS] = rpom * R_3(gst) * rbpn * [CRS]
                     = rc2t * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003).
             </ol>

        <p>Called:

          <dl>
<dt><code>iauCr</code><dd>Copy <code>r</code>-matrix.

          <br><dt><code>iauRz</code><dd>Rotate around Z-axis.

          <br><dt><code>iauRxr</code><dd>Product of two <code>r</code>-matrices. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004)
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2tpe</b> (<var>double tta, double ttb, double uta, double utb, double dpsi, double deps, double xp, double yp, double rc2t</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2tpe-39"></a></var><br>
<blockquote><p>Form the celestial to terrestrial matrix given the date, the UT1, the
nutation and the polar motion.  IAU 2000.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          tta,ttb    double        TT as a 2-part Julian Date (Note 1)
          uta,utb    double        UT1 as a 2-part Julian Date (Note 1)
          dpsi,deps  double        nutation (Note 2)
          xp,yp      double        coordinates of the pole (radians, Note 3)
</pre>
        <p>Returned:

     <pre class="example">          rc2t       double[3][3]  celestial-to-terrestrial matrix (Note 4)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT and UT1 dates <var>tta</var><code> + </code><var>ttb</var> and <var>uta</var><code> +
</code><var>utb</var> are Julian Dates, apportioned in any convenient way between
the arguments <var>uta</var> and <var>utb</var>.  For example, <code>JD(UT1) =
2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                   uta            utb
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  In the case of <var>uta</var>, <var>utb</var>, the date &amp; time
method is best matched to the Earth rotation angle algorithm used:
maximum precision is delivered when the uta argument is for 0hrs UT1 on
the day in question and the <var>utb</var> argument lies in the range
0 to 1, or vice versa.

          <li>The caller is responsible for providing the nutation components; they
are in longitude and obliquity, in radians and are with respect to the
equinox and ecliptic of date.  For high&ndash;accuracy applications, free
core nutation should be included as well as any other relevant
corrections to the position of the CIP.

          <li>The arguments <var>xp</var> and <var>yp</var> are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to 0 and 90 deg west respectively.

          <li>The matrix <var>rc2t</var> transforms from celestial to terrestrial coordinates:

          <pre class="example">               [TRS] = RPOM * R_3(GST) * RBPN * [CRS]
                     = rc2t * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), <code>RBPN</code> is the
bias&ndash;precession&ndash;nutation matrix, <code>GST</code> is the Greenwich
(apparent) Sidereal Time and <code>RPOM</code> is the polar motion matrix.

          <li>Although its name does not include <code>00</code>, this function is in fact
specific to the IAU 2000 models.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPn00</code><dd>Bias/precession/nutation results, IAU 2000.

          <br><dt><code>iauGmst00</code><dd>Greenwich mean sidereal time, IAU 2000.

          <br><dt><code>iauSp00</code><dd>The TIO locator s', IERS 2000.

          <br><dt><code>iauEe00</code><dd>Equation of the equinoxes, IAU 2000.

          <br><dt><code>iauPom00</code><dd>Polar motion matrix.

          <br><dt><code>iauC2teqx</code><dd>Form equinox&ndash;based celestial&ndash;to&ndash;terrestrial matrix. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauC2txy</b> (<var>double tta, double ttb, double uta, double utb, double x, double y, double xp, double yp, double rc2t</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauC2txy-40"></a></var><br>
<blockquote><p>Form the celestial to terrestrial matrix given the date, the UT1, the
CIP coordinates and the polar motion.  IAU 2000.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          tta,ttb  double         TT as a 2-part Julian Date (Note 1)
          uta,utb  double         UT1 as a 2-part Julian Date (Note 1)
          x,y      double         Celestial Intermediate Pole (Note 2)
          xp,yp    double         coordinates of the pole (radians, Note 3)
</pre>
        <p>Returned:

     <pre class="example">          rc2t     double[3][3]   celestial-to-terrestrial matrix (Note 4)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT and UT1 dates <var>tta</var><code> + </code><var>ttb</var> and <var>uta</var><code> +
</code><var>utb</var> are Julian Dates, apportioned in any convenient way between
the arguments <var>uta</var> and <var>utb</var>.  For example, <code>JD(UT1) =
2450123.7</code> could be expressed in any o these ways, among others:

          <pre class="example">                   uta            utb
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  In the case of <var>uta</var>, <var>utb</var>, the date &amp; time
method is best matched to the Earth rotation angle algorithm used:
maximum precision is delivered when the <var>uta</var> argument is for 0hrs
UT1 on the day in question and the <var>utb</var> argument lies in the range
0 to 1, or vice versa.

          <li>The Celestial Intermediate Pole coordinates are the x, y
components of the unit vector in the Geocentric Celestial Reference
System.

          <li>The arguments <var>xp</var> and <var>yp</var> are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to 0 and 90 deg west respectively.

          <li>The matrix <var>rc2t</var> transforms from celestial to terrestrial coordinates:

          <pre class="example">               [TRS] = RPOM * R_3(ERA) * RC2I * [CRS]
                     = rc2t * [CRS]
</pre>
          <p class="noindent">where <code>[CRS]</code> is a vector in the Geocentric Celestial Reference
System and <code>[TRS]</code> is a vector in the International Terrestrial
Reference System (see IERS Conventions 2003), <code>ERA</code> is the Earth
Rotation Angle and <code>RPOM</code> is the polar motion matrix.

          <li>Although its name does not include <code>00</code>, this function is in fact
specific to the IAU 2000 models.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauC2ixy</code><dd>Celestial&ndash;to&ndash;intermediate matrix, given X, Y.

          <br><dt><code>iauEra00</code><dd>Earth rotation angle, IAU 2000.

          <br><dt><code>iauSp00</code><dd>The TIO locator s', IERS 2000.

          <br><dt><code>iauPom00</code><dd>Polar motion matrix.

          <br><dt><code>iauC2tcio</code><dd>Form CIO-based celestial&ndash;to&ndash;terrestrial matrix. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauEo06a</b> (<var>double date1, double date2</var>)<var><a name="index-iauEo06a-41"></a></var><br>
<blockquote><p>Equation of the origins, IAU 2006 precession and IAU 2000A nutation.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double    TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                       double    equation of the origins in radians
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The equation of the origins is the distance between the true equinox and
the celestial intermediate origin and, equivalently, the difference
between Earth rotation angle and Greenwich apparent sidereal time
(ERA-GST).  It comprises the precession (since J2000.0) in right
ascension plus the equation of the equinoxes (including the small
correction terms).
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPnm06a</code><dd>Classical NPB matrix, IAU 2006/2000A.

          <br><dt><code>iauBpn2xy</code><dd>Extract CIP X,Y coordinates from NPB matrix.

          <br><dt><code>iauS06</code><dd>The CIO locator s, given X,Y, IAU 2006.

          <br><dt><code>iauEors</code><dd>Equation of the origins, Given NPB matrix and s. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N. &amp; Wallace, P.T., 2006, Astron.Astrophys. 450, 855

          <li>Wallace, P.T. &amp; Capitaine, N., 2006, Astron.Astrophys. 459, 981. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauEors</b> (<var>double rnpb</var>[<var>3</var>][<var>3</var>]<var>, double s</var>)<var><a name="index-iauEors-42"></a></var><br>
<blockquote><p>Equation of the origins, given the classical NPB matrix and the quantity
<var>s</var>.

        <p>Status: support function.

        <p>Given:
     <pre class="example">          rnpb  double[3][3]  classical nutation x precession x bias matrix
          s     double        the quantity s (the CIO locator)
</pre>
        <p>Returned (function value):

     <pre class="example">                double        the equation of the origins in radians.
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The equation of the origins is the distance between the true equinox and
the celestial intermediate origin and, equivalently, the difference
between Earth rotation angle and Greenwich apparent sidereal time
(ERA-GST).  It comprises the precession (since J2000.0) in right
ascension plus the equation of the equinoxes (including the small
correction terms).

          <li>The algorithm is from Wallace &amp; Capitaine (2006).
             </ol>

        <p>References:

          <ul>
<li>Capitaine, N. &amp; Wallace, P.T., 2006, Astron.Astrophys. 450, 855

          <li>Wallace, P. &amp; Capitaine, N., 2006, Astron.Astrophys. 459, 981. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauFw2m</b> (<var>double gamb, double phib, double psi, double eps, double r</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauFw2m-43"></a></var><br>
<blockquote><p>Form rotation matrix given the Fukushima&ndash;Williams angles.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          gamb     double         F-W angle gamma_bar (radians)
          phib     double         F-W angle phi_bar (radians)
          psi      double         F-W angle psi (radians)
          eps      double         F-W angle epsilon (radians)
</pre>
        <p>Returned:

     <pre class="example">          r        double[3][3]   rotation matrix
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Naming the following points:

          <pre class="example">               e = J2000.0 ecliptic pole,
               p = GCRS pole,
               E = ecliptic pole of date,
               P = CIP,
</pre>
          <p class="noindent">the four Fukushima&ndash;Williams angles are as follows:

          <pre class="example">               gamb = gamma   = epE
               phib = phi     = pE
               psi  = psi     = pEP
               eps  = epsilon = EP
</pre>
          <li>The matrix representing the combined effects of frame bias, precession
and nutation is:

          <pre class="example">               NxPxB = R_1(-eps).R_3(-psi).R_1(phib).R_3(gamb)
</pre>
          <li>Three different matrices can be constructed, depending on the supplied
angles:

               <ul>
<li>To obtain the nutation x precession x frame bias matrix, generate the
four precession angles, generate the nutation components and add them to
the psi_bar and epsilon_A angles, and call the present function.

               <li>To obtain the precession x frame bias matrix, generate the four
precession angles and call the present function.

               <li>To obtain the frame bias matrix, generate the four precession angles for
date J2000.0 and call the present function. 
</ul>

          <p>The nutation&ndash;only and precession&ndash;only matrices can if necessary be
obtained by combining these three appropriately.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauIr</code><dd>Initialize <code>r</code>-matrix to identity.

          <br><dt><code>iauRz</code><dd>Rotate around Z-axis.

          <br><dt><code>iauRx</code><dd>Rotate around X-axis. 
</dl>

        <p>Reference:

          <ul>
<li>Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauFw2xy</b> (<var>double gamb, double phib, double psi, double eps, double * x, double * y</var>)<var><a name="index-iauFw2xy-44"></a></var><br>
<blockquote><p>CIP X,Y given Fukushima&ndash;Williams bias&ndash;precession&ndash;nutation angles.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          gamb     double    F-W angle gamma_bar (radians)
          phib     double    F-W angle phi_bar (radians)
          psi      double    F-W angle psi (radians)
          eps      double    F-W angle epsilon (radians)
</pre>
        <p>Returned:

     <pre class="example">          x,y      double    CIP X,Y ("radians")
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Naming the following points:

          <pre class="example">               e = J2000.0 ecliptic pole,
               p = GCRS pole
               E = ecliptic pole of date,
               P = CIP,
</pre>
          <li>the four Fukushima&ndash;Williams angles are as follows:

          <pre class="example">               gamb = gamma   = epE
               phib = phi     = pE
               psi  = psi     = pEP
               eps  = epsilon = EP
</pre>
          <li>The matrix representing the combined effects of frame bias, precession
and nutation is:

          <pre class="example">               NxPxB = R_1(-epsA).R_3(-psi).R_1(phib).R_3(gamb)
</pre>
          <p class="noindent">X,Y are elements (3,1) and (3,2) of the
matrix.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauFw2m</code><dd>F-W angles to <code>r</code>-matrix.

          <br><dt><code>iauBpn2xy</code><dd>Extract CIP X,Y coordinates from NPB matrix. 
</dl>

        <p>Reference:

          <ul>
<li>Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauNum00a</b> (<var>double date1, double date2, double rmatn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauNum00a-45"></a></var><br>
<blockquote><p>Form the matrix of nutation for a given date, IAU 2000A model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double          TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rmatn        double[3][3]    nutation matrix
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix operates in the sense <code>V(true) = rmatn * V(mean)</code>, where
the <code>p</code>-vector <code>V(true)</code> is with respect to the true
equatorial triad of date and the <code>p</code>-vector <code>V(mean)</code> is with
respect to the mean equatorial triad of date.

          <li>A faster, but slightly less accurate result (about 1 mas), can be
obtained by using instead the iauNum00b function.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPn00a</code><dd>Bias/precession/nutation, IAU 2000A. 
</dl>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.222-3
(p114). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauNum00b</b> (<var>double date1, double date2, double rmatn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauNum00b-46"></a></var><br>
<blockquote><p>Form the matrix of nutation for a given date, IAU 2000B model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double         TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rmatn        double[3][3]   nutation matrix
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix operates in the sense <code>V(true) = rmatn * V(mean)</code>, where
the <code>p</code>-vector <code>V(true)</code> is with respect to the true
equatorial triad of date and the <code>p</code>-vector <code>V(mean)</code> is with
respect to the mean equatorial triad of date.

          <li>The present function is faster, but slightly less accurate (about
1 mas), than the iauNum00a function.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPn00b</code><dd>Bias/precession/nutation, IAU 2000B. 
</dl>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.222-3
(p114). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauNum06a</b> (<var>double date1, double date2, double rmatn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauNum06a-47"></a></var><br>
<blockquote><p>Form the matrix of nutation for a given date, IAU 2006/2000A model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2   double          TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rmatn         double[3][3]    nutation matrix
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix operates in the sense <code>V(true) = rmatn * V(mean)</code>, where
the <code>p</code>-vector <code>V(true)</code> is with respect to the true
equatorial triad of date and the <code>p</code>-vector <code>V(mean)</code> is with
respect to the mean equatorial triad of date.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauObl06</code><dd>Mean obliquity, IAU 2006.

          <br><dt><code>iauNut06a</code><dd>Nutation, IAU 2006/2000A.

          <br><dt><code>iauNumat</code><dd>Form nutation matrix. 
</dl>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.222-3
(p114). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauNumat</b> (<var>double epsa, double dpsi, double deps, double rmatn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauNumat-48"></a></var><br>
<blockquote><p>Form the matrix of nutation.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          epsa        double         mean obliquity of date (Note 1)
          dpsi,deps   double         nutation (Note 2)
</pre>
        <p>Returned:

     <pre class="example">          rmatn       double[3][3]   nutation matrix (Note 3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The supplied mean obliquity <var>epsa</var>, must be consistent with the
precession&ndash;nutation models from which dpsi and deps were obtained.

          <li>The caller is responsible for providing the nutation components; they
are in longitude and obliquity, in radians and are with respect to the
equinox and ecliptic of date.

          <li>The matrix operates in the sense <code>V(true) = rmatn * V(mean)</code>, where
the <code>p</code>-vector <code>V(true)</code> is with respect to the true
equatorial triad of date and the <code>p</code>-vector <code>V(mean)</code> is with
respect to the mean equatorial triad of date.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauIr</code><dd>Initialize <code>r</code>-matrix to identity.

          <br><dt><code>iauRx</code><dd>Rotate around X-axis.

          <br><dt><code>iauRz</code><dd>Rotate around Z-axis. 
</dl>

        <p>Reference:

          <ul>
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.222-3
(p114). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauNut00a</b> (<var>double date1, double date2, double * dpsi, double * deps</var>)<var><a name="index-iauNut00a-49"></a></var><br>
<blockquote><p>Nutation, IAU 2000A model (MHB2000 luni-solar and planetary nutation
with free core nutation omitted).

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2   double   TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          dpsi,deps     double   nutation, luni-solar + planetary (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The nutation components in longitude and obliquity are in radians and
with respect to the equinox and ecliptic of date.  The obliquity at
J2000.0 is assumed to be the Lieske et al. (1977) value of 84381.448
arcsec.

          <p>Both the luni&ndash;solar and planetary nutations are included.  The latter
are due to direct planetary nutations and the perturbations of the lunar
and terrestrial orbits.

          <li>The function computes the MHB2000 nutation series with the associated
corrections for planetary nutations.  It is an implementation of the
nutation part of the IAU 2000A precession&ndash;nutation model, formally
adopted by the IAU General Assembly in 2000, namely MHB2000 (Mathews et
al. 2002), but with the free core nutation (FCN &mdash; see Note 4) omitted.

          <li>The full MHB2000 model also contains contributions to the nutations in
longitude and obliquity due to the free-excitation of the
free&ndash;core&ndash;nutation during the period 1979-2000.  These FCN terms,
which are time&ndash;dependent and unpredictable, are NOT included in the
present function and, if required, must be independently computed.  With
the FCN corrections included, the present function delivers a pole which
is at current epochs accurate to a few hundred microarcseconds.  The
omission of FCN introduces further errors of about that size.

          <li>The present function provides classical nutation.  The MHB2000
algorithm, from which it is adapted, deals also with (i) the offsets
between the GCRS and mean poles and (ii) the adjustments in longitude
and obliquity due to the changed precession rates.  These additional
functions, namely frame bias and precession adjustments, are supported
by the SOFA functions iauBi00 and iauPr00.

          <li>The MHB2000 algorithm also provides &ldquo;total&rdquo; nutations, comprising the
arithmetic sum of the frame bias, precession adjustments, luni-solar
nutation and planetary nutation.  These total nutations can be used in
combination with an existing IAU 1976 precession implementation, such as
iauPmat76, to deliver GCRS- to-true predictions of sub-mas accuracy at
current dates.  However, there are three shortcomings in the MHB2000
model that must be taken into account if more accurate or definitive
results are required (see Wallace 2002):

               <ol type=a start=1>
<li>The MHB2000 total nutations are simply arithmetic sums, yet in reality
the various components are successive Euler rotations.  This slight lack
of rigor leads to cross terms that exceed 1 mas after a century.  The
rigorous procedure is to form the GCRS-to-true rotation matrix by
applying the bias, precession and nutation in that order.

               <li>Although the precession adjustments are stated to be with respect to
Lieske et al. (1977), the MHB2000 model does not specify which set of
Euler angles are to be used and how the adjustments are to be applied. 
The most literal and straightforward procedure is to adopt the
4-rotation epsilon_0, psi_A, omega_A, xi_A option, and to add DPSIPR to
psi_A and DEPSPR to both omega_A and eps_A.

               <li>The MHB2000 model predates the determination by Chapront et al. (2002)
of a 14.6 mas displacement between the J2000.0 mean equinox and the
origin of the ICRS frame.  It should, however, be noted that neglecting
this displacement when calculating star coordinates does not lead to a
14.6 mas change in right ascension, only a small second- order
distortion in the pattern of the precession-nutation effect.
               </ol>

          <p>For these reasons, the SOFA functions do not generate the &ldquo;total
nutations&rdquo; directly, though they can of course easily be generated by
calling iauBi00, iauPr00 and the present function and adding the
results.

          <li>The MHB2000 model contains 41 instances where the same frequency appears
multiple times, of which 38 are duplicates and three are triplicates. 
To keep the present code close to the original MHB algorithm, this small
inefficiency has not been corrected.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauFal03</code><dd>Mean anomaly of the Moon.

          <br><dt><code>iauFaf03</code><dd>Mean argument of the latitude of the Moon.

          <br><dt><code>iauFaom03</code><dd>Mean longitude of the Moon's ascending node.

          <br><dt><code>iauFame03</code><dd>Mean longitude of Mercury.

          <br><dt><code>iauFave03</code><dd>Mean longitude of Venus.

          <br><dt><code>iauFae03</code><dd>Mean longitude of Earth.

          <br><dt><code>iauFama03</code><dd>Mean longitude of Mars.

          <br><dt><code>iauFaju03</code><dd>Mean longitude of Jupiter.

          <br><dt><code>iauFasa03</code><dd>Mean longitude of Saturn.

          <br><dt><code>iauFaur03</code><dd>Mean longitude of Uranus.

          <br><dt><code>iauFapa03</code><dd>General accumulated precession in longitude. 
</dl>

        <p>References:

          <ul>
<li>Chapront, J., Chapront-Touze, M. &amp; Francou, G. 2002,
Astron.Astrophys. 387, 700

          <li>Lieske, J.H., Lederle, T., Fricke, W. &amp; Morando, B. 1977,
Astron.Astrophys. 58, 1-16

          <li>Mathews, P.M., Herring, T.A., Buffet, B.A. 2002, J.Geophys.Res.  107,
B4.  The MHB_2000 code itself was obtained on 9th September 2002 from:

          <div align="center"><a href="ftp//maia.usno.navy.mil/conv2000/chapter5/IAU2000A">ftp//maia.usno.navy.mil/conv2000/chapter5/IAU2000A</a></div>

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

          <li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.

          <li>Wallace, P.T., &ldquo;Software for Implementing the IAU 2000 Resolutions&rdquo;,
in IERS Workshop 5.1 (2002). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauNut00b</b> (<var>double date1, double date2, double * dpsi, double * deps</var>)<var><a name="index-iauNut00b-50"></a></var><br>
<blockquote><p>Nutation, IAU 2000B model.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2   double    TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          dpsi,deps     double    nutation, luni-solar + planetary (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The nutation components in longitude and obliquity are in radians and
with respect to the equinox and ecliptic of date.  The obliquity at
J2000.0 is assumed to be the Lieske et al. (1977) value of 84381.448
arcsec.  (The errors that result from using this function with the IAU
2006 value of 84381.406 arcsec can be neglected.)

          <p>The nutation model consists only of luni&ndash;solar terms, but includes also
a fixed offset which compensates for certain long&ndash;period planetary
terms (Note 7).

          <li>This function is an implementation of the IAU 2000B abridged nutation
model formally adopted by the IAU General Assembly in 2000.  The
function computes the MHB_2000_SHORT luni&ndash;solar nutation series (Luzum
2001), but without the associated corrections for the precession rate
adjustments and the offset between the GCRS and J2000.0 mean poles.

          <li>The full IAU 2000A (MHB2000) nutation model contains nearly 1400 terms. 
The IAU 2000B model (McCarthy &amp; Luzum 2003) contains only 77 terms, plus
additional simplifications, yet still delivers results of 1 mas accuracy
at present epochs.  This combination of accuracy and size makes the IAU
2000B abridged nutation model suitable for most practical applications.

          <p>The function delivers a pole accurate to 1 mas from 1900 to 2100
(usually better than 1 mas, very occasionally just outside 1 mas).  The
full IAU 2000A model, which is implemented in the function iauNut00a
(q.v.), delivers considerably greater accuracy at current dates;
however, to realize this improved accuracy, corrections for the
essentially unpredictable free-core-nutation (FCN) must also be
included.

          <li>The present function provides classical nutation.  The MHB_2000_SHORT
algorithm, from which it is adapted, deals also with (i) the offsets
between the GCRS and mean poles and (ii) the adjustments in longitude
and obliquity due to the changed precession rates.  These additional
functions, namely frame bias and precession adjustments, are supported
by the SOFA functions iauBi00 and iauPr00.

          <li>The MHB_2000_SHORT algorithm also provides &ldquo;total&rdquo; nutations,
comprising the arithmetic sum of the frame bias, precession adjustments,
and nutation (luni-solar + planetary).  These total nutations can be
used in combination with an existing IAU 1976 precession implementation,
such as <code>iauPmat76</code>, to deliver GCRS&ndash;to&ndash;true predictions of mas
accuracy at current epochs.  However, for symmetry with the iauNut00a
function (q.v. for the reasons), the <acronym>SOFA</acronym> functions do not generate
the &ldquo;total nutations&rdquo; directly.  Should they be required, they could
of course easily be generated by calling <code>iauBi00</code>, <code>iauPr00</code>
and the present function and adding the results.

          <li>The IAU 2000B model includes &ldquo;planetary bias&rdquo; terms that are fixed in
size but compensate for long-period nutations.  The amplitudes quoted in
McCarthy &amp; Luzum (2003), namely <code>Dpsi = -1.5835 mas</code> and
<code>Depsilon = +1.6339 mas</code>, are optimized for the &ldquo;total nutations&rdquo;
method described in Note 6.  The Luzum (2001) values used in this SOFA
implementation, namely -0.135 mas and +0.388 mas, are optimized for the
&ldquo;rigorous&rdquo; method, where frame bias, precession and nutation are
applied separately and in that order.  During the interval 1995-2050,
the <acronym>SOFA</acronym> implementation delivers a maximum error of 1.001 mas (not
including FCN).
             </ol>

        <p>References:

          <ul>
<li>Lieske, J.H., Lederle, T., Fricke, W., Morando, B., &ldquo;Expressions for
the precession quantities based upon the IAU /1976/ system of
astronomical constants&rdquo;, Astron.Astrophys. 58, 1-2, 1-16. (1977).

          <li>Luzum, B., private communication, 2001 (Fortran code MHB_2000_SHORT).

          <li>McCarthy, D.D. &amp; Luzum, B.J., &ldquo;An abridged model of the
precession&ndash;nutation of the celestial pole&rdquo;, Cel.Mech.Dyn.Astron.  85,
37-49 (2003).

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J., Astron.Astrophys. 282, 663-683 (1994). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauNut06a</b> (<var>double date1, double date2, double * dpsi, double * deps</var>)<var><a name="index-iauNut06a-51"></a></var><br>
<blockquote><p>IAU 2000A nutation with adjustments to match the IAU 2006 precession.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2   double   TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          dpsi,deps     double   nutation, luni-solar + planetary (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The nutation components in longitude and obliquity are in radians and
with respect to the mean equinox and ecliptic of date, IAU 2006
precession model (Hilton et al. 2006, Capitaine et al.  2005).

          <li>The function first computes the IAU 2000A nutation, then applies
adjustments for (i) the consequences of the change in obliquity from the
IAU 1980 ecliptic to the IAU 2006 ecliptic and (ii) the secular
variation in the Earth's dynamical form factor J2.

          <li>The present function provides classical nutation, complementing the IAU
2000 frame bias and IAU 2006 precession.  It delivers a pole which is at
current epochs accurate to a few tens of microarcseconds, apart from the
free core nutation.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauNut00a</code><dd>Nutation, IAU 2000A. 
</dl>

        <p>References:

          <ul>
<li>Chapront, J., Chapront-Touze, M. &amp; Francou, G. 2002,
Astron.Astrophys. 387, 700

          <li>Lieske, J.H., Lederle, T., Fricke, W. &amp; Morando, B. 1977,
Astron.Astrophys. 58, 1-16

          <li>Mathews, P.M., Herring, T.A., Buffet, B.A. 2002, J.Geophys.Res.  107,
B4.  The MHB_2000 code itself was obtained on 9th September 2002 from:

          <div align="center"><a href="ftp//maia.usno.navy.mil/conv2000/chapter5/IAU2000A">ftp//maia.usno.navy.mil/conv2000/chapter5/IAU2000A</a></div>

          <li>Simon, J.-L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G., Laskar, J. 1994, Astron.Astrophys. 282, 663-683.

          <li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M.  1999,
Astron.Astrophys.Supp.Ser. 135, 111.

          <li>Wallace, P.T., &ldquo;Software for Implementing the IAU 2000 Resolutions&rdquo;,
in IERS Workshop 5.1 (2002). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauNut80</b> (<var>double date1, double date2, double * dpsi, double * deps</var>)<var><a name="index-iauNut80-52"></a></var><br>
<blockquote><p>Nutation, IAU 1980 model.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2   double    TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          dpsi          double    nutation in longitude (radians)
          deps          double    nutation in obliquity (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The nutation components are with respect to the ecliptic of date.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauAnpm</code><dd>Normalize angle into range +/- pi. 
</dl>

        <p>Reference:

          <ul>
Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.222 (p111). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauNutm80</b> (<var>double date1, double date2, double rmatn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauNutm80-53"></a></var><br>
<blockquote><p>Form the matrix of nutation for a given date, IAU 1980 model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2    double          TDB date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rmatn          double[3][3]    nutation matrix
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix operates in the sense <code>V(true) = rmatn * V(mean)</code>, where
the <code>p</code>-vector <code>V(true)</code> is with respect to the true
equatorial triad of date and the <code>p</code>-vector <code>V(mean)</code> is with
respect to the mean equatorial triad of date.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauNut80</code><dd>Nutation, IAU 1980.

          <br><dt><code>iauObl80</code><dd>Mean obliquity, IAU 1980.

          <br><dt><code>iauNumat</code><dd>Form nutation matrix. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauObl06</b> (<var>double date1, double date2</var>)<var><a name="index-iauObl06-54"></a></var><br>
<blockquote><p>Mean obliquity of the ecliptic, IAU 2006 precession model.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2  double   TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">          double   obliquity of the ecliptic (radians, Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The result is the angle between the ecliptic and mean equator of date
<var>date1</var><code> + </code><var>date2</var>.
             </ol>

        <p>Reference:

          <ul>
<li>Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauObl80</b> (<var>double date1, double date2</var>)<var><a name="index-iauObl80-55"></a></var><br>
<blockquote><p>Mean obliquity of the ecliptic, IAU 1980 model.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2   double    TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                        double    obliquity of the ecliptic (radians, Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The result is the angle between the ecliptic and mean equator of date
<var>date1</var><code> + </code><var>date2</var>.
             </ol>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Expression 3.222-1
(p114). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauP06e</b> (<var>double date1, double date2, double * eps0, double * psia, double * oma, double * bpa, double * bqa, double * pia, double * bpia, double * epsa, double * chia, double * za, double * zetaa, double * thetaa, double * pa, double * gam, double * phi, double * psi</var>)<var><a name="index-iauP06e-56"></a></var><br>
<blockquote><p>Precession angles, IAU 2006, equinox based.

        <p>Status: canonical models.

        <p>Given:

     <pre class="example">          date1,date2   double   TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (see Note 2):

     <pre class="example">          eps0          double   epsilon_0
          psia          double   psi_A
          oma           double   omega_A
          bpa           double   P_A
          bqa           double   Q_A
          pia           double   pi_A
          bpia          double   Pi_A
          epsa          double   obliquity epsilon_A
          chia          double   chi_A
          za            double   z_A
          zetaa         double   zeta_A
          thetaa        double   theta_A
          pa            double   p_A
          gam           double   F-W angle gamma_J2000
          phi           double   F-W angle phi_J2000
          psi           double   F-W angle psi_J2000
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>This function returns the set of equinox based angles for the Capitaine
et al. &ldquo;P03&rdquo; precession theory, adopted by the IAU in 2006.  The
angles are set out in Table 1 of Hilton et al. (2006):

          <pre class="example">               eps0   epsilon_0   obliquity at J2000.0
               psia   psi_A       luni-solar precession
               oma    omega_A     inclination of equator wrt J2000.0 ecliptic
               bpa    P_A         ecliptic pole x, J2000.0 ecliptic triad
               bqa    Q_A         ecliptic pole -y, J2000.0 ecliptic triad
               pia    pi_A        angle between moving and J2000.0 ecliptics
               bpia   Pi_A        longitude of ascending node of the ecliptic
               epsa   epsilon_A   obliquity of the ecliptic
               chia   chi_A       planetary precession
               za     z_A         equatorial precession: -3rd 323 Euler angle
               zetaa  zeta_A      equatorial precession: -1st 323 Euler angle
               thetaa theta_A     equatorial precession: 2nd 323 Euler angle
               pa     p_A         general precession
               gam    gamma_J2000 J2000.0 RA difference of ecliptic poles
               phi    phi_J2000   J2000.0 codeclination of ecliptic pole
               psi    psi_J2000   longitude difference of equator poles, J2000.0
</pre>
          <p>The returned values are all radians.

          <li>Hilton et al. (2006) Table 1 also contains angles that depend on models
distinct from the P03 precession theory itself, namely the IAU 2000A
frame bias and nutation.  The quoted polynomials are used in other SOFA
functions:

               <dl>
<dt><code>iauXy06</code><dd>Contains the polynomial parts of the X and Y series.

               <br><dt><code>iauS06</code><dd>Contains the polynomial part of the s+XY/2 series.

               <br><dt><code>iauPfw06</code><dd>Implements the series for the Fukushima&ndash;Williams angles that are with
respect to the GCRS pole (i.e. the variants that include frame bias). 
</dl>

          <li>The IAU resolution stipulated that the choice of parameterization was
left to the user, and so an IAU compliant precession implementation can
be constructed using various combinations of the angles returned by the
present function.

          <li>The parameterization used by SOFA is the version of the Fukushima-
Williams angles that refers directly to the GCRS pole.  These angles may
be calculated by calling the function iauPfw06.  SOFA also supports the
direct computation of the CIP GCRS X,Y by series, available by calling
iauXy06.

          <li>The agreement between the different parameterizations is at the 1
microarcsecond level in the present era.

          <li>When constructing a precession formulation that refers to the GCRS pole
rather than the dynamical pole, it may (depending on the choice of
angles) be necessary to introduce the frame bias explicitly.

          <li>It is permissible to re-use the same variable in the returned arguments. 
The quantities are stored in the stated order.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauObl06</code><dd>Mean obliquity, IAU 2006. 
</dl>

        <p>Reference:

          <ul>
<li>Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPb06</b> (<var>double date1, double date2, double * bzeta, double * bz, double * btheta</var>)<var><a name="index-iauPb06-57"></a></var><br>
<blockquote><p>This function forms three Euler angles which implement general
precession from epoch J2000.0, using the IAU 2006 model.  Frame bias
(the offset between ICRS and mean J2000.0) is included.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double   TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          bzeta        double   1st rotation: radians cw around z
          bz           double   3rd rotation: radians cw around z
          btheta       double   2nd rotation: radians ccw around y
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The traditional accumulated precession angles zeta_A, z_A, theta_A
cannot be obtained in the usual way, namely through polynomial
expressions, because of the frame bias.  The latter means that two of
the angles undergo rapid changes near this date.  They are instead the
results of decomposing the precession&ndash;bias matrix obtained by using the
Fukushima&ndash;Williams method, which does not suffer from the problem.  The
decomposition returns values which can be used in the conventional
formulation and which include frame bias.

          <li>The three angles are returned in the conventional order, which is not
the same as the order of the corresponding Euler rotations.  The
precession&ndash;bias matrix is:

          <pre class="example">               R_3(-z) x R_2(+theta) x R_3(-zeta).
</pre>
          <li>Should zeta_A, z_A, theta_A angles be required that do not contain frame
bias, they are available by calling the <acronym>SOFA</acronym> function iauP06e.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPmat06</code><dd>PB matrix, IAU 2006.

          <br><dt><code>iauRz</code><dd>Rotate around Z-axis. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPfw06</b> (<var>double date1, double date2, double * gamb, double * phib, double * psib, double * epsa</var>)<var><a name="index-iauPfw06-58"></a></var><br>
<blockquote><p>Precession angles, IAU 2006 (Fukushima&ndash;Williams 4-angle formulation).

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2  double   TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          gamb         double   F-W angle gamma_bar (radians)
          phib         double   F-W angle phi_bar (radians)
          psib         double   F-W angle psi_bar (radians)
          epsa         double   F-W angle epsilon_A (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>Naming the following points:

          <pre class="example">               e = J2000.0 ecliptic pole,
               p = GCRS pole,
               E = mean ecliptic pole of date,
               P = mean pole of date,
</pre>
          <p class="noindent">the four Fukushima&ndash;Williams angles are as follows:

          <pre class="example">               gamb = gamma_bar = epE
               phib = phi_bar = pE
               psib = psi_bar = pEP
               epsa = epsilon_A = EP
</pre>
          <li>The matrix representing the combined effects of frame bias and
precession is:

          <pre class="example">               PxB = R_1(-epsa).R_3(-psib).R_1(phib).R_3(gamb)
</pre>
          <li>The matrix representing the combined effects of frame bias, precession
and nutation is simply:

          <pre class="example">               NxPxB = R_1(-epsa-dE).R_3(-psib-dP).R_1(phib).R_3(gamb)
</pre>
          <p class="noindent">where dP and dE are the nutation components with respect to the ecliptic
of date.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauObl06</code><dd>Mean obliquity, IAU 2006. 
</dl>

        <p>Reference:

          <ul>
<li>Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPmat00</b> (<var>double date1, double date2, double rbp</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPmat00-59"></a></var><br>
<blockquote><p>Precession matrix (including frame bias) from GCRS to a specified date,
IAU 2000 model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double          TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rbp          double[3][3]    bias-precession matrix (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix operates in the sense <code>V(date) = rbp * V(GCRS)</code>, where
the <code>p</code>-vector <code>V(GCRS)</code> is with respect to the Geocentric
Celestial Reference System (IAU, 2000) and the <code>p</code>-vector
<code>V(date)</code> is with respect to the mean equatorial triad of the given
date.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauBp00</code><dd>Frame bias and precession matrices, IAU 2000. 
</dl>

        <p>Reference:

          <ul>
<li>IAU: Trans. International Astronomical Union, Vol. XXIVB; Proc.  24th
General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.  (2000). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPmat06</b> (<var>double date1, double date2, double rbp</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPmat06-60"></a></var><br>
<blockquote><p>Precession matrix (including frame bias) from GCRS to a specified date,
IAU 2006 model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double          TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rbp          double[3][3]    bias-precession matrix (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix operates in the sense <code>V(date) = rbp * V(GCRS)</code>, where
the <code>p</code>-vector <code>V(GCRS)</code> is with respect to the Geocentric
Celestial Reference System (IAU, 2000) and the <code>p</code>-vector V(date)
is with respect to the mean equatorial triad of the given date.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPfw06</code><dd>Bias-precession F-W angles, IAU 2006.

          <br><dt><code>iauFw2m</code><dd>F-W angles to <code>r</code>-matrix. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N. &amp; Wallace, P.T., 2006, Astron.Astrophys. 450, 855

          <li>Wallace, P.T. &amp; Capitaine, N., 2006, Astron.Astrophys. 459, 981. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPmat76</b> (<var>double date1, double date2, double rmatp</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPmat76-61"></a></var><br>
<blockquote><p>Precession matrix from J2000.0 to a specified date, IAU 1976 model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2 double       ending date, TT (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rmatp       double[3][3] precession matrix, J2000.0 -&gt; <var>date1</var><code> + </code><var>date2</var>
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix operates in the sense <code>V(date) = RMATP * V(J2000)</code>,
where the <code>p</code>-vector <code>V(J2000)</code> is with respect to the mean
equatorial triad of epoch J2000.0 and the <code>p</code>-vector <code>V(date)</code>
is with respect to the mean equatorial triad of the given date.

          <li>Though the matrix method itself is rigorous, the precession angles are
expressed through canonical polynomials which are valid only for a
limited time span.  In addition, the IAU 1976 precession rate is known
to be imperfect.  The absolute accuracy of the present formulation is
better than 0.1 arcsec from 1960AD to 2040AD, better than 1 arcsec from
1640AD to 2360AD, and remains below 3 arcsec for the whole of the period
500BC to 3000AD.  The errors exceed 10 arcsec outside the range 1200BC
to 3900AD, exceed 100 arcsec outside 4200BC to 5600AD and exceed 1000
arcsec outside 6800BC to 8200AD.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPrec76</code><dd>Accumulated precession angles, IAU 1976.

          <br><dt><code>iauIr</code><dd>Initialize <code>r</code>-matrix to identity.

          <br><dt><code>iauRz</code><dd>Rotate around Z-axis.

          <br><dt><code>iauRy</code><dd>Rotate around Y-axis.

          <br><dt><code>iauCr</code><dd>Copy <code>r</code>-matrix. 
</dl>

        <p>References:

          <ul>
<li>Lieske, J.H., 1979, Astron.Astrophys. 73, 282.

          <li>Equations (6) &amp; (7), p283.

          <li>Kaplan,G.H., 1981. USNO circular no. 163, pA2. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPn00</b> (<var>double date1, double date2, double dpsi, double deps, double * epsa, double rb</var>[<var>3</var>][<var>3</var>]<var>, double rp</var>[<var>3</var>][<var>3</var>]<var>, double rbp</var>[<var>3</var>][<var>3</var>]<var>, double rn</var>[<var>3</var>][<var>3</var>]<var>, double rbpn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPn00-62"></a></var><br>
<blockquote><p>Precession&ndash;nutation, IAU 2000 model: a multi&ndash;purpose function,
supporting classical (equinox&ndash;based) use directly and CIO&ndash;based use
indirectly.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double          TT as a 2-part Julian Date (Note 1)
          dpsi,deps    double          nutation (Note 2)
</pre>
        <p>Returned:

     <pre class="example">          epsa         double          mean obliquity (Note 3)
          rb           double[3][3]    frame bias matrix (Note 4)
          rp           double[3][3]    precession matrix (Note 5)
          rbp          double[3][3]    bias-precession matrix (Note 6)
          rn           double[3][3]    nutation matrix (Note 7)
          rbpn         double[3][3]    GCRS-to-true matrix (Note 8)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The caller is responsible for providing the nutation components; they
are in longitude and obliquity, in radians and are with respect to the
equinox and ecliptic of date.  For high&ndash;accuracy applications, free
core nutation should be included as well as any other relevant
corrections to the position of the CIP.

          <li>The returned mean obliquity is consistent with the IAU 2000
precession&ndash;nutation models.

          <li>The matrix <var>rb</var> transforms vectors from GCRS to J2000.0 mean equator
and equinox by applying frame bias.

          <li>The matrix <var>rp</var> transforms vectors from J2000.0 mean equator and
equinox to mean equator and equinox of date by applying precession.

          <li>The matrix <var>rbp</var> transforms vectors from GCRS to mean equator and
equinox of date by applying frame bias then precession.  It is the
product <var>rp</var><code> * </code><var>rb</var>.

          <li>The matrix <var>rn</var> transforms vectors from mean equator and equinox of
date to true equator and equinox of date by applying the nutation
(luni&ndash;solar + planetary).

          <li>The matrix rbpn transforms vectors from GCRS to true equator and equinox
of date.  It is the product <var>rn</var><code> * </code><var>rbp</var>, applying frame
bias, precession and nutation in that order.

          <li>It is permissible to re-use the same array in the returned arguments. 
The arrays are filled in the order given.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPr00</code><dd>IAU 2000 precession adjustments.

          <br><dt><code>iauObl80</code><dd>Mean obliquity, IAU 1980.

          <br><dt><code>iauBp00</code><dd>Frame bias and precession matrices, IAU 2000.

          <br><dt><code>iauCr</code><dd>Copy <code>r</code>-matrix. 
<br><dt><code>iauNumat</code><dd>Form nutation matrix.

          <br><dt><code>iauRxr</code><dd>Product of two <code>r</code>-matrices. 
</dl>

        <p>Reference:

          <ul>
<li>Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., &ldquo;Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession&ndash;nutation model&rdquo;,
Astron.Astrophys. 400, 1145-1154 (2003).

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed &ldquo;celestial
intermediate origin&rdquo; (CIO) by IAU 2006 Resolution 2. 
</blockquote>
          </ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPn00a</b> (<var>double date1, double date2, double * dpsi, double * deps, double * epsa, double rb</var>[<var>3</var>][<var>3</var>]<var>, double rp</var>[<var>3</var>][<var>3</var>]<var>, double rbp</var>[<var>3</var>][<var>3</var>]<var>, double rn</var>[<var>3</var>][<var>3</var>]<var>, double rbpn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPn00a-63"></a></var><br>
<blockquote><p>Precession&ndash;nutation, IAU 2000A model: a multi&ndash;purpose function,
supporting classical (equinox&ndash;based) use directly and CIO&ndash;based use
indirectly.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double          TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          dpsi,deps    double          nutation (Note 2)
          epsa         double          mean obliquity (Note 3)
          rb           double[3][3]    frame bias matrix (Note 4)
          rp           double[3][3]    precession matrix (Note 5)
          rbp          double[3][3]    bias-precession matrix (Note 6)
          rn           double[3][3]    nutation matrix (Note 7)
          rbpn         double[3][3]    GCRS-to-true matrix (Notes 8,9)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The nutation components (luni&ndash;solar + planetary, IAU 2000A) in
longitude and obliquity are in radians and with respect to the equinox
and ecliptic of date.  Free core nutation is omitted; for the utmost
accuracy, use the <code>iauPn00</code> function, where the nutation components
are caller&ndash;specified.  For faster but slightly less accurate results,
use the <code>iauPn00b</code> function.

          <li>The mean obliquity is consistent with the IAU 2000 precession.

          <li>The matrix rb transforms vectors from GCRS to J2000.0 mean equator and
equinox by applying frame bias.

          <li>The matrix <var>rp</var> transforms vectors from J2000.0 mean equator and
equinox to mean equator and equinox of date by applying precession.

          <li>The matrix rbp transforms vectors from GCRS to mean equator and equinox
of date by applying frame bias then precession.  It is the product
<var>rp</var><code> * </code><var>rb</var>.

          <li>The matrix <var>rn</var> transforms vectors from mean equator and equinox of
date to true equator and equinox of date by applying the nutation
(luni&ndash;solar + planetary).

          <li>The matrix rbpn transforms vectors from GCRS to true equator and equinox
of date.  It is the product <var>rn</var><code> * </code><var>rbp</var>, applying frame
bias, precession and nutation in that order.

          <li>The X, Y, Z coordinates of the IAU 2000B Celestial
Intermediate Pole are elements (3,1-3) of the matrix <var>rbpn</var>.

          <li>It is permissible to re-use the same array in the returned arguments. 
The arrays are filled in the order given.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauNut00a</code><dd>Nutation, IAU 2000A.

          <br><dt><code>iauPn00</code><dd>Bias/precession/nutation results, IAU 2000. 
</dl>

        <p>Reference:

          <ul>
<li>Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., &ldquo;Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession&ndash;nutation model&rdquo;,
Astron.Astrophys. 400, 1145-1154 (2003).

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed &ldquo;celestial
intermediate origin&rdquo; (CIO) by IAU 2006 Resolution 2. 
</blockquote>
          </ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPn00b</b> (<var>double date1, double date2, double * dpsi, double * deps, double * epsa, double rb</var>[<var>3</var>][<var>3</var>]<var>, double rp</var>[<var>3</var>][<var>3</var>]<var>, double rbp</var>[<var>3</var>][<var>3</var>]<var>, double rn</var>[<var>3</var>][<var>3</var>]<var>, double rbpn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPn00b-64"></a></var><br>
<blockquote><p>Precession&ndash;nutation, IAU 2000B model: a multi&ndash;purpose function,
supporting classical (equinox&ndash;based) use directly and CIO&ndash;based use
indirectly.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double          TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          dpsi,deps    double          nutation (Note 2)
          epsa         double          mean obliquity (Note 3)
          rb           double[3][3]    frame bias matrix (Note 4)
          rp           double[3][3]    precession matrix (Note 5)
          rbp          double[3][3]    bias-precession matrix (Note 6)
          rn           double[3][3]    nutation matrix (Note 7)
          rbpn         double[3][3]    GCRS-to-true matrix (Notes 8,9)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The nutation components (luni&ndash;solar + planetary, IAU 2000B) in
longitude and obliquity are in radians and with respect to the equinox
and ecliptic of date.  For more accurate results, but at the cost of
increased computation, use the <code>iauPn00a</code> function.  For the utmost
accuracy, use the <code>iauPn00</code> function, where the nutation components
are caller&ndash;specified.

          <li>The mean obliquity is consistent with the IAU 2000 precession.

          <li>The matrix <var>rb</var> transforms vectors from GCRS to J2000.0 mean equator
and equinox by applying frame bias.

          <li>The matrix <var>rp</var> transforms vectors from J2000.0 mean equator and
equinox to mean equator and equinox of date by applying precession.

          <li>The matrix <var>rbp</var> transforms vectors from GCRS to mean equator and
equinox of date by applying frame bias then precession.  It is the
product <var>rp</var><code> * </code><var>rb</var>.

          <li>The matrix <var>rn</var> transforms vectors from mean equator and equinox of
date to true equator and equinox of date by applying the nutation
(luni&ndash;solar + planetary).

          <li>The matrix <var>rbpn</var> transforms vectors from GCRS to true equator and
equinox of date.  It is the product <var>rn</var><code> * </code><var>rbp</var>,
applying frame bias, precession and nutation in that order.

          <li>The X, Y, Z coordinates of the IAU 2000B Celestial
Intermediate Pole are elements (3,1-3) of the matrix rbpn.

          <li>It is permissible to re-use the same array in the returned arguments. 
The arrays are filled in the stated order.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauNut00b</code><dd>Nutation, IAU 2000B.

          <br><dt><code>iauPn00</code><dd>Bias/precession/nutation results, IAU 2000. 
</dl>

        <p>Reference:

          <ul>
<li>Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., &ldquo;Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession&ndash;nutation model&rdquo;,
Astron.Astrophys. 400, 1145-1154 (2003).

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed &ldquo;celestial
intermediate origin&rdquo; (CIO) by IAU 2006 Resolution 2. 
</blockquote>
          </ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPn06</b> (<var>double date1, double date2, double dpsi, double deps, double * epsa, double rb</var>[<var>3</var>][<var>3</var>]<var>, double rp</var>[<var>3</var>][<var>3</var>]<var>, double rbp</var>[<var>3</var>][<var>3</var>]<var>, double rn</var>[<var>3</var>][<var>3</var>]<var>, double rbpn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPn06-65"></a></var><br>
<blockquote><p>Precession&ndash;nutation, IAU 2006 model: a multi&ndash;purpose function,
supporting classical (equinox&ndash;based) use directly and CIO&ndash;based use
indirectly.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double          TT as a 2-part Julian Date (Note 1)
          dpsi,deps    double          nutation (Note 2)
</pre>
        <p>Returned:

     <pre class="example">          epsa         double          mean obliquity (Note 3)
          rb           double[3][3]    frame bias matrix (Note 4)
          rp           double[3][3]    precession matrix (Note 5)
          rbp          double[3][3]    bias-precession matrix (Note 6)
          rn           double[3][3]    nutation matrix (Note 7)
          rbpn         double[3][3]    GCRS-to-true matrix (Note 8)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The caller is responsible for providing the nutation components; they
are in longitude and obliquity, in radians and are with respect to the
equinox and ecliptic of date.  For high&ndash;accuracy applications, free
core nutation should be included as well as any other relevant
corrections to the position of the CIP.

          <li>The returned mean obliquity is consistent with the IAU 2006 precession.

          <li>The matrix <var>rb</var> transforms vectors from GCRS to J2000.0 mean equator
and equinox by applying frame bias.

          <li>The matrix <var>rp</var> transforms vectors from J2000.0 mean equator and
equinox to mean equator and equinox of date by applying precession.

          <li>The matrix <var>rbp</var> transforms vectors from GCRS to mean equator and
equinox of date by applying frame bias then precession.  It is the
product <var>rp</var><code> * </code><var>rb</var>.

          <li>The matrix <var>rn</var> transforms vectors from mean equator and equinox of
date to true equator and equinox of date by applying the nutation
(luni&ndash;solar + planetary).

          <li>The matrix <var>rbpn</var> transforms vectors from GCRS to true equator and
equinox of date.  It is the product <var>rn</var><code> * </code><var>rbp</var>,
applying frame bias, precession and nutation in that order.

          <li>The X, Y, Z coordinates of the IAU 2000B Celestial
Intermediate Pole are elements (3,1-3) of the matrix <var>rbpn</var>.

          <li>It is permissible to re-use the same array in the returned arguments. 
The arrays are filled in the stated order.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPfw06</code><dd>Bias-precession F-W angles, IAU 2006.

          <br><dt><code>iauFw2m</code><dd>F-W angles to <code>r</code>-matrix.

          <br><dt><code>iauCr</code><dd>Copy <code>r</code>-matrix.

          <br><dt><code>iauTr</code><dd>Transpose <code>r</code>-matrix.

          <br><dt><code>iauRxr</code><dd>Product of two <code>r</code>-matrices. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N. &amp; Wallace, P.T., 2006, Astron.Astrophys. 450, 855

          <li>Wallace, P.T. &amp; Capitaine, N., 2006, Astron.Astrophys. 459, 981. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPn06a</b> (<var>double date1, double date2, double * dpsi, double * deps, double * epsa, double rb</var>[<var>3</var>][<var>3</var>]<var>, double rp</var>[<var>3</var>][<var>3</var>]<var>, double rbp</var>[<var>3</var>][<var>3</var>]<var>, double rn</var>[<var>3</var>][<var>3</var>]<var>, double rbpn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPn06a-66"></a></var><br>
<blockquote><p>Precession&ndash;nutation, IAU 2006/2000A models: a multi&ndash;purpose function,
supporting classical (equinox&ndash;based) use directly and CIO&ndash;based use
indirectly.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double          TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          dpsi,deps    double          nutation (Note 2)
          epsa         double          mean obliquity (Note 3)
          rb           double[3][3]    frame bias matrix (Note 4)
          rp           double[3][3]    precession matrix (Note 5)
          rbp          double[3][3]    bias-precession matrix (Note 6)
          rn           double[3][3]    nutation matrix (Note 7)
          rbpn         double[3][3]    GCRS-to-true matrix (Notes 8,9)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The nutation components (luni&ndash;solar + planetary, IAU 2000A) in
longitude and obliquity are in radians and with respect to the equinox
and ecliptic of date.  Free core nutation is omitted; for the utmost
accuracy, use the <code>iauPn06</code> function, where the nutation components
are caller&ndash;specified.

          <li>The mean obliquity is consistent with the IAU 2006 precession.

          <li>The matrix <var>rb</var> transforms vectors from GCRS to mean J2000.0 by
applying frame bias.

          <li>The matrix <var>rp</var> transforms vectors from mean J2000.0 to mean of date
by applying precession.

          <li>The matrix rbp transforms vectors from GCRS to mean of date by applying
frame bias then precession.  It is the product <var>rp</var><code> *
</code><var>rb</var>.

          <li>The matrix <var>rn</var> transforms vectors from mean of date to true of date
by applying the nutation (luni&ndash;solar + planetary).

          <li>The matrix rbpn transforms vectors from GCRS to true of date
(CIP/equinox).  It is the product <var>rn</var><code> * </code><var>rbp</var>, applying
frame bias, precession and nutation in that order.

          <li>The X, Y, Z coordinates of the IAU 2006/2000A
Celestial Intermediate Pole are elements (1,1-3) of the matrix
<var>rbpn</var>.

          <li>It is permissible to re-use the same array in the returned arguments. 
The arrays are filled in the stated order.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauNut06a</code><dd>Nutation, IAU 2006/2000A.

          <br><dt><code>iauPn06</code><dd>Bias/precession/nutation results, IAU 2006. 
</dl>

        <p>Reference:

          <ul>
<li>Capitaine, N. &amp; Wallace, P.T., 2006, Astron.Astrophys. 450, 855. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPnm00a</b> (<var>double date1, double date2, double rbpn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPnm00a-67"></a></var><br>
<blockquote><p>Form the matrix of precession&ndash;nutation for a given date (including
frame bias), equinox&ndash;based, IAU 2000A model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double     TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rbpn         double[3][3]    classical NPB matrix (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix operates in the sense <code>V(date) = rbpn * V(GCRS)</code>, where
the <code>p</code>-vector <code>V(date)</code> is with respect to the true
equatorial triad of date <var>date1</var><code> + </code><var>date2</var> and the
<code>p</code>-vector <code>V(GCRS)</code> is with respect to the Geocentric
Celestial Reference System (IAU, 2000).

          <li>A faster, but slightly less accurate result (about 1 mas), can be
obtained by using instead the <code>iauPnm00b</code> function.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPn00a</code><dd>Bias/precession/nutation, IAU 2000A. 
</dl>

        <p>Reference:

          <ul>
<li>IAU: Trans. International Astronomical Union, Vol. XXIVB; Proc.  24th
General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.  (2000). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPnm00b</b> (<var>double date1, double date2, double rbpn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPnm00b-68"></a></var><br>
<blockquote><p>Form the matrix of precession&ndash;nutation for a given date (including
frame bias), equinox&ndash;based, IAU 2000B model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2 double       TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rbpn        double[3][3] bias-precession-nutation matrix (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix operates in the sense <code>V(date) = rbpn * V(GCRS)</code>, where
the <code>p</code>-vector <code>V(date)</code> is with respect to the true
equatorial triad of date <var>date1</var><code> + </code><var>date2</var> and the
<code>p</code>-vector V(GCRS) is with respect to the Geocentric Celestial
Reference System (IAU, 2000).

          <li>The present function is faster, but slightly less accurate (about
1 mas), than the <code>iauPnm00a</code> function.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPn00b</code><dd>Bias/precession/nutation, IAU 2000B. 
</dl>

        <p>Reference:

          <ul>
<li>IAU: Trans. International Astronomical Union, Vol. XXIVB; Proc.  24th
General Assembly, Manchester, UK.  Resolutions B1.3, B1.6.  (2000). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPnm06a</b> (<var>double date1, double date2, double rnpb</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPnm06a-69"></a></var><br>
<blockquote><p>Form the matrix of precession&ndash;nutation for a given date (including
frame bias), IAU 2006 precession and IAU 2000A nutation models.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2 double       TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rnpb        double[3][3] bias-precession-nutation matrix (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix operates in the sense <code>V(date) = rnpb * V(GCRS)</code>, where
the <code>p</code>-vector <code>V(date)</code> is with respect to the true
equatorial triad of date <var>date1</var><code> + </code><var>date2</var> and the
<code>p</code>-vector <code>V(GCRS)</code> is with respect to the Geocentric
Celestial Reference System (IAU, 2000).
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPfw06</code><dd>Bias-precession F-W angles, IAU 2006.

          <br><dt><code>iauNut06a</code><dd>Nutation, IAU 2006/2000A.

          <br><dt><code>iauFw2m</code><dd>F-W angles to <code>r</code>-matrix. 
</dl>

        <p>Reference:

          <ul>
<li>Capitaine, N. &amp; Wallace, P.T., 2006, Astron.Astrophys. 450, 855. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPnm80</b> (<var>double date1, double date2, double rmatpn</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPnm80-70"></a></var><br>
<blockquote><p>Form the matrix of precession/nutation for a given date, IAU 1976
precession model, IAU 1980 nutation model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2    double         TDB date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          rmatpn         double[3][3]   combined precession/nutation matrix
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TDB date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TDB) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                 date1          date2
               
               450123.7           0.0       (JD method)
               451545.0       -1421.3       (J2000 method)
               400000.5       50123.2       (MJD method)
               450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The matrix operates in the sense <code>V(date) = rmatpn * V(J2000)</code>,
where the <code>p</code>-vector V(date) is with respect to the true equatorial
triad of date <var>date1</var><code> + </code><var>date2</var> and the <code>p</code>-vector
<code>V(J2000)</code> is with respect to the mean equatorial triad of epoch
J2000.0.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPmat76</code><dd>Precession matrix, IAU 1976.

          <br><dt><code>iauNutm80</code><dd>Nutation matrix, IAU 1980.

          <br><dt><code>iauRxr</code><dd>Product of two <code>r</code>-matrices. 
</dl>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 3.3 (p145). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPom00</b> (<var>double xp, double yp, double sp, double rpom</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauPom00-71"></a></var><br>
<blockquote><p>Form the matrix of polar motion for a given date, IAU 2000.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          xp,yp    double    coordinates of the pole (radians, Note 1)
          sp       double    the TIO locator s' (radians, Note 2)
</pre>
        <p>Returned:

     <pre class="example">          rpom     double[3][3]   polar-motion matrix (Note 3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The arguments <var>xp</var> and <var>yp</var> are the coordinates (in radians) of
the Celestial Intermediate Pole with respect to the International
Terrestrial Reference System (see IERS Conventions 2003), measured along
the meridians to 0 and 90 deg west respectively.

          <li>The argument <var>sp</var> is the TIO locator s', in radians, which positions
the Terrestrial Intermediate Origin on the equator.  It is obtained from
polar motion observations by numerical integration, and so is in essence
unpredictable.  However, it is dominated by a secular drift of about 47
microarcseconds per century, and so can be taken into account by using
s' = -47*t, where t is centuries since J2000.0.  The function
<code>iauSp00</code> implements this approximation.

          <li>The matrix operates in the sense <code>V(TRS) = rpom * V(CIP)</code>, meaning
that it is the final rotation when computing the pointing direction to a
celestial source.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauIr</code><dd>Initialize <code>r</code>-matrix to identity.

          <br><dt><code>iauRz</code><dd>Rotate around Z-axis.

          <br><dt><code>iauRy</code><dd>Rotate around Y-axis.

          <br><dt><code>iauRx</code><dd>Rotate around X-axis. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPr00</b> (<var>double date1, double date2, double * dpsipr, double * depspr</var>)<var><a name="index-iauPr00-72"></a></var><br>
<blockquote><p>Precession&ndash;rate part of the IAU 2000 precession&ndash;nutation models (part
of MHB2000).

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2    double  TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          dpsipr,depspr  double  precession corrections (Notes 2,3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The precession adjustments are expressed as &ldquo;nutation components&rdquo;,
corrections in longitude and obliquity with respect to the J2000.0
equinox and ecliptic.

          <li>Although the precession adjustments are stated to be with respect to
Lieske et al. (1977), the MHB2000 model does not specify which set of
Euler angles are to be used and how the adjustments are to be applied. 
The most literal and straightforward procedure is to adopt the
4-rotation epsilon_0, psi_A, omega_A, xi_A option, and to add dpsipr to
psi_A and depspr to both omega_A and eps_A.

          <li>This is an implementation of one aspect of the IAU 2000A nutation model,
formally adopted by the IAU General Assembly in 2000, namely MHB2000
(Mathews et al. 2002).
             </ol>

        <p>References:

          <ul>
<li>Lieske, J.H., Lederle, T., Fricke, W. &amp; Morando, B., &ldquo;Expressions for
the precession quantities based upon the IAU (1976) System of
Astronomical Constants&rdquo;, Astron.Astrophys., 58, 1-16 (1977).

          <li>Mathews, P.M., Herring, T.A., Buffet, B.A., &ldquo;Modeling of nutation and
precession New nutation series for nonrigid Earth and insights into the
Earth's interior&rdquo;, J.Geophys.Res., 107, B4, 2002.  The MHB2000 code
itself was obtained on 9th September 2002 from:

          <div align="center"><a href="ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A">ftp://maia.usno.navy.mil/conv2000/chapter5/IAU2000A</a></div>

          <li>Wallace, P.T., &ldquo;Software for Implementing the IAU 2000 Resolutions&rdquo;,
in IERS Workshop 5.1 (2002). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPrec76</b> (<var>double ep01, double ep02, double ep11, double ep12, double * zeta, double * z, double * theta</var>)<var><a name="index-iauPrec76-73"></a></var><br>
<blockquote><p>IAU 1976 precession model.  This function forms the three Euler angles
which implement general precession between two epochs, using the IAU
1976 model (as for the FK5 catalog).

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          ep01,ep02   double    TDB starting epoch (Note 1)
          ep11,ep12   double    TDB ending epoch (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          zeta        double    1st rotation: radians cw around z
          z           double    3rd rotation: radians cw around z
          theta       double    2nd rotation: radians ccw around y
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The epochs <var>ep01</var><code> + </code><var>ep02</var> and <var>ep11</var><code> +
</code><var>ep12</var> are Julian Dates, apportioned in any convenient way between
the arguments <var>epn1</var> and <var>epn2</var>.  For example, <code>JD(TDB) =
2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                  epn1          epn2
               
               450123.7           0.0       (JD method)
               451545.0       -1421.3       (J2000 method)
               400000.5       50123.2       (MJD method)
               450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum optimum resolution.  The MJD
method and the date &amp; time methods are both good compromises between
resolution and convenience.  The two epochs may be expressed using
different methods, but at the risk of losing some resolution.

          <li>The accumulated precession angles <var>zeta</var>, <var>z</var>, <var>theta</var> are
expressed through canonical polynomials which are valid only for a
limited time span.  In addition, the IAU 1976 precession rate is known
to be imperfect.  The absolute accuracy of the present formulation is
better than 0.1 arcsec from 1960AD to 2040AD, better than 1 arcsec from
1640AD to 2360AD, and remains below 3 arcsec for the whole of the period
500BC to 3000AD.  The errors exceed 10 arcsec outside the range 1200BC
to 3900AD, exceed 100 arcsec outside 4200BC to 5600AD and exceed 1000
arcsec outside 6800BC to 8200AD.

          <li>The three angles are returned in the conventional order, which is not
the same as the order of the corresponding Euler rotations.  The
precession matrix is:

          <pre class="example">               R_3(-z) * R_2(+theta) * R_3(-zeta)
</pre>
          </ol>

        <p>Reference:

          <ul>
<li>Lieske, J.H., 1979, Astron.Astrophys. 73, 282, equations (6) &amp; (7),
p283. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauS00</b> (<var>double date1, double date2, double x, double y</var>)<var><a name="index-iauS00-74"></a></var><br>
<blockquote><p>The CIO locator s, positioning the Celestial Intermediate Origin
on the equator of the Celestial Intermediate Pole, given the CIP's
X, Y coordinates.  Compatible with IAU 2000A
precession&ndash;nutation.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2   double    TT as a 2-part Julian Date (Note 1)
          x,y           double    CIP coordinates (Note 3)
</pre>
        <p>Returned (function value):

     <pre class="example">                        double    the CIO locator s in radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The CIO locator s is the difference between the right ascensions
of the same point in two systems: the two systems are the GCRS and the
CIP, CIO, and the point is the ascending node of the CIP equator.  The
quantity s remains below 0.1 arcsecond throughout
1900-2100.

          <li>The series used to compute s is in fact for s + X Y/2,
where X and Y are the x and y components of
the CIP unit vector; this series is more compact than a direct series
for s would be.  This function requires X, Y to be
supplied by the caller, who is responsible for providing values that are
consistent with the supplied date.

          <li>The model is consistent with the IAU 2000A precession&ndash;nutation.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauFal03</code><dd>Mean anomaly of the Moon.

          <br><dt><code>iauFalp03</code><dd>Mean anomaly of the Sun.

          <br><dt><code>iauFaf03</code><dd>Mean argument of the latitude of the Moon.

          <br><dt><code>iauFad03</code><dd>Mean elongation of the Moon from the Sun.

          <br><dt><code>iauFaom03</code><dd>Mean longitude of the Moon's ascending node.

          <br><dt><code>iauFave03</code><dd>Mean longitude of Venus.

          <br><dt><code>iauFae03</code><dd>Mean longitude of Earth.

          <br><dt><code>iauFapa03</code><dd>General accumulated precession in longitude. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., &ldquo;Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession&ndash;nutation model&rdquo;,
Astron.Astrophys. 400, 1145-1154 (2003).

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed &ldquo;celestial
intermediate origin&rdquo; (CIO) by IAU 2006 Resolution 2. 
</blockquote>

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauS00a</b> (<var>double date1, double date2</var>)<var><a name="index-iauS00a-75"></a></var><br>
<blockquote><p>The CIO locator s, positioning the Celestial Intermediate Origin
on the equator of the Celestial Intermediate Pole, using the IAU 2000A
precession&ndash;nutation model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double    TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                       double    the CIO locator s in radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The CIO locator s is the difference between the right ascensions
of the same point in two systems.  The two systems are the GCRS and the
CIP, CIO, and the point is the ascending node of the CIP equator.  The
CIO locator s remains a small fraction of 1 arcsecond
throughout 1900-2100.

          <li>The series used to compute s is in fact for s + X Y/2,
where X and Y are the x and y components of
the CIP unit vector; this series is more compact than a direct series
for s would be.  The present function uses the full IAU 2000A
nutation model when predicting the CIP position.  Faster results, with
no significant loss of accuracy, can be obtained via the function
<code>iauS00b</code>, which uses instead the IAU 2000B truncated model.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPnm00a</code><dd>Classical NPB matrix, IAU 2000A.

          <br><dt><code>iauBnp2xy</code><dd>Extract CIP X, Y from the BPN matrix.

          <br><dt><code>iauS00</code><dd>The CIO locator s, given X, Y, IAU 2000A. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., &ldquo;Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession&ndash;nutation model&rdquo;,
Astron.Astrophys. 400, 1145-1154 (2003).

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed &ldquo;celestial
intermediate origin&rdquo; (CIO) by IAU 2006 Resolution 2. 
</blockquote>

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauS00b</b> (<var>double date1, double date2</var>)<var><a name="index-iauS00b-76"></a></var><br>
<blockquote><p>The CIO locator s, positioning the Celestial Intermediate Origin
on the equator of the Celestial Intermediate Pole, using the IAU 2000B
precession&ndash;nutation model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double    TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                       double    the CIO locator s in radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The CIO locator s is the difference between the right ascensions
of the same point in two systems.  The two systems are the GCRS and the
CIP, CIO, and the point is the ascending node of the CIP equator.  The
CIO locator s remains a small fraction of 1 arcsecond
throughout 1900-2100.

          <li>The series used to compute s is in fact for s + X Y/2,
where X and Y are the x and y components of
the CIP unit vector; this series is more compact than a direct series
for s would be.  The present function uses the IAU 2000B
truncated nutation model when predicting the CIP position.  The function
iauS00a uses instead the full IAU 2000A model, but with no significant
increase in accuracy and at some cost in speed.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPnm00b</code><dd>Classical NPB matrix, IAU 2000B.

          <br><dt><code>iauBnp2xy</code><dd>Extract CIP X, Y from the BPN matrix.

          <br><dt><code>iauS00</code><dd>The CIO locator s, given X, Y, IAU 2000A. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., &ldquo;Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession&ndash;nutation model&rdquo;,
Astron.Astrophys. 400, 1145-1154 (2003).

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed &ldquo;celestial
intermediate origin&rdquo; (CIO) by IAU 2006 Resolution 2. 
</blockquote>

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauS06</b> (<var>double date1, double date2, double x, double y</var>)<var><a name="index-iauS06-77"></a></var><br>
<blockquote><p>The CIO locator s, positioning the Celestial Intermediate Origin
on the equator of the Celestial Intermediate Pole, given the CIP's
X, Y coordinates.  Compatible with IAU 2006/2000A
precession&ndash;nutation.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2   double    TT as a 2-part Julian Date (Note 1)
          x,y           double    CIP coordinates (Note 3)
</pre>
        <p>Returned (function value):

     <pre class="example">                        double    the CIO locator s in radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The CIO locator s is the difference between the right ascensions
of the same point in two systems: the two systems are the GCRS and the
CIP, CIO, and the point is the ascending node of the CIP equator.  The
quantity s remains below 0.1 arcsecond throughout
1900-2100.

          <li>The series used to compute s is in fact for s + X Y/2,
where X and Y are the x and y components of
the CIP unit vector; this series is more compact than a direct series
for s would be.  This function requires X, Y to be
supplied by the caller, who is responsible for providing values that are
consistent with the supplied date.

          <li>The model is consistent with the &ldquo;P03&rdquo; precession (Capitaine et
al. 2003), adopted by IAU 2006 Resolution 1, 2006, and the IAU 2000A
nutation (with P03 adjustments).
             </ol>

        <p>Called:

          <dl>
<dt><code>iauFal03</code><dd>Mean anomaly of the Moon.

          <br><dt><code>iauFalp03</code><dd>Mean anomaly of the Sun.

          <br><dt><code>iauFaf03</code><dd>Mean argument of the latitude of the Moon.

          <br><dt><code>iauFad03</code><dd>Mean elongation of the Moon from the Sun.

          <br><dt><code>iauFaom03</code><dd>Mean longitude of the Moon's ascending node.

          <br><dt><code>iauFave03</code><dd>Mean longitude of Venus.

          <br><dt><code>iauFae03</code><dd>Mean longitude of Earth.

          <br><dt><code>iauFapa03</code><dd>General accumulated precession in longitude. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Wallace, P.T. &amp; Chapront, J., 2003, Astron. 
Astrophys. 432, 355.

          <li>McCarthy, D.D., Petit, G. (eds.) 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauS06a</b> (<var>double date1, double date2</var>)<var><a name="index-iauS06a-78"></a></var><br>
<blockquote><p>The CIO locator s, positioning the Celestial Intermediate Origin
on the equator of the Celestial Intermediate Pole, using the IAU 2006
precession and IAU 2000A nutation models.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double    TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                       double    the CIO locator s in radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The CIO locator s is the difference between the right ascensions
of the same point in two systems.  The two systems are the GCRS and the
CIP, CIO, and the point is the ascending node of the CIP equator.  The
CIO locator s remains a small fraction of 1 arcsecond
throughout 1900-2100.

          <li>The series used to compute s is in fact for s + X Y/2,
where X and Y are the x and y components of
the CIP unit vector; this series is more compact than a direct series
for s would be.  The present function uses the full IAU 2000A
nutation model when predicting the CIP position.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPnm06a</code><dd>Classical NPB matrix, IAU 2006/2000A.

          <br><dt><code>iauBpn2xy</code><dd>Extract CIP X,Y coordinates from NPB matrix.

          <br><dt><code>iauS06</code><dd>The CIO locator s, given X,Y, IAU 2006. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Chapront, J., Lambert, S. and Wallace, P., &ldquo;Expressions
for the Celestial Intermediate Pole and Celestial Ephemeris Origin
consistent with the IAU 2000A precession&ndash;nutation model&rdquo;,
Astron.Astrophys. 400, 1145-1154 (2003).

          <blockquote>
n.b. The celestial ephemeris origin (CEO) was renamed &ldquo;celestial
intermediate origin&rdquo; (CIO) by IAU 2006 Resolution 2. 
</blockquote>

          <li>Capitaine, N. &amp; Wallace, P.T., 2006, Astron.Astrophys. 450, 855

          <li>McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG.

          <li>Wallace, P.T. &amp; Capitaine, N., 2006, Astron.Astrophys. 459, 981. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauSp00</b> (<var>double date1, double date2</var>)<var><a name="index-iauSp00-79"></a></var><br>
<blockquote><p>The TIO locator s', positioning the Terrestrial Intermediate
Origin on the equator of the Celestial Intermediate Pole.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2  double    TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                       double    the TIO locator s' in radians (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The TIO locator s' is obtained from polar motion observations by
numerical integration, and so is in essence unpredictable.  However, it
is dominated by a secular drift of about 47 microarcseconds per
century, which is the approximation evaluated by the present function.
             </ol>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauXy06</b> (<var>double date1, double date2, double * x, double * y</var>)<var><a name="index-iauXy06-80"></a></var><br>
<blockquote><p>X, Y coordinates of celestial intermediate pole from
series based on IAU 2006 precession and IAU 2000A nutation.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2  double     TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          x,y          double     CIP X,Y coordinates (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The X, Y coordinates are those of the unit vector towards
the celestial intermediate pole.  They represent the combined effects of
frame bias, precession and nutation.

          <li>The fundamental arguments used are as adopted in IERS Conventions (2003)
and are from Simon et al. (1994) and Souchay et al. (1999).

          <li>This is an alternative to the angles&ndash;based method, via the <acronym>SOFA</acronym>
function <code>iauFw2xy</code> and as used in <code>iauXys06a</code> for example. 
The two methods agree at the 1 microarcsecond level (at present),
a negligible amount compared with the intrinsic accuracy of the models. 
However, it would be unwise to mix the two methods (angles&ndash;based and
series&ndash;based) in a single application.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauFal03</code><dd>Mean anomaly of the Moon.

          <br><dt><code>iauFalp03</code><dd>Mean anomaly of the Sun.

          <br><dt><code>iauFaf03</code><dd>Mean argument of the latitude of the Moon.

          <br><dt><code>iauFad03</code><dd>Mean elongation of the Moon from the Sun.

          <br><dt><code>iauFaom03</code><dd>Mean longitude of the Moon's ascending node.

          <br><dt><code>iauFame03</code><dd>Mean longitude of Mercury.

          <br><dt><code>iauFave03</code><dd>Mean longitude of Venus.

          <br><dt><code>iauFae03</code><dd>Mean longitude of Earth.

          <br><dt><code>iauFama03</code><dd>Mean longitude of Mars.

          <br><dt><code>iauFaju03</code><dd>Mean longitude of Jupiter.

          <br><dt><code>iauFasa03</code><dd>Mean longitude of Saturn.

          <br><dt><code>iauFaur03</code><dd>Mean longitude of Uranus.

          <br><dt><code>iauFane03</code><dd>Mean longitude of Neptune.

          <br><dt><code>iauFapa03</code><dd>General accumulated precession in longitude. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Wallace, P.T. &amp; Chapront, J., 2003, Astron.Astrophys.,
412, 567.

          <li>Capitaine, N. &amp; Wallace, P.T., 2006, Astron.Astrophys. 450, 855

          <li>McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG.

          <li>Simon, J.L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G. &amp; Laskar, J., Astron.Astrophys., 1994, 282, 663

          <li>Souchay, J., Loysel, B., Kinoshita, H., Folgueira, M., 1999,
Astron.Astrophys.Supp.Ser. 135, 111

          <li>Wallace, P.T. &amp; Capitaine, N., 2006, Astron.Astrophys. 459, 981. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauXys00a</b> (<var>double date1, double date2, double * x, double * y, double * s</var>)<var><a name="index-iauXys00a-81"></a></var><br>
<blockquote><p>For a given TT date, compute the X, Y coordinates of the
Celestial Intermediate Pole and the CIO locator s, using the IAU
2000A precession&ndash;nutation model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double   TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          x,y          double   Celestial Intermediate Pole (Note 2)
          s            double   the CIO locator s (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The Celestial Intermediate Pole coordinates are the x, y
components of the unit vector in the Geocentric Celestial Reference
System.

          <li>The CIO locator s (in radians) positions the Celestial
Intermediate Origin on the equator of the CIP.

          <li>A faster, but slightly less accurate result (about 1 mas for
X, Y), can be obtained by using instead the
<code>iauXys00b</code> function.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPnm00a</code><dd>Classical NPB matrix, IAU 2000A.

          <br><dt><code>iauBpn2xy</code><dd>Extract CIP X,Y coordinates from NPB matrix.

          <br><dt><code>iauS00</code><dd>The CIO locator s, given X,Y, IAU 2000A. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauXys00b</b> (<var>double date1, double date2, double * x, double * y, double * s</var>)<var><a name="index-iauXys00b-82"></a></var><br>
<blockquote><p>For a given TT date, compute the X, Y coordinates of the
Celestial Intermediate Pole and the CIO locator s, using the IAU
2000B precession&ndash;nutation model.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double   TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          x,y          double   Celestial Intermediate Pole (Note 2)
          s            double   the CIO locator s (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The Celestial Intermediate Pole coordinates are the X, Y
components of the unit vector in the Geocentric Celestial Reference
System.

          <li>The CIO locator s (in radians) positions the Celestial
Intermediate Origin on the equator of the CIP.

          <li>The present function is faster, but slightly less accurate (about
1 mas in X, Y), than the <code>iauXys00a</code> function.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPnm00b</code><dd>Classical NPB matrix, IAU 2000B.

          <br><dt><code>iauBpn2xy</code><dd>Extract CIP X,Y coordinates from NPB matrix.

          <br><dt><code>iauS00</code><dd>The CIO locator s, given X,Y, IAU 2000A. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauXys06a</b> (<var>double date1, double date2, double * x, double * y, double * s</var>)<var><a name="index-iauXys06a-83"></a></var><br>
<blockquote><p>For a given TT date, compute the X,Y coordinates of the Celestial
Intermediate Pole and the CIO locator s, using the IAU 2006
precession and IAU 2000A nutation models.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double  TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          x,y          double  Celestial Intermediate Pole (Note 2)
          s            double  the CIO locator s (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and

          <li>The Celestial Intermediate Pole coordinates are the <var>x</var>, <var>y</var>
components of the unit vector in the Geocentric Celestial Reference
System.

          <li>The CIO locator s (in radians) positions the Celestial Intermediate
Origin on the equator of the CIP.

          <li>Series&ndash;based solutions for generating X and Y are also
available: see Capitaine &amp; Wallace (2006) and <code>iauXy06</code>.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPnm06a</code><dd>Classical NPB matrix, IAU 2006/2000A.

          <br><dt><code>iauBpn2xy</code><dd>Extract CIP X, Y coordinates from NPB matrix.

          <br><dt><code>iauS06</code><dd>The CIO locator s, given X, Y, IAU 2006. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N. &amp; Wallace, P.T., 2006, Astron.Astrophys. 450, 855

          <li>Wallace, P.T. &amp; Capitaine, N., 2006, Astron.Astrophys. 459, 981. 
</ul>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-RotationAndTime"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-SpaceMotion">api SpaceMotion</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-PrecNutPolar">api PrecNutPolar</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-astronomy">api astronomy</a>

</div>

<h4 class="subsection">5.1.5 Rotation and time</h4>

<div class="defun">
&mdash; Function: double <b>iauEe00</b> (<var>double date1, double date2, double epsa, double dpsi</var>)<var><a name="index-iauEe00-84"></a></var><br>
<blockquote><p>The equation of the equinoxes, compatible with IAU 2000 resolutions,
given the nutation in longitude and the mean obliquity.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2  double    TT as a 2-part Julian Date (Note 1)
          epsa         double    mean obliquity (Note 2)
          dpsi         double    nutation in longitude (Note 3)
</pre>
        <p>Returned (function value):

     <pre class="example">                       double    equation of the equinoxes (Note 4)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The obliquity, in radians, is mean of date.

          <li>The result, which is in radians, operates in the following sense:

          <pre class="example">               Greenwich apparent ST = GMST + equation of the equinoxes
</pre>
          <li>The result is compatible with the IAU 2000 resolutions.  For further
details, see IERS Conventions 2003 and Capitaine et al.  (2002).
             </ol>

        <p>Called:

          <dl>
<dt><code>iauEect00</code><dd>Equation of the equinoxes complementary terms. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Wallace, P.T. and McCarthy, D.D., &ldquo;Expressions to
implement the IAU 2000 definition of UT1&rdquo;, Astronomy &amp; Astrophysics,
406, 1135-1149 (2003)

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauEe00a</b> (<var>double date1, double date2</var>)<var><a name="index-iauEe00a-85"></a></var><br>
<blockquote><p>Equation of the equinoxes, compatible with IAU 2000 resolutions.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double    TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                       double    equation of the equinoxes (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The result, which is in radians, operates in the following sense:

          <pre class="example">               Greenwich apparent ST = GMST + equation of the equinoxes
</pre>
          <li>The result is compatible with the IAU 2000 resolutions.  For further
details, see IERS Conventions 2003 and Capitaine et al.  (2002).
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPr00</code><dd>IAU 2000 precession adjustments.

          <br><dt><code>iauObl80</code><dd>Mean obliquity, IAU 1980.

          <br><dt><code>iauNut00a</code><dd>Nutation, IAU 2000A.

          <br><dt><code>iauEe00</code><dd>Equation of the equinoxes, IAU 2000. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Wallace, P.T. and McCarthy, D.D., &ldquo;Expressions to
implement the IAU 2000 definition of UT1&rdquo;, Astronomy &amp; Astrophysics,
406, 1135-1149 (2003).

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauEe00b</b> (<var>double date1, double date2</var>)<var><a name="index-iauEe00b-86"></a></var><br>
<blockquote><p>Equation of the equinoxes, compatible with IAU 2000 resolutions but
using the truncated nutation model IAU 2000B.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double    TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                       double    equation of the equinoxes (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The result, which is in radians, operates in the following sense:

          <pre class="example">               Greenwich apparent ST = GMST + equation of the equinoxes
</pre>
          <li>The result is compatible with the IAU 2000 resolutions except that
accuracy has been compromised for the sake of speed.  For further
details, see McCarthy &amp; Luzum (2001), IERS Conventions 2003 and
Capitaine et al. (2003).
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPr00</code><dd>IAU 2000 precession adjustments.

          <br><dt><code>iauObl80</code><dd>Mean obliquity, IAU 1980.

          <br><dt><code>iauNut00b</code><dd>Nutation, IAU 2000B.

          <br><dt><code>iauEe00</code><dd>Equation of the equinoxes, IAU 2000. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Wallace, P.T. and McCarthy, D.D., &ldquo;Expressions to
implement the IAU 2000 definition of UT1&rdquo;, Astronomy &amp; Astrophysics,
406, 1135-1149 (2003).

          <li>McCarthy, D.D. &amp; Luzum, B.J., &ldquo;An abridged model of the
precession&ndash;nutation of the celestial pole&rdquo;, Celestial Mechanics &amp;
Dynamical Astronomy, 85, 37-49 (2003).

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauEe06a</b> (<var>double date1, double date2</var>)<var><a name="index-iauEe06a-87"></a></var><br>
<blockquote><p>Equation of the equinoxes, compatible with IAU 2000 resolutions and IAU
2006/2000A precession&ndash;nutation.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          date1,date2  double    TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                       double    equation of the equinoxes (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The result, which is in radians, operates in the following sense:

          <pre class="example">               Greenwich apparent ST = GMST + equation of the equinoxes
</pre>
          </ol>

        <p>Called:

          <dl>
<dt><code>iauAnpm</code><dd>Normalize angle into range +/- pi.

          <br><dt><code>iauGst06a</code><dd>Greenwich apparent sidereal time, IAU 2006/2000A.

          <br><dt><code>iauGmst06</code><dd>Greenwich mean sidereal time, IAU 2006. 
</dl>

        <p>Reference:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), 2004, IERS Conventions (2003), IERS
Technical Note No. 32, BKG
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauEect00</b> (<var>double date1, double date2</var>)<var><a name="index-iauEect00-88"></a></var><br>
<blockquote><p>Equation of the equinoxes complementary terms, consistent with IAU 2000
resolutions.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2  double   TT as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                       double   complementary terms (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The &ldquo;complementary terms&rdquo; are part of the equation of the equinoxes
(EE), classically the difference between apparent and mean Sidereal
Time:

          <pre class="example">               GAST = GMST + EE
</pre>
          <p class="noindent">with:

          <pre class="example">               EE = dpsi * cos(eps)
</pre>
          <p class="noindent">where <code>dpsi</code> is the nutation in longitude and eps is the obliquity
of date.  However, if the rotation of the Earth were constant in an
inertial frame the classical formulation would lead to apparent
irregularities in the UT1 timescale traceable to side&ndash;effects of
precession&ndash;nutation.  In order to eliminate these effects from UT1,
&ldquo;complementary terms&rdquo; were introduced in 1994 (IAU, 1994) and took
effect from 1997 (Capitaine and Gontier, 1993):

          <pre class="example">               GAST = GMST + CT + EE
</pre>
          <p>By convention, the complementary terms are included as part of the
equation of the equinoxes rather than as part of the mean Sidereal Time. 
This slightly compromises the &ldquo;geometrical&rdquo; interpretation of mean
sidereal time but is otherwise inconsequential.

          <p>The present function computes <code>CT</code> in the above expression,
compatible with IAU 2000 resolutions (Capitaine et al., 2002, and IERS
Conventions 2003).
             </ol>

        <p>Called:

          <dl>
<dt><code>iauFal03</code><dd>Mean anomaly of the Moon.

          <br><dt><code>iauFalp03</code><dd>Mean anomaly of the Sun.

          <br><dt><code>iauFaf03</code><dd>Mean argument of the latitude of the Moon.

          <br><dt><code>iauFad03</code><dd>Mean elongation of the Moon from the Sun.

          <br><dt><code>iauFaom03</code><dd>Mean longitude of the Moon's ascending node.

          <br><dt><code>iauFave03</code><dd>Mean longitude of Venus.

          <br><dt><code>iauFae03</code><dd>Mean longitude of Earth.

          <br><dt><code>iauFapa03</code><dd>General accumulated precession in longitude. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N. &amp; Gontier, A.-M., Astron. Astrophys., 275, 645-650 (1993).

          <li>Capitaine, N., Wallace, P.T. and McCarthy, D.D., &ldquo;Expressions to
implement the IAU 2000 definition of UT1&rdquo;, Astronomy &amp; Astrophysics,
406, 1135-1149 (2003).

          <li>IAU Resolution C7, Recommendation 3 (1994).

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauEqeq94</b> (<var>double date1, double date2</var>)<var><a name="index-iauEqeq94-89"></a></var><br>
<blockquote><p>Equation of the equinoxes, IAU 1994 model.

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          date1,date2   double     TDB date (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">                        double     equation of the equinoxes (Note 2)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The date <var>date1</var> <var>date2</var> is a Julian Date, apportioned
in any convenient way between the two arguments.  For example,
<code>JD(TT) = 2450123.7</code> could be expressed in any of these ways, among
others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The result, which is in radians, operates in the following sense:

          <pre class="example">               Greenwich apparent ST = GMST + equation of the equinoxes
</pre>
          </ol>

        <p>Called:

          <dl>
<dt><code>iauNut80</code><dd>Nutation, IAU 1980.

          <br><dt><code>iauObl80</code><dd>Mean obliquity, IAU 1980. 
</dl>

        <p>References:

          <ul>
<li>IAU Resolution C7, Recommendation 3 (1994).

          <li>Capitaine, N. &amp; Gontier, A.-M., 1993, Astron. Astrophys., 275, 645-650. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauEra00</b> (<var>double dj1, double dj2</var>)<var><a name="index-iauEra00-90"></a></var><br>
<blockquote><p>Earth rotation angle (IAU 2000 model).

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          dj1,dj2   double    UT1 as a 2-part Julian Date (see note)
</pre>
        <p>Returned (function value):

     <pre class="example">          double    Earth rotation angle (radians), range 0-2pi
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The UT1 date <var>dj1</var><code> + </code><var>dj2</var> is a Julian Date, apportioned
in any convenient way between the arguments <var>dj1</var> and <var>dj2</var>. 
For example, <code>JD(UT1) = 2450123.7</code> could be expressed in any of
these ways, among others:

          <pre class="example">                   dj1            dj2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  The date &amp; time method is best matched to the algorithm
used: maximum precision is delivered when the <var>dj1</var> argument is for
0hrs UT1 on the day in question and the <var>dj2</var> argument lies in the
range 0 to 1, or vice versa.

          <li>The algorithm is adapted from Expression 22 of Capitaine et al.  2000. 
The time argument has been expressed in days directly, and, to retain
precision, integer contributions have been eliminated.  The same
formulation is given in IERS Conventions (2003), Chap. 5, Eq. 14.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi. 
</dl>

        <p>References:

          <ul>
<li>Capitaine N., Guinot B. and McCarthy D.D, 2000, Astron.  Astrophys.,
355, 398-405.

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauGmst00</b> (<var>double uta, double utb, double tta, double ttb</var>)<var><a name="index-iauGmst00-91"></a></var><br>
<blockquote><p>Greenwich mean sidereal time (model consistent with IAU 2000
resolutions).

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
          tta,ttb    double    TT as a 2-part Julian Date (Notes 1,2)
</pre>
        <p>Returned (function value):

     <pre class="example">                     double    Greenwich mean sidereal time (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The UT1 and TT dates <var>uta</var><code> + </code><var>utb</var> and <var>tta</var><code> +
</code><var>ttb</var> respectively, are both Julian Dates, apportioned in any
convenient way between the argument pairs.  For example, <code>JD =
2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                  Part A         Part B
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable (in the
case of UT; the TT is not at all critical in this respect).  The J2000
and MJD methods are good compromises between resolution and convenience. 
For UT, the date &amp; time method is best matched to the algorithm that is
used by the Earth Rotation Angle function, called internally: maximum
precision is delivered when the uta argument is for 0hrs UT1 on the day
in question and the utb argument lies in the range 0 to 1, or vice
versa.

          <li>Both UT1 and TT are required, UT1 to predict the Earth rotation and TT
to predict the effects of precession.  If UT1 is used for both purposes,
errors of order 100 microarcseconds result.

          <li>This GMST is compatible with the IAU 2000 resolutions and must be used
only in conjunction with other IAU 2000 compatible components such as
precession-nutation and equation of the equinoxes.

          <li>The result is returned in the range 0 to 2pi.

          <li>The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauEra00</code><dd>Earth rotation angle, IAU 2000.

          <br><dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Wallace, P.T. and McCarthy, D.D., &ldquo;Expressions to
implement the IAU 2000 definition of UT1&rdquo;, Astronomy &amp; Astrophysics,
406, 1135-1149 (2003)

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauGmst06</b> (<var>double uta, double utb, double tta, double ttb</var>)<var><a name="index-iauGmst06-92"></a></var><br>
<blockquote><p>Greenwich mean sidereal time (consistent with IAU 2006 precession).

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
          tta,ttb    double    TT as a 2-part Julian Date (Notes 1,2)
</pre>
        <p>Returned (function value):

     <pre class="example">                     double    Greenwich mean sidereal time (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The UT1 and TT dates <var>uta</var><code> + </code><var>utb</var> and <var>tta</var><code> +
</code><var>ttb</var> respectively, are both Julian Dates, apportioned in any
convenient way between the argument pairs.  For example, <code>JD =
2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                  Part A        Part B
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable (in the
case of UT; the TT is not at all critical in this respect).  The J2000
and MJD methods are good compromises between resolution and convenience. 
For UT, the date &amp; time method is best matched to the algorithm that is
used by the Earth rotation angle function, called internally: maximum
precision is delivered when the <var>uta</var> argument is for 0hrs UT1 on
the day in question and the <var>utb</var> argument lies in the range
0 to 1, or vice versa.

          <li>Both UT1 and TT are required, UT1 to predict the Earth rotation and TT
to predict the effects of precession.  If UT1 is used for both purposes,
errors of order 100 microarcseconds result.

          <li>This GMST is compatible with the IAU 2006 precession and must not be
used with other precession models.

          <li>The result is returned in the range 0 to 2pi.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauEra00</code><dd>Earth rotation angle, IAU 2000.

          <br><dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi. 
</dl>

        <p>Reference:

          <ul>
<li>Capitaine, N., Wallace, P.T. &amp; Chapront, J., 2005,
Astron.Astrophys. 432, 355. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauGmst82</b> (<var>double dj1, double dj2</var>)<var><a name="index-iauGmst82-93"></a></var><br>
<blockquote><p>Universal Time to Greenwich mean sidereal time (IAU 1982 model).

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          dj1,dj2    double    UT1 Julian Date (see note)
</pre>
        <p>Returned (function value):

     <pre class="example">                     double    Greenwich mean sidereal time (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The UT1 date <var>dj1</var><code> + </code><var>dj2</var> is a Julian Date, apportioned
in any convenient way between the arguments <var>dj1</var> and <var>dj2</var>. 
For example, <code>JD(UT1) = 2450123.7</code> could be expressed in any of
these ways, among others:

          <pre class="example">                   dj1            dj2
               
               2450123.7D0        0D0        (JD method)
                2451545D0      -1421.3D0     (J2000 method)
               2400000.5D0     50123.2D0     (MJD method)
               2450123.5D0       0.2D0       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  The date &amp; time method is best matched to the algorithm
used: maximum accuracy (or, at least, minimum noise) is delivered when
the <var>dj1</var> argument is for 0hrs UT1 on the day in question and the
<var>dj2</var> argument lies in the range 0 to 1, or vice versa.

          <li>The algorithm is based on the IAU 1982 expression.  This is always
described as giving the GMST at 0 hours UT1.  In fact, it gives the
difference between the GMST and the UT, the steady 4&ndash;minutes&ndash;per&ndash;day
drawing&ndash;ahead of ST with respect to UT.  When whole days are ignored,
the expression happens to equal the GMST at 0 hours UT1 each day.

          <li>In this function, the entire UT1 (the sum of the two arguments <var>dj1</var>
and <var>dj2</var>) is used directly as the argument for the standard
formula, the constant term of which is adjusted by 12 hours to take
account of the noon phasing of Julian Date.  The UT1 is then added, but
omitting whole days to conserve accuracy.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi. 
</dl>

        <p>References:

          <ul>
<li>Transactions of the International Astronomical Union, XVIII B, 67
(1983).

          <li>Aoki et al., Astron. Astrophys. 105, 359-361 (1982). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauGst00a</b> (<var>double uta, double utb, double tta, double ttb</var>)<var><a name="index-iauGst00a-94"></a></var><br>
<blockquote><p>Greenwich apparent sidereal time (consistent with IAU 2000 resolutions).

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
          tta,ttb    double    TT as a 2-part Julian Date (Notes 1,2)
</pre>
        <p>Returned (function value):

     <pre class="example">                     double    Greenwich apparent sidereal time (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The UT1 and TT dates <var>uta</var><code> + </code><var>utb</var> and <var>tta</var><code> +
</code><var>ttb</var> respectively, are both Julian Dates, apportioned in any
convenient way between the argument pairs.  For example, <code>JD =
2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                  Part A        Part B
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable (in the
case of UT; the TT is not at all critical in this respect).  The J2000
and MJD methods are good compromises between resolution and convenience. 
For UT, the date &amp; time method is best matched to the algorithm that is
used by the Earth Rotation Angle function, called internally: maximum
precision is delivered when the uta argument is for 0hrs UT1 on the day
in question and the <var>utb</var> argument lies in the range 0 to 1, or vice
versa.

          <li>Both UT1 and TT are required, UT1 to predict the Earth rotation and TT
to predict the effects of precession&ndash;nutation.  If UT1 is used for both
purposes, errors of order 100 microarcseconds result.

          <li>This GAST is compatible with the IAU 2000 resolutions and must be used
only in conjunction with other IAU 2000 compatible components such as
precession&ndash;nutation.

          <li>The result is returned in the range 0 to 2pi.

          <li>The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauGmst00</code><dd>Greenwich mean sidereal time, IAU 2000.

          <br><dt><code>iauEe00a</code><dd>Equation of the equinoxes, IAU 2000A.

          <br><dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Wallace, P.T. and McCarthy, D.D., &ldquo;Expressions to
implement the IAU 2000 definition of UT1&rdquo;, Astronomy &amp; Astrophysics,
406, 1135-1149 (2003)

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauGst00b</b> (<var>double uta, double utb</var>)<var><a name="index-iauGst00b-95"></a></var><br>
<blockquote><p>Greenwich apparent sidereal time (consistent with IAU 2000
resolutions but using the truncated nutation model IAU 2000B).

        <p>Status: support function.

        <p>Given:

     <pre class="example">          uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
</pre>
        <p>Returned (function value):

     <pre class="example">                     double    Greenwich apparent sidereal time (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The UT1 date <var>uta</var><code> + </code><var>utb</var> is a Julian Date, apportioned
in any convenient way between the argument pair.  For example, <code>JD
= 2450123f.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                   uta            utb
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  For UT, the date &amp; time method is best matched to the
algorithm that is used by the Earth Rotation Angle function, called
internally: maximum precision is delivered when the <var>uta</var> argument
is for 0hrs UT1 on the day in question and the <var>utb</var> argument lies
in the range 0 to 1, or vice versa.

          <li>The result is compatible with the IAU 2000 resolutions, except that
accuracy has been compromised for the sake of speed and convenience in
two respects:

               <ul>
<li>UT is used instead of TDB (or TT) to compute the precession component of
GMST and the equation of the equinoxes.  This results in errors of order
0.1 mas at present.

               <li>The IAU 2000B abridged nutation model (McCarthy &amp; Luzum, 2001) is used,
introducing errors of up to 1 mas. 
</ul>

          <li>This GAST is compatible with the IAU 2000 resolutions and must be used
only in conjunction with other IAU 2000 compatible components such as
precession-nutation.

          <li>The result is returned in the range 0 to 2pi.

          <li>The algorithm is from Capitaine et al. (2003) and IERS Conventions 2003.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauGmst00</code><dd>Greenwich mean sidereal time, IAU 2000.

          <br><dt><code>iauEe00b</code><dd>Equation of the equinoxes, IAU 2000B.

          <br><dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi. 
</dl>

        <p>References:

          <ul>
<li>Capitaine, N., Wallace, P.T. and McCarthy, D.D., &ldquo;Expressions to
implement the IAU 2000 definition of UT1&rdquo;, Astronomy &amp; Astrophysics,
406, 1135-1149 (2003)

          <li>McCarthy, D.D. &amp; Luzum, B.J., &ldquo;An abridged model of the
precession&ndash;nutation of the celestial pole&rdquo;, Celestial Mechanics &amp;
Dynamical Astronomy, 85, 37-49 (2003).

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauGst06</b> (<var>double uta, double utb, double tta, double ttb, double rnpb</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauGst06-96"></a></var><br>
<blockquote><p>Greenwich apparent sidereal time, IAU 2006, given the NPB matrix.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          uta,utb  double        UT1 as a 2-part Julian Date (Notes 1,2)
          tta,ttb  double        TT as a 2-part Julian Date (Notes 1,2)
          rnpb     double[3][3]  nutation x precession x bias matrix
</pre>
        <p>Returned (function value):

     <pre class="example">          double        Greenwich apparent sidereal time (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The UT1 and TT dates <var>uta</var><code> + </code><var>utb</var> and <var>tta</var><code> +
</code><var>ttb</var> respectively, are both Julian Dates, apportioned in any
convenient way between the argument pairs.  For example, <code>JD =
2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                  Part A        Part B
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable (in the
case of UT; the TT is not at all critical in this respect).  The J2000
and MJD methods are good compromises between resolution and convenience. 
For UT, the date &amp; time method is best matched to the algorithm that is
used by the Earth rotation angle function, called internally: maximum
precision is delivered when the <var>uta</var> argument is for 0hrs UT1 on
the day in question and the <var>utb</var> argument lies in the range 0 to 1,
or vice versa.

          <li>Both UT1 and TT are required, UT1 to predict the Earth rotation and TT
to predict the effects of precession&ndash;nutation.  If UT1 is used for both
purposes, errors of order 100 microarcseconds result.

          <li>Although the function uses the IAU 2006 series for <code>s + XY/2</code>, it
is otherwise independent of the precession&ndash;nutation model and can in
practice be used with any equinox&ndash;based NPB matrix.

          <li>The result is returned in the range 0 to 2pi.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauBpn2xy</code><dd>Extract CIP X,Y coordinates from NPB matrix.

          <br><dt><code>iauS06</code><dd>The CIO locator s, given X,Y, IAU 2006.

          <br><dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi.

          <br><dt><code>iauEra00</code><dd>Earth rotation angle, IAU 2000.

          <br><dt><code>iauEors</code><dd>Equation of the origins, given NPB matrix and <var>s</var>. 
</dl>

        <p>Reference:

          <ul>
<li>Wallace, P.T. &amp; Capitaine, N., 2006, Astron.Astrophys. 459, 981. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauGst06a</b> (<var>double uta, double utb, double tta, double ttb</var>)<var><a name="index-iauGst06a-97"></a></var><br>
<blockquote><p>Greenwich apparent sidereal time (consistent with IAU 2000 and 2006
resolutions).

        <p>Status: canonical model.

        <p>Given:

     <pre class="example">          uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
          tta,ttb    double    TT as a 2-part Julian Date (Notes 1,2)
</pre>
        <p>Returned (function value):

     <pre class="example">                     double    Greenwich apparent sidereal time (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The UT1 and TT dates <var>uta</var><code> + </code><var>utb</var> and <var>tta</var><code> +
</code><var>ttb</var> respectively, are both Julian Dates, apportioned in any
convenient way between the argument pairs.  For example, <code>JD =
2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                  Part A        Part B
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable (in the
case of UT; the TT is not at all critical in this respect).  The J2000
and MJD methods are good compromises between resolution and convenience. 
For UT, the date &amp; time method is best matched to the algorithm that is
used by the Earth rotation angle function, called internally: maximum
precision is delivered when the <var>uta</var> argument is for 0hrs UT1 on
the day in question and the <var>utb</var> argument lies in the range 0 to 1,
or vice versa.

          <li>Both UT1 and TT are required, UT1 to predict the Earth rotation and TT
to predict the effects of precession-nutation.  If UT1 is used for both
purposes, errors of order 100 microarcseconds result.

          <li>This GAST is compatible with the IAU 2000/2006 resolutions and must be
used only in conjunction with IAU 2006 precession and IAU 2000A
nutation.

          <li>The result is returned in the range 0 to 2pi.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPnm06a</code><dd>Classical NPB matrix, IAU 2006/2000A.

          <br><dt><code>iauGst06</code><dd>Greenwich apparent ST, IAU 2006, given NPB matrix. 
</dl>

        <p>Reference:

          <ul>
<li>Wallace, P.T. &amp; Capitaine, N., 2006, Astron.Astrophys. 459, 981. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauGst94</b> (<var>double uta, double utb</var>)<var><a name="index-iauGst94-98"></a></var><br>
<blockquote><p>Greenwich apparent sidereal time (consistent with IAU 1982/94
resolutions).

        <p>Status: support function.

        <p>Given:

     <pre class="example">          uta,utb    double    UT1 as a 2-part Julian Date (Notes 1,2)
</pre>
        <p>Returned (function value):

     <pre class="example">                     double    Greenwich apparent sidereal time (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The UT1 date <var>uta</var><code> + </code><var>utb</var> is a Julian Date, apportioned
in any convenient way between the argument pair.  For example, <code>JD
= 2450123.7</code> could be expressed in any of these ways, among others:

          <pre class="example">                   uta            utb
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 and MJD methods are good compromises between resolution and
convenience.  For UT, the date &amp; time method is best matched to the
algorithm that is used by the Earth Rotation Angle function, called
internally: maximum precision is delivered when the <var>uta</var> argument
is for 0hrs UT1 on the day in question and the <var>utb</var> argument lies
in the range 0 to 1, or vice versa.

          <li>The result is compatible with the IAU 1982 and 1994 resolutions, except
that accuracy has been compromised for the sake of convenience in that
UT is used instead of TDB (or TT) to compute the equation of the
equinoxes.

          <li>This GAST must be used only in conjunction with contemporaneous IAU
standards such as 1976 precession, 1980 obliquity and 1982 nutation.  It
is not compatible with the IAU 2000 resolutions.

          <li>The result is returned in the range 0 to 2pi.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauGmst82</code><dd>Greenwich mean sidereal time, IAU 1982.

          <br><dt><code>iauEqeq94</code><dd>Equation of the equinoxes, IAU 1994.

          <br><dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi. 
</dl>

        <p>References:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992).

          <li>IAU Resolution C7, Recommendation 3 (1994). 
</ul>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-SpaceMotion"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-StarCatalogs">api StarCatalogs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-RotationAndTime">api RotationAndTime</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-astronomy">api astronomy</a>

</div>

<h4 class="subsection">5.1.6 Space motion</h4>

<div class="defun">
&mdash; Function: int <b>iauPvstar</b> (<var>double pv</var>[<var>2</var>][<var>3</var>]<var>, double * ra, double * dec, double * pmr, double * pmd, double * px, double * rv</var>)<var><a name="index-iauPvstar-99"></a></var><br>
<blockquote><p>Convert star position+velocity vector to catalog coordinates.

        <p>Status: support function.

        <p>Given (Note 1):

     <pre class="example">          pv     double[2][3]   pv-vector (AU, AU/day)
</pre>
        <p>Returned (Note 2):

     <pre class="example">          ra     double         right ascension (radians)
          dec    double         declination (radians)
          pmr    double         RA proper motion (radians/year)
          pmd    double         Dec proper motion (radians/year)
          px     double         parallax (arcsec)
          rv     double         radial velocity (km/s, positive = receding)
</pre>
        <p>Returned (function value):

     <pre class="example">          int            status:
                            0 = OK
                           -1 = superluminal speed (Note 5)
                           -2 = null position vector
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The specified <var>pv</var>-vector is the coordinate direction (and its rate
of change) for the date at which the light leaving the star reached the
solar&ndash;system barycenter.

          <li>The star data returned by this function are &ldquo;observables&rdquo; for an
imaginary observer at the solar&ndash;system barycenter.  Proper motion and
radial velocity are, strictly, in terms of barycentric coordinate time,
TCB.  For most practical applications, it is permissible to neglect the
distinction between TCB and ordinary &ldquo;proper&rdquo; time on Earth (TT/TAI). 
The result will, as a rule, be limited by the intrinsic accuracy of the
proper&ndash;motion and radial&ndash;velocity data; moreover, the supplied
<var>pv</var>-vector is likely to be merely an intermediate result (for
example generated by the function iauStarpv), so that a change of time
unit will cancel out overall.

          <p>In accordance with normal star&ndash;catalog conventions, the object's right
ascension and declination are freed from the effects of secular
aberration.  The frame, which is aligned to the catalog equator and
equinox, is Lorentzian and centered on the SSB.

          <p>Summarizing, the specified <var>pv</var>-vector is for most stars almost
identical to the result of applying the standard geometrical &ldquo;space
motion&rdquo; transformation to the catalog data.  The differences, which are
the subject of the Stumpff paper cited below, are:

               <ol type=a start=1>
<li>In stars with significant radial velocity and proper motion, the
constantly changing light&ndash;time distorts the apparent proper motion. 
Note that this is a classical, not a relativistic, effect.

               <li>The transformation complies with special relativity.
               </ol>

          <li>Care is needed with units.  The star coordinates are in radians and the
proper motions in radians per Julian year, but the parallax is in
arcseconds; the radial velocity is in km/s, but the <var>pv</var>-vector
result is in AU and AU/day.

          <li>The proper motions are the rate of change of the right ascension and
declination at the catalog epoch and are in radians per Julian year. 
The RA proper motion is in terms of coordinate angle, not true angle,
and will thus be numerically larger at high declinations.

          <li>Straight&ndash;line motion at constant speed in the inertial frame is
assumed.  If the speed is greater than or equal to the speed of light,
the function aborts with an error status.

          <li>The inverse transformation is performed by the function iauStarpv.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPn</code><dd>Decompose <code>p</code>-vector into modulus and direction.

          <br><dt><code>iauPdp</code><dd>Scalar product of two <code>p</code>-vectors.

          <br><dt><code>iauSxp</code><dd>Multiply <code>p</code>-vector by scalar.

          <br><dt><code>iauPmp</code><dd><code>p</code>-vector minus <code>p</code>-vector.

          <br><dt><code>iauPm</code><dd>Modulus of <code>p</code>-vector.

          <br><dt><code>iauPpp</code><dd><code>p</code>-vector plus <code>p</code>-vector.

          <br><dt><code>iauPv2s</code><dd><code>pv</code>-vector to spherical.

          <br><dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi. 
</dl>

        <p>Reference:

          <ul>
<li>Stumpff, P., 1985, Astron.Astrophys. 144, 232-240. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauStarpv</b> (<var>double ra, double dec, double pmr, double pmd, double px, double rv, double pv</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauStarpv-100"></a></var><br>
<blockquote><p>Convert star catalog coordinates to position+velocity vector.

        <p>Status: support function.

        <p>Given (Note 1):

     <pre class="example">          ra     double        right ascension (radians)
          dec    double        declination (radians)
          pmr    double        RA proper motion (radians/year)
          pmd    double        Dec proper motion (radians/year)
          px     double        parallax (arcseconds)
          rv     double        radial velocity (km/s, positive = receding)
</pre>
        <p>Returned (Note 2):

     <pre class="example">          pv     double[2][3]  pv-vector (AU, AU/day)
</pre>
        <p>Returned (function value):

     <pre class="example">          int           status:
                            0 = no warnings
                            1 = distance overridden (Note 6)
                            2 = excessive speed (Note 7)
                            4 = solution didn't converge (Note 8)
                         else = binary logical OR of the above
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The star data accepted by this function are &ldquo;observables&rdquo; for an
imaginary observer at the solar&ndash;system barycenter.  Proper motion and
radial velocity are, strictly, in terms of barycentric coordinate time,
TCB.  For most practical applications, it is permissible to neglect the
distinction between TCB and ordinary &ldquo;proper&rdquo; time on Earth (TT/TAI). 
The result will, as a rule, be limited by the intrinsic accuracy of the
proper&ndash;motion and radial&ndash;velocity data; moreover, the <var>pv</var>-vector
is likely to be merely an intermediate result, so that a change of time
unit would cancel out overall.

          <p>In accordance with normal star&ndash;catalog conventions, the object's right
ascension and declination are freed from the effects of secular
aberration.  The frame, which is aligned to the catalog equator and
equinox, is Lorentzian and centered on the SSB.

          <li>The resulting position and velocity <var>pv</var>-vector is with respect to
the same frame and, like the catalog coordinates, is freed from the
effects of secular aberration.  Should the &ldquo;coordinate direction&rdquo;,
where the object was located at the catalog epoch, be required, it may
be obtained by calculating the magnitude of the position vector
<var>pv</var><code>[0][0-2]</code> dividing by the speed of light in AU/day to give
the light&ndash;time, and then multiplying the space velocity
<var>pv</var><code>[1][0-2]</code> by this light&ndash;time and adding the result to
<var>pv</var><code>[0][0-2]</code>.

          <p>Summarizing, the <var>pv</var>-vector returned is for most stars almost
identical to the result of applying the standard geometrical &ldquo;space
motion&rdquo; transformation.  The differences, which are the subject of the
Stumpff paper referenced below, are:

               <ul>
<li>In stars with significant radial velocity and proper motion, the
constantly changing light&ndash;time distorts the apparent proper motion. 
Note that this is a classical, not a relativistic, effect.

               <li>The transformation complies with special relativity. 
</ul>

          <li>Care is needed with units.  The star coordinates are in radians and the
proper motions in radians per Julian year, but the parallax is in
arcseconds; the radial velocity is in km/s, but the
<var>pv</var>-vector result is in AU and AU/day.

          <li>The RA proper motion is in terms of coordinate angle, not true angle. 
If the catalog uses arcseconds for both RA and Dec proper motions, the
RA proper motion will need to be divided by <code>cos(Dec)</code> before use.

          <li>Straight&ndash;line motion at constant speed, in the inertial frame, is
assumed.

          <li>An extremely small (or zero or negative) parallax is interpreted to mean
that the object is on the &ldquo;celestial sphere&rdquo;, the radius of which is
an arbitrary (large) value (see the constant <code>PXMIN</code>).  When the
distance is overridden in this way, the status, initially zero, has
1 added to it.

          <li>If the space velocity is a significant fraction of c (see the
constant <code>VMAX</code>), it is arbitrarily set to zero.  When this action
occurs, 2 is added to the status.

          <li>The relativistic adjustment involves an iterative calculation.  If the
process fails to converge within a set number (<code>IMAX</code>) of
iterations, 4 is added to the status.

          <li>The inverse transformation is performed by the function
<code>iauPvstar</code>.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauS2pv</code><dd>Spherical coordinates to <var>pv</var>-vector.

          <br><dt><code>iauPm</code><dd>Modulus of <code>p</code>-vector.

          <br><dt><code>iauZp</code><dd>Zero <code>p</code>-vector.

          <br><dt><code>iauPn</code><dd>Decompose <code>p</code>-vector into modulus and direction.

          <br><dt><code>iauPdp</code><dd>Scalar product of two <code>p</code>-vectors.

          <br><dt><code>iauSxp</code><dd>Multiply <code>p</code>-vector by scalar.

          <br><dt><code>iauPmp</code><dd><code>p</code>-vector minus <code>p</code>-vector.

          <br><dt><code>iauPpp</code><dd><code>p</code>-vector plus <code>p</code>-vector. 
</dl>

        <p>Reference:

          <ul>
<li>Stumpff, P., 1985, Astron.Astrophys. 144, 232-240. 
</ul>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-StarCatalogs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-Geodetic_002fGeocentric">api Geodetic/Geocentric</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-SpaceMotion">api SpaceMotion</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-astronomy">api astronomy</a>

</div>

<h4 class="subsection">5.1.7 Star catalogs</h4>

<div class="defun">
&mdash; Function: void <b>iauFk52h</b> (<var>double r5, double d5, double dr5, double dd5, double px5, double rv5, double * rh, double * dh, double * drh, double * ddh, double * pxh, double * rvh</var>)<var><a name="index-iauFk52h-101"></a></var><br>
<blockquote><p>Transform FK5 (J2000.0) star data into the Hipparcos system.

        <p>Status: support function.

        <p>Given (all FK5, equinox J2000.0, epoch J2000.0):

     <pre class="example">          r5      double    RA (radians)
          d5      double    Dec (radians)
          dr5     double    proper motion in RA (dRA/dt, rad/Jyear)
          dd5     double    proper motion in Dec (dDec/dt, rad/Jyear)
          px5     double    parallax (arcsec)
          rv5     double    radial velocity (km/s, positive = receding)
</pre>
        <p>Returned (all Hipparcos, epoch J2000.0):

     <pre class="example">          rh      double    RA (radians)
          dh      double    Dec (radians)
          drh     double    proper motion in RA (dRA/dt, rad/Jyear)
          ddh     double    proper motion in Dec (dDec/dt, rad/Jyear)
          pxh     double    parallax (arcsec)
          rvh     double    radial velocity (km/s, positive = receding)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>This function transforms FK5 star positions and proper motions into the
system of the Hipparcos catalog.

          <li>The proper motions in RA are <code>dRA/dt</code> rather than <code>cos(Dec) *
dRA/dt</code>, and are per year rather than per century.

          <li>The FK5 to Hipparcos transformation is modeled as a pure rotation and
spin; zonal errors in the FK5 catalog are not taken into account.

          <li>See also <code>iauH2fk5</code>, <code>iauFk5hz</code>, <code>iauHfk5z</code>.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauStarpv</code><dd>Star catalog data to space motion <code>pv</code>-vector.

          <br><dt><code>iauFk5hip</code><dd>FK5 to Hipparcos rotation and spin.

          <br><dt><code>iauRxp</code><dd>Product of <code>r</code>-matrix and <code>p</code>-vector.

          <br><dt><code>iauPxp</code><dd>Vector product of two <code>p</code>-vectors.

          <br><dt><code>iauPpp</code><dd><code>p</code>-vector plus <code>p</code>-vector.

          <br><dt><code>iauPvstar</code><dd>Space motion <code>pv</code>-vector to star catalog data. 
</dl>

        <p>Reference:

          <ul>
<li>F.Mignard &amp; M.Froeschle, Astron. Astrophys. 354, 732-739 (2000). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauFk5hip</b> (<var>double r5h</var>[<var>3</var>][<var>3</var>]<var>, double s5h</var>[<var>3</var>])<var><a name="index-iauFk5hip-102"></a></var><br>
<blockquote><p>FK5 to Hipparcos rotation and spin.

        <p>Status: support function.

        <p>Returned:

     <pre class="example">          r5h   double[3][3]  r-matrix: FK5 rotation wrt Hipparcos (Note 2)
          s5h   double[3]     r-vector: FK5 spin wrt Hipparcos (Note 3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>This function models the FK5 to Hipparcos transformation as a pure
rotation and spin; zonal errors in the FK5 catalogue are not taken into
account.

          <li>The <code>r</code>-matrix <var>r5h</var> operates in the sense:

          <pre class="example">               P_Hipparcos = r5h x P_FK5
</pre>
          <p class="noindent">where <code>P_FK5</code> is a <code>p</code>-vector in the FK5 frame, and
<code>P_Hipparcos</code> is the equivalent Hipparcos <code>p</code>-vector.

          <li>The <code>r</code>-vector <var>s5h</var> represents the time derivative of the FK5
to Hipparcos rotation.  The units are radians per year (Julian, TDB).
             </ol>

        <p>Called:

          <dl>
<dt><code>iauRv2m</code><dd><code>r</code>-vector to <code>r</code>-matrix. 
</dl>

        <p>Reference:

          <ul>
<li>F.Mignard &amp; M.Froeschle, Astron. Astrophys. 354, 732-739 (2000). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauFk5hz</b> (<var>double r5, double d5, double date1, double date2, double * rh, double * dh</var>)<var><a name="index-iauFk5hz-103"></a></var><br>
<blockquote><p>Transform an FK5 (J2000.0) star position into the system of the
Hipparcos catalogue, assuming zero Hipparcos proper motion.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          r5           double   FK5 RA (radians), equinox J2000.0, at date
          d5           double   FK5 Dec (radians), equinox J2000.0, at date
          date1,date2  double   TDB date (Notes 1,2)
</pre>
        <p>Returned:

     <pre class="example">          rh           double   Hipparcos RA (radians)
          dh           double   Hipparcos Dec (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>This function converts a star position from the FK5 system to the
Hipparcos system, in such a way that the Hipparcos proper motion is
zero.  Because such a star has, in general, a non-zero proper motion in
the FK5 system, the function requires the date at which the position in
the FK5 system was determined.

          <li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The FK5 to Hipparcos transformation is modeled as a pure rotation and
spin; zonal errors in the FK5 catalogue are not taken into account.

          <li>The position returned by this function is in the Hipparcos reference
system but at date date1+date2.

          <li>See also <code>iauFk52h</code>, <code>iauH2fk5</code>, <code>iauHfk5z</code>.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauS2c</code><dd>Spherical coordinates to unit vector.

          <br><dt><code>iauFk5hip</code><dd>FK5 to Hipparcos rotation and spin.

          <br><dt><code>iauSxp</code><dd>Multiply <code>p</code>-vector by scalar.

          <br><dt><code>iauRv2m</code><dd><code>r</code>-vector to <code>r</code>-matrix.

          <br><dt><code>iauTrxp</code><dd>Product of transpose of <code>r</code>-matrix and <code>p</code>-vector.

          <br><dt><code>iauPxp</code><dd>Vector product of two <code>p</code>-vectors.

          <br><dt><code>iauC2s</code><dd><code>p</code>-vector to spherical.

          <br><dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi. 
</dl>

        <p>Reference:

          <ul>
<li>F.Mignard &amp; M.Froeschle, 2000, Astron.Astrophys. 354, 732-739. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauH2fk5</b> (<var>double rh, double dh, double drh, double ddh, double pxh, double rvh, double * r5, double * d5, double * dr5, double * dd5, double * px5, double * rv5</var>)<var><a name="index-iauH2fk5-104"></a></var><br>
<blockquote><p>Transform Hipparcos star data into the FK5 (J2000.0) system.

        <p>Status: support function.

        <p>Given (all Hipparcos, epoch J2000.0):

     <pre class="example">          rh      double    RA (radians)
          dh      double    Dec (radians)
          drh     double    proper motion in RA (dRA/dt, rad/Jyear)
          ddh     double    proper motion in Dec (dDec/dt, rad/Jyear)
          pxh     double    parallax (arcsec)
          rvh     double    radial velocity (km/s, positive = receding)
</pre>
        <p>Returned (all FK5, equinox J2000.0, epoch J2000.0):

     <pre class="example">          r5      double    RA (radians)
          d5      double    Dec (radians)
          dr5     double    proper motion in RA (dRA/dt, rad/Jyear)
          dd5     double    proper motion in Dec (dDec/dt, rad/Jyear)
          px5     double    parallax (arcsec)
          rv5     double    radial velocity (km/s, positive = receding)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>This function transforms Hipparcos star positions and proper motions
into FK5 J2000.0.

          <li>The proper motions in RA are <code>dRA/dt</code> rather than <code>cos(Dec) *
dRA/dt</code>, and are per year rather than per century.

          <li>The FK5 to Hipparcos transformation is modeled as a pure rotation and
spin; zonal errors in the FK5 catalog are not taken into account.

          <li>See also <code>iauFk52h</code>, <code>iauFk5hz</code>, <code>iauHfk5z</code>.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauStarpv</code><dd>Star catalog data to space motion <code>pv</code>-vector.

          <br><dt><code>iauFk5hip</code><dd>FK5 to Hipparcos rotation and spin.

          <br><dt><code>iauRv2m</code><dd><code>r</code>-vector to <code>r</code>-matrix.

          <br><dt><code>iauRxp</code><dd>Product of <code>r</code>-matrix and <code>p</code>-vector.

          <br><dt><code>iauTrxp</code><dd>Product of transpose of <code>r</code>-matrix and <code>p</code>-vector.

          <br><dt><code>iauPxp</code><dd>Vector product of two <code>p</code>-vectors.

          <br><dt><code>iauPmp</code><dd><code>p</code>-vector minus <code>p</code>-vector.

          <br><dt><code>iauPvstar</code><dd>Space motion <code>pv</code>-vector to star catalog data. 
</dl>

        <p>Reference:

          <ul>
<li>F.Mignard &amp; M.Froeschle, Astron. Astrophys. 354, 732-739 (2000). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauHfk5z</b> (<var>double rh, double dh, double date1, double date2, double * r5, double * d5, double * dr5, double * dd5</var>)<var><a name="index-iauHfk5z-105"></a></var><br>
<blockquote><p>Transform a Hipparcos star position into FK5 J2000.0, assuming zero
Hipparcos proper motion.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          rh            double    Hipparcos RA (radians)
          dh            double    Hipparcos Dec (radians)
          date1,date2   double    TDB date (Note 1)
</pre>
        <p>Returned (all FK5, equinox J2000.0, date <var>date1</var><code> +
</code><var>date2</var>):

     <pre class="example">          r5            double    RA (radians)
          d5            double    Dec (radians)
          dr5           double    FK5 RA proper motion (rad/year, Note 4)
          dd5           double    Dec proper motion (rad/year, Note 4)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The TT date <var>date1</var><code> + </code><var>date2</var> is a Julian Date,
apportioned in any convenient way between the two arguments.  For
example, <code>JD(TT) = 2450123.7</code> could be expressed in any of these
ways, among others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>The proper motion in RA is <code>dRA/dt</code> rather than <code>cos(Dec) *
dRA/dt</code>.

          <li>The FK5 to Hipparcos transformation is modeled as a pure rotation and
spin; zonal errors in the FK5 catalogue are not taken into account.

          <li>It was the intention that Hipparcos should be a close approximation to
an inertial frame, so that distant objects have zero proper motion; such
objects have (in general) non-zero proper motion in FK5, and this
function returns those fictitious proper motions.

          <li>The position returned by this function is in the FK5 J2000.0 reference
system but at date <var>date1</var><code> + </code><var>date2</var>.

          <li>See also <code>iauFk52h</code>, <code>iauH2fk5</code>, <code>iauFk5zhz</code>.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauS2c</code><dd>Spherical coordinates to unit vector.

          <br><dt><code>iauFk5hip</code><dd>FK5 to Hipparcos rotation and spin.

          <br><dt><code>iauRxp</code><dd>Product of <code>r</code>-matrix and <code>p</code>-vector.

          <br><dt><code>iauSxp</code><dd>Multiply <code>p</code>-vector by scalar.

          <br><dt><code>iauRxr</code><dd>Product of two <code>r</code>-matrices.

          <br><dt><code>iauTrxp</code><dd>Product of transpose of <code>r</code>-matrix and <code>p</code>-vector.

          <br><dt><code>iauPxp</code><dd>Vector product of two <code>p</code>-vectors.

          <br><dt><code>iauPv2s</code><dd><code>pv</code>-vector to spherical.

          <br><dt><code>iauAnp</code><dd>Normalize angle into range 0 to 2pi. 
</dl>

        <p>Reference:

          <ul>
<li>F.Mignard &amp; M.Froeschle, 2000, Astron.Astrophys. 354, 732-739. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauStarpm</b> (<var>double ra1, double dec1, double pmr1, double pmd1, double px1, double rv1, double ep1a, double ep1b, double ep2a, double ep2b, double * ra2, double * dec2, double * pmr2, double * pmd2, double * px2, double * rv2</var>)<var><a name="index-iauStarpm-106"></a></var><br>
<blockquote><p>Star proper motion: update star catalog data for space motion.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          ra1    double     right ascension (radians), before
          dec1   double     declination (radians), before
          pmr1   double     RA proper motion (radians/year), before
          pmd1   double     Dec proper motion (radians/year), before
          px1    double     parallax (arcseconds), before
          rv1    double     radial velocity (km/s, +ve = receding), before
          ep1a   double     "before" epoch, part A (Note 1)
          ep1b   double     "before" epoch, part B (Note 1)
          ep2a   double     "after" epoch, part A (Note 1)
          ep2b   double     "after" epoch, part B (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          ra2    double     right ascension (radians), after
          dec2   double     declination (radians), after
          pmr2   double     RA proper motion (radians/year), after
          pmd2   double     Dec proper motion (radians/year), after
          px2    double     parallax (arcseconds), after
          rv2    double     radial velocity (km/s, +ve = receding), after
</pre>
        <p>Returned (function value):

     <pre class="example">          int        status:
                        -1 = system error (should not occur)
                         0 = no warnings or errors
                         1 = distance overridden (Note 6)
                         2 = excessive velocity (Note 7)
                         4 = solution didn't converge (Note 8)
                      else = binary logical OR of the above warnings
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The starting and ending TDB dates <var>ep1a</var><code> + </code><var>ep1b</var> and
<var>ep2a</var><code> + </code><var>ep2b</var> are Julian Dates, apportioned in any
convenient way between the two parts (A and B).  For example,
<code>JD(TDB) = 2450123.7</code> could be expressed in any of these ways,
among others:

          <pre class="example">                   epna          epnb
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <li>In accordance with normal star&ndash;catalog conventions, the object's right
ascension and declination are freed from the effects of secular
aberration.  The frame, which is aligned to the catalog equator and
equinox, is Lorentzian and centered on the SSB.

          <p>The proper motions are the rate of change of the right ascension and
declination at the catalog epoch and are in radians per TDB Julian year.

          <p>The parallax and radial velocity are in the same frame.

          <li>Care is needed with units.  The star coordinates are in radians and the
proper motions in radians per Julian year, but the parallax is in
arcseconds.

          <li>The RA proper motion is in terms of coordinate angle, not true angle. 
If the catalog uses arcseconds for both RA and Dec proper motions, the
RA proper motion will need to be divided by <code>cos(Dec)</code> before use.

          <li>Straight&ndash;line motion at constant speed, in the inertial frame, is
assumed.

          <li>An extremely small (or zero or negative) parallax is interpreted to mean
that the object is on the &ldquo;celestial sphere&rdquo;, the radius of which is
an arbitrary (large) value (see the <code>iauStarpv</code> function for the
value used).  When the distance is overridden in this way, the status,
initially zero, has 1 added to it.

          <li>If the space velocity is a significant fraction of c (see the
constant <code>VMAX</code> in the function <code>iauStarpv</code>), it is
arbitrarily set to zero.  When this action occurs, 2 is added to
the status.

          <li>The relativistic adjustment carried out in the <code>iauStarpv</code> function
involves an iterative calculation.  If the process fails to converge
within a set number of iterations, 4 is added to the status.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauStarpv</code><dd>Star catalog data to space motion <code>pv</code>-vector.

          <br><dt><code>iauPvu</code><dd>Update a <var>pv</var>-vector.

          <br><dt><code>iauPdp</code><dd>Scalar product of two <code>p</code>-vectors.

          <br><dt><code>iauPvstar</code><dd>Space motion <code>pv</code>-vector to star catalog data. 
</dl>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-Geodetic%2fGeocentric"></a>
<a name="api-Geodetic_002fGeocentric"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-Timescales">api Timescales</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-StarCatalogs">api StarCatalogs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-astronomy">api astronomy</a>

</div>

<h4 class="subsection">5.1.8 Geodetic geocentric</h4>

<div class="defun">
&mdash; Function: int <b>iauEform</b> (<var>int n, double * a, double * f</var>)<var><a name="index-iauEform-107"></a></var><br>
<blockquote><p>Earth reference ellipsoids.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          n    int         ellipsoid identifier (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          a    double      equatorial radius (meters, Note 2)
          f    double      flattening (Note 2)
</pre>
        <p>Returned (function value):

     <pre class="example">          int         status:  0 = OK
                              -1 = illegal identifier (Note 3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The identifier <var>n</var> is a number that specifies the choice of
reference ellipsoid.  The following are supported:

          <pre class="example">               n    ellipsoid
               
               1     WGS84
               2     GRS80
               3     WGS72
</pre>
          <p>The <var>n</var> value has no significance outside the <acronym>SOFA</acronym> software.  For
convenience, symbols WGS84 etc. are defined in <samp><span class="file">sofam.h</span></samp>.

          <li>The ellipsoid parameters are returned in the form of equatorial radius
in meters (a) and flattening (f).  The latter is a number around
0.00335, i.e. around 1/298.

          <li>For the case where an unsupported <var>n</var> value is supplied, zero
<var>a</var> and <var>f</var> are returned, as well as error status.
             </ol>

        <p>References:

          <ul>
<li>Department of Defense World Geodetic System 1984, National Imagery and
Mapping Agency Technical Report 8350.2, Third Edition, p3-2.

          <li>Moritz, H., Bull. Geodesique 66-2, 187 (1992).

          <li>The Department of Defense World Geodetic System 1972, World Geodetic
System Committee, May 1974.

          <li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), p220. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauGc2gd</b> (<var>int n, double xyz</var>[<var>3</var>]<var>, double * elong, double * phi, double * height</var>)<var><a name="index-iauGc2gd-108"></a></var><br>
<blockquote><p>Transform geocentric coordinates to geodetic using the specified
reference ellipsoid.

        <p>Status: canonical transformation.

        <p>Given:

     <pre class="example">          n       int        ellipsoid identifier (Note 1)
          xyz     double[3]  geocentric vector (Note 2)
</pre>
        <p>Returned:

     <pre class="example">          elong   double     longitude (radians, east +ve)
          phi     double     latitude (geodetic, radians, Note 3)
          height  double     height above ellipsoid (geodetic, Notes 2,3)
</pre>
        <p>Returned (function value):

     <pre class="example">          int         status:  0 = OK
                              -1 = illegal identifier (Note 3)
                              -2 = internal error (Note 3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The identifier <var>n</var> is a number that specifies the choice of
reference ellipsoid.  The following are supported:

          <pre class="example">               n    ellipsoid
               
               1     WGS84
               2     GRS80
               3     WGS72
</pre>
          <p>The <var>n</var> value has no significance outside the <acronym>SOFA</acronym> software.  For
convenience, symbols WGS84 etc. are defined in <samp><span class="file">sofam.h</span></samp>.

          <li>The geocentric vector (xyz, given) and height (height, returned) are in
meters.

          <li>An error status -1 means that the identifier <var>n</var> is illegal.  An
error status -2 is theoretically impossible.  In all error cases, phi
and height are both set to -1e9.

          <li>The inverse transformation is performed in the function <code>iauGd2gc</code>.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauEform</code><dd>Earth reference ellipsoids.

          <br><dt><code>iauGc2gde</code><dd>Geocentric to geodetic transformation, general. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauGc2gde</b> (<var>double a, double f, double xyz</var>[<var>3</var>]<var>, double * elong, double * phi, double * height</var>)<var><a name="index-iauGc2gde-109"></a></var><br>
<blockquote><p>Transform geocentric coordinates to geodetic for a reference ellipsoid
of specified form.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          a       double     equatorial radius (Notes 2,4)
          f       double     flattening (Note 3)
          xyz     double[3]  geocentric vector (Note 4)
</pre>
        <p>Returned:

     <pre class="example">          elong   double     longitude (radians, east +ve)
          phi     double     latitude (geodetic, radians)
          height  double     height above ellipsoid (geodetic, Note 4)
</pre>
        <p>Returned (function value):

     <pre class="example">          int        status:  0 = OK
                             -1 = illegal f
                             -2 = illegal a
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>This function is based on the GCONV2H Fortran subroutine by Toshio
Fukushima (see reference).

          <li>The equatorial radius, a, can be in any units, but meters is the
conventional choice.

          <li>The flattening, f, is (for the Earth) a value around 0.00335,
i.e. around 1/298.

          <li>The equatorial radius, a, and the geocentric vector, xyz, must be given
in the same units, and determine the units of the returned height,
height.

          <li>If an error occurs (status &lt; 0), elong, phi and height are unchanged.

          <li>The inverse transformation is performed in the function
<code>iauGd2gce</code>.

          <li>The transformation for a standard ellipsoid (such as WGS84) can more
conveniently be performed by calling iauGc2gd, which uses a numerical
code to identify the required A and F values.
             </ol>

        <p>Reference:

          <ul>
<li>Fukushima, T., &ldquo;Transformation from Cartesian to geodetic coordinates
accelerated by Halley's method&rdquo;, J.Geodesy (2006) 79: 689-693
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauGd2gc</b> (<var>int n, double elong, double phi, double height, double xyz</var>[<var>3</var>])<var><a name="index-iauGd2gc-110"></a></var><br>
<blockquote><p>Transform geodetic coordinates to geocentric using the specified
reference ellipsoid.

        <p>Status: canonical transformation.

        <p>Given:

     <pre class="example">          n       int        ellipsoid identifier (Note 1)
          elong   double     longitude (radians, east +ve)
          phi     double     latitude (geodetic, radians, Note 3)
          height  double     height above ellipsoid (geodetic, Notes 2,3)
</pre>
        <p>Returned:

     <pre class="example">          xyz     double[3]  geocentric vector (Note 2)
</pre>
        <p>Returned (function value):

     <pre class="example">          int        status:  0 = OK
                             -1 = illegal identifier (Note 3)
                             -2 = illegal case (Note 3)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The identifier <var>n</var> is a number that specifies the choice of
reference ellipsoid.  The following are supported:

          <pre class="example">               n    ellipsoid
               
               1     WGS84
               2     GRS80
               3     WGS72
</pre>
          <p>The <var>n</var> value has no significance outside the <acronym>SOFA</acronym> software.  For
convenience, symbols WGS84 etc. are defined in <samp><span class="file">sofam.h</span></samp>.

          <li>The height (height, given) and the geocentric vector (xyz, returned) are
in meters.

          <li>No validation is performed on the arguments elong, phi and height.  An
error status -1 means that the identifier n is illegal.  An error status
-2 protects against cases that would lead to arithmetic exceptions.  In
all error cases, xyz is set to zeros.

          <li>The inverse transformation is performed in the function <code>iauGc2gd</code>.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauEform</code><dd>Earth reference ellipsoids.

          <br><dt><code>iauGd2gce</code><dd>Geodetic to geocentric transformation, general.

          <br><dt><code>iauZp</code><dd>Zero <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauGd2gce</b> (<var>double a, double f, double elong, double phi, double height, double xyz</var>[<var>3</var>])<var><a name="index-iauGd2gce-111"></a></var><br>
<blockquote><p>Transform geodetic coordinates to geocentric for a reference ellipsoid
of specified form.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          a       double     equatorial radius (Notes 1,4)
          f       double     flattening (Notes 2,4)
          elong   double     longitude (radians, east +ve)
          phi     double     latitude (geodetic, radians, Note 4)
          height  double     height above ellipsoid (geodetic, Notes 3,4)
</pre>
        <p>Returned:

     <pre class="example">          xyz     double[3]  geocentric vector (Note 3)
</pre>
        <p>Returned (function value):

     <pre class="example">          int        status:  0 = OK
                             -1 = illegal case (Note 4)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The equatorial radius, a, can be in any units, but meters is the
conventional choice.

          <li>The flattening, f, is (for the Earth) a value around 0.00335,
i.e. around 1/298.

          <li>The equatorial radius, a, and the height, height, must be given in the
same units, and determine the units of the returned geocentric vector,
xyz.

          <li>No validation is performed on individual arguments.  The error status -1
protects against (unrealistic) cases that would lead to arithmetic
exceptions.  If an error occurs, xyz is unchanged.

          <li>The inverse transformation is performed in the function
<code>iauGc2gde</code>.

          <li>The transformation for a standard ellipsoid (such as WGS84) can more
conveniently be performed by calling <code>iauGd2gc</code>, which uses a
numerical code to identify the required a and f values.
             </ol>

        <p>References:

          <ul>
<li>Green, R.M., Spherical Astronomy, Cambridge University Press, (1985)
Section 4.5, p96.

          <li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992), Section 4.22, p202. 
</ul>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-Timescales"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-Geodetic_002fGeocentric">api Geodetic/Geocentric</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-astronomy">api astronomy</a>

</div>

<h4 class="subsection">5.1.9 Timescales</h4>

<div class="defun">
&mdash; Function: int <b>iauD2dtf</b> (<var>const char * scale, int ndp, double d1, double d2, int * iy, int * im, int * id, int ihmsf</var>[<var>4</var>])<var><a name="index-iauD2dtf-112"></a></var><br>
<blockquote><p>Format for output a 2-part Julian Date (or in the case of UTC a quasi-JD
form that includes special provision for leap seconds).

        <p>Status: support function.

        <p>Given:

     <pre class="example">          scale     char[]  time scale ID (Note 1)
          ndp       int     resolution (Note 2)
          d1,d2     double  time as a 2-part Julian Date (Notes 3,4)
</pre>
        <p>Returned:

     <pre class="example">          iy,im,id  int     year, month, day in Gregorian calendar (Note 5)
          ihmsf     int[4]  hours, minutes, seconds, fraction (Note 1)
</pre>
        <p>Returned (function value):

     <pre class="example">          int     status: +1 = dubious year (Note 5)
                           0 = OK
                          -1 = unacceptable date (Note 6)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>scale</var> identifies the time scale.  Only the value <code>UTC</code> (in
upper case) is significant, and enables handling of leap seconds (see
Note 4).

          <li><var>ndp</var> is the number of decimal places in the seconds field, and can
have negative as well as positive values, such as:

          <pre class="example">               ndp         resolution
               -4            1 00 00
               -3            0 10 00
               -2            0 01 00
               -1            0 00 10
                0            0 00 01
                1            0 00 00.1
                2            0 00 00.01
                3            0 00 00.001
</pre>
          <p>The limits are platform dependent, but a safe range is -5 to
+9.

          <li><var>d1</var><code> + </code><var>d2</var> is Julian Date, apportioned in any convenient
way between the two arguments, for example where <var>d1</var> is the Julian
Day Number and <var>d2</var> is the fraction of a day.  In the case of UTC,
where the use of JD is problematical, special conventions apply: see the
next note.

          <li>JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The SOFA internal convention is that the
quasi-JD day represents UTC days whether the length is 86399,
86400 or 86401 SI seconds.

          <li>The warning status &ldquo;dubious year&rdquo; flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See <code>iauDat</code> for further details.

          <li>For calendar conventions and limitations, see <code>iauCal2jd</code>.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauJd2cal</code><dd>JD to Gregorian calendar.

          <br><dt><code>iauD2tf</code><dd>Decompose days to hms.

          <br><dt><code>iauDat</code><dd><code>delta(AT) = TAI-UTC</code>. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauDat</b> (<var>int iy, int im, int id, double fd, double * deltat </var>)<var><a name="index-iauDat-113"></a></var><br>
<blockquote><p>For a given UTC date, calculate <code>delta(AT) = TAI-UTC</code>.

        <blockquote>
<strong>IMPORTANT</strong> A new version of this function must be produced
whenever a new leap second is announced.  There are four items to change
on each such occasion:

          <ol type=1 start=1>
<li>A new line must be added to the set of statements that initialize the
array &ldquo;changes&rdquo;.

          <li>The parameter IYV must be set to the current year.

          <li>The &ldquo;Latest leap second&rdquo; comment below must be set to the new leap
second date.

          <li>The &ldquo;This revision&rdquo; comment, later, must be set to the current date.
             </ol>

        <p>Change (2) must also be carried out whenever the function is re&ndash;issued,
even if no leap seconds have been added.

        <p>Latest leap second:  2012 June 30
</blockquote>

        <p>Status: support function.

        <p>Given:

     <pre class="example">          iy     int      UTC:  year (Notes 1 and 2)
          im     int            month (Note 2)
          id     int            day (Notes 2 and 3)
          fd     double         fraction of day (Note 4)
</pre>
        <p>Returned:

     <pre class="example">          deltat double   TAI minus UTC, seconds
</pre>
        <p>Returned (function value):

     <pre class="example">          int      status (Note 5):
                     1 = dubious year (Note 1)
                     0 = OK
                    -1 = bad year
                    -2 = bad month
                    -3 = bad day (Note 3)
                    -4 = bad fraction (Note 4)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>UTC began at 1960 January 1.0 (JD 2436934.5) and it is improper to call
the function with an earlier date.  If this is attempted, zero is
returned together with a warning status.

          <p>Because leap seconds cannot, in principle, be predicted in advance, a
reliable check for dates beyond the valid range is impossible.  To guard
against gross errors, a year five or more after the release year of the
present function (see parameter IYV) is considered dubious.  In this
case a warning status is returned but the result is computed in the
normal way.

          <p>For both too&ndash;early and too&ndash;late years, the warning status is j =
+1.  This is distinct from the error status j = -1, which
signifies a year so early that JD could not be computed.

          <li>If the specified date is for a day which ends with a leap second, the
UTC-TAI value returned is for the period leading up to the leap second. 
If the date is for a day which begins as a leap second ends, the UTC-TAI
returned is for the period following the leap second.

          <li>The day number must be in the normal calendar range, for example 1
through 30 for April.  The &ldquo;almanac&rdquo; convention of allowing such dates
as January 0 and December 32 is not supported in this function, in order
to avoid confusion near leap seconds.

          <li>The fraction of day is used only for dates before the introduction of
leap seconds, the first of which occurred at the end of 1971.  It is
tested for validity (0 to 1 is the valid range) even if
not used; if invalid, zero is used and status j = -4 is returned. 
For many applications, setting fd to zero is acceptable; the resulting
error is always less than 3 ms (and occurs only pre-1972).

          <li>The status value returned in the case where there are multiple errors
refers to the first error detected.  For example, if the month and day
are 13 and 32 respectively, j = -2 (bad month) will be returned.

          <li>In cases where a valid result is not available, zero is returned.
             </ol>

        <p>References:

          <ol type=1 start=1>
<li>For dates from 1961 January 1 onwards, the expressions from the file
<a href="ftp://maia.usno.navy.mil/ser7/tai-utc.dat">ftp://maia.usno.navy.mil/ser7/tai-utc.dat</a> are used.

          <li>The 5ms timestep at 1961 January 1 is taken from 2.58.1 (p87) of the
1992 Explanatory Supplement.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauCal2jd</code><dd>Gregorian calendar to Julian Day number. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauDtdb</b> (<var>double date1, double date2, double ut, double elong, double u, double v</var>)<var><a name="index-iauDtdb-114"></a></var><br>
<blockquote><p>An approximation to TDB-TT, the difference between barycentric dynamical
time and terrestrial time, for an observer on the Earth.

        <p>The different time scales &mdash; proper, coordinate and realized &mdash; are
related to each other:

     <pre class="example">                  TAI             &lt;-  physically realized
                   :
                offset            &lt;-  observed (nominally +32.184s)
                   :
                  TT              &lt;-  terrestrial time
                   :
          rate adjustment (L_G)   &lt;-  definition of TT
                   :
                  TCG             &lt;-  time scale for GCRS
                   :
            "periodic" terms      &lt;-  iauDtdb  is an implementation
                   :
          rate adjustment (L_C)   &lt;-  function of solar-system ephemeris
                   :
                  TCB             &lt;-  time scale for BCRS
                   :
          rate adjustment (-L_B)  &lt;-  definition of TDB
                   :
                  TDB             &lt;-  TCB scaled to track TT
                   :
            "periodic" terms      &lt;-  -iauDtdb is an approximation
                   :
                  TT              &lt;-  terrestrial time
</pre>
        <p>Adopted values for the various constants can be found in the IERS
Conventions (McCarthy &amp; Petit 2003).

        <p>Status: support routine.

        <p>Given:

     <pre class="example">          date1,date2   double  date, TDB (Notes 1-3)
          ut            double  universal time (UT1, fraction of one day)
          elong         double  longitude (east positive, radians)
          u             double  distance from Earth spin axis (km)
          v             double  distance north of equatorial plane (km)
</pre>
        <p>Returned (function value):

     <pre class="example">          double  TDB-TT (seconds)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The date <var>date1</var><code> + </code><var>date2</var> is a Julian Date, apportioned
in any convenient way between the two arguments.  For example,
<code>JD(TT) = 2450123.7</code> could be expressed in any of these ways, among
others:

          <pre class="example">                  date1          date2
               
               2450123.7           0.0       (JD method)
               2451545.0       -1421.3       (J2000 method)
               2400000.5       50123.2       (MJD method)
               2450123.5           0.2       (date &amp; time method)
</pre>
          <p>The JD method is the most natural and convenient to use in cases where
the loss of several decimal digits of resolution is acceptable.  The
J2000 method is best matched to the way the argument is handled
internally and will deliver the optimum resolution.  The MJD method and
the date &amp; time methods are both good compromises between resolution and
convenience.

          <p>Although the date is, formally, barycentric dynamical time (TDB), the
terrestrial dynamical time (TT) can be used with no practical effect on
the accuracy of the prediction.

          <li>TT can be regarded as a coordinate time that is realized as an offset of
32.184s from International Atomic Time, TAI.  TT is a specific linear
transformation of geocentric coordinate time TCG, which is the time
scale for the Geocentric Celestial Reference System, GCRS.

          <li>TDB is a coordinate time, and is a specific linear transformation of
barycentric coordinate time TCB, which is the time scale for the
Barycentric Celestial Reference System, BCRS.

          <li>The difference TCG-TCB depends on the masses and positions of the bodies
of the solar system and the velocity of the Earth.  It is dominated by a
rate difference, the residual being of a periodic character.  The
latter, which is modeled by the present function, comprises a main
(annual) sinusoidal term of amplitude approximately 0.00166 seconds,
plus planetary terms up to about 20 microseconds, and lunar and diurnal
terms up to 2 microseconds.  These effects come from the changing
transverse Doppler effect and gravitational red-shift as the observer
(on the Earth's surface) experiences variations in speed (with respect
to the BCRS) and gravitational potential.

          <li>TDB can be regarded as the same as TCB but with a rate adjustment to
keep it close to TT, which is convenient for many applications.  The
history of successive attempts to define TDB is set out in Resolution 3
adopted by the IAU General Assembly in 2006, which defines a fixed
TDB(TCB) transformation that is consistent with contemporary
solar-system ephemerides.  Future ephemerides will imply slightly
changed transformations between TCG and TCB, which could introduce a
linear drift between TDB and TT; however, any such drift is unlikely to
exceed 1 nanosecond per century.

          <li>The geocentric TDB-TT model used in the present function is that of
Fairhead &amp; Bretagnon (1990), in its full form.  It was originally
supplied by Fairhead (private communications with P.T.Wallace, 1990) as
a Fortran subroutine.  The present C function contains an adaptation of
the Fairhead code.  The numerical results are essentially unaffected by
the changes, the differences with respect to the Fairhead &amp; Bretagnon
original being at the 1e-20 s level.

          <p>The topocentric part of the model is from Moyer (1981) and Murray
(1983), with fundamental arguments adapted from Simon et al. 1994.  It
is an approximation to the expression <code>( v / c ) . ( r / c )</code>,
where <code>v</code> is the barycentric velocity of the Earth, <code>r</code> is the
geocentric position of the observer and <code>c</code> is the speed of light.

          <p>By supplying zeroes for <var>u</var> and <var>v</var>, the topocentric part of the
model can be nullified, and the function will return the Fairhead &amp;
Bretagnon result alone.

          <li>During the interval 1950-2050, the absolute accuracy is better than +/-
3 nanoseconds relative to time ephemerides obtained by direct numerical
integrations based on the JPL DE405 solar system ephemeris.

          <li>It must be stressed that the present function is merely a model, and
that numerical integration of solar-system ephemerides is the definitive
method for predicting the relationship between TCG and TCB and hence
between TT and TDB.
             </ol>

        <p>References:

          <ul>
<li>Fairhead, L., &amp; Bretagnon, P., Astron.Astrophys., 229, 240-247 (1990).

          <li>IAU 2006 Resolution 3.

          <li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Moyer, T.D., Cel.Mech., 23, 33 (1981).

          <li>Murray, C.A., Vectorial Astrometry, Adam Hilger (1983).

          <li>Seidelmann, P.K. et al., Explanatory Supplement to the Astronomical
Almanac, Chapter 2, University Science Books (1992).

          <li>Simon, J.L., Bretagnon, P., Chapront, J., Chapront-Touze, M., Francou,
G. &amp; Laskar, J., Astron.Astrophys., 282, 663-683 (1994). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauDtf2d</b> (<var>const char * scale, int iy, int im, int id, int ihr, int imn, double sec, double * d1, double * d2</var>)<var><a name="index-iauDtf2d-115"></a></var><br>
<blockquote><p>Encode date and time fields into 2-part Julian Date (or in the case of
UTC a quasi-JD form that includes special provision for leap seconds).

        <p>Status: support function.

        <p>Given:

     <pre class="example">          scale     char[]  time scale ID (Note 1)
          iy,im,id  int     year, month, day in Gregorian calendar (Note 2)
          ihr,imn   int     hour, minute
          sec       double  seconds
</pre>
        <p>Returned:

     <pre class="example">          d1,d2     double  2-part Julian Date (Notes 3,4)
</pre>
        <p>Returned (function value):

     <pre class="example">          int     status: +3 = both of next two
                          +2 = time is after end of day (Note 5)
                          +1 = dubious year (Note 6)
                           0 = OK
                          -1 = bad year
                          -2 = bad month
                          -3 = bad day
                          -4 = bad hour
                          -5 = bad minute
                          -6 = bad second (&lt;0)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>scale</var> identifies the time scale.  Only the value <code>UTC</code> (in
upper case) is significant, and enables handling of leap seconds (see
Note 4).

          <li>For calendar conventions and limitations, see iauCal2jd.

          <li>The sum of the results, <var>d1</var><code> + </code><var>d2</var>, is Julian Date,
where normally <var>d1</var> is the Julian Day Number and <var>d2</var> is the
fraction of a day.  In the case of UTC, where the use of JD is
problematical, special conventions apply: see the next note.

          <li>JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The <acronym>SOFA</acronym> internal convention is that the
quasi-JD day represents UTC days whether the length is 86399,
86400 or 86401 SI seconds.

          <li>The warning status &ldquo;time is after end of day&rdquo; usually means that the
sec argument is greater than 60.0.  However, in a day ending in a
leap second the limit changes to 61.0 (or 59.0 in the case
of a negative leap second).

          <li>The warning status &ldquo;dubious year&rdquo; flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See <code>iauDat</code> for further details.

          <li>Only in the case of continuous and regular time scales (TAI, TT, TCG,
TCB and TDB) is the result d1+d2 a Julian Date, strictly speaking.  In
the other cases (UT1 and UTC) the result must be used with
circumspection; in particular the difference between two such results
cannot be interpreted as a precise time interval.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauCal2jd</code><dd>Gregorian calendar to JD.

          <br><dt><code>iauDat</code><dd><code>delta(AT) = TAI-UTC</code>.

          <br><dt><code>iauJd2cal</code><dd>JD to Gregorian calendar. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTaitt</b> (<var>double tai1, double tai2, double * tt1, double * tt2</var>)<var><a name="index-iauTaitt-116"></a></var><br>
<blockquote><p>Time scale transformation: International Atomic Time, TAI, to
Terrestrial Time, TT.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          tai1,tai2  double    TAI as a 2-part Julian Date
</pre>
        <p>Returned:

     <pre class="example">          tt1,tt2    double    TT as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>tai1</var><code> + </code><var>tai2</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>tai1</var>
is the Julian Day Number and <var>tai2</var> is the fraction of a day.  The
returned <var>tt1</var>, <var>tt2</var> follow suit.
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTaiut1</b> (<var>double tai1, double tai2, double dta, double * ut11, double * ut12</var>)<var><a name="index-iauTaiut1-117"></a></var><br>
<blockquote><p>Time scale transformation: International Atomic Time, TAI, to Universal
Time, UT1.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          tai1,tai2  double    TAI as a 2-part Julian Date
          dta        double    UT1-TAI in seconds
</pre>
        <p>Returned:

     <pre class="example">          ut11,ut12  double    UT1 as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>tai1</var><code> + </code><var>tai2</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>tai1</var>
is the Julian Day Number and <var>tai2</var> is the fraction of a day.  The
returned <var>ut11</var>, <var>ut12</var> follow suit.

          <li>The argument dta, i.e. UT1-TAI, is an observed quantity, and is
available from IERS tabulations.
             </ol>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTaiutc</b> (<var>double tai1, double tai2, double * utc1, double * utc2</var>)<var><a name="index-iauTaiutc-118"></a></var><br>
<blockquote><p>Time scale transformation: International Atomic Time, TAI, to
Coordinated Universal Time, UTC.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          tai1,tai2  double   TAI as a 2-part Julian Date (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          utc1,utc2  double   UTC as a 2-part quasi Julian Date (Notes 1-3)
</pre>
        <p>Returned (function value):

     <pre class="example">          int      status: +1 = dubious year (Note 4)
                            0 = OK
                           -1 = unacceptable date
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>tai1</var><code> + </code><var>tai2</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>tai1</var>
is the Julian Day Number and <var>tai2</var> is the fraction of a day.  The
returned <var>utc1</var> and <var>utc2</var> form an analogous pair, except that
a special convention is used, to deal with the problem of leap
seconds&mdash;see the next note.

          <li>JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The convention in the present function is
that the JD day represents UTC days whether the length is 86399, 86400
or 86401 SI seconds.

          <li>The function <code>iauD2dtf</code> can be used to transform the UTC quasi-JD
into calendar date and clock time, including UTC leap second handling.

          <li>The warning status &ldquo;dubious year&rdquo; flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See <code>iauDat</code> for further details.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauJd2cal</code><dd>JD to Gregorian calendar.

          <br><dt><code>iauDat</code><dd><code>delta(AT) = TAI-UTC</code>.

          <br><dt><code>iauCal2jd</code><dd>Gregorian calendar to JD. 
</dl>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTcbtdb</b> (<var>double tcb1, double tcb2, double * tdb1, double * tdb2</var>)<var><a name="index-iauTcbtdb-119"></a></var><br>
<blockquote><p>Time scale transformation: Barycentric Coordinate Time, TCB, to
Barycentric Dynamical Time, TDB.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          tcb1,tcb2  double    TCB as a 2-part Julian Date
</pre>
        <p>Returned:

     <pre class="example">          tdb1,tdb2  double    TDB as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>tcb1</var><code> + </code><var>tcb2</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>tcb1</var>
is the Julian Day Number and <var>tcb2</var> is the fraction of a day.  The
returned <var>tdb1</var>, <var>tdb2</var> follow suit.

          <li>The 2006 IAU General Assembly introduced a conventional linear
transformation between TDB and TCB.  This transformation compensates for
the drift between TCB and terrestrial time TT, and keeps TDB
approximately centered on TT.  Because the relationship between TT and
TCB depends on the adopted solar system ephemeris, the degree of
alignment between TDB and TT over long intervals will vary according to
which ephemeris is used.  Former definitions of TDB attempted to avoid
this problem by stipulating that TDB and TT should differ only by
periodic effects.  This is a good description of the nature of the
relationship but eluded precise mathematical formulation.  The
conventional linear relationship adopted in 2006 sidestepped these
difficulties whilst delivering a TDB that in practice was consistent
with values before that date.

          <li>TDB is essentially the same as Teph, the time argument for the JPL solar
system ephemerides.
             </ol>

        <p>Reference:

          <ul>
<li>IAU 2006 Resolution B3. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTcgtt</b> (<var>double tcg1, double tcg2, double * tt1, double * tt2</var>)<var><a name="index-iauTcgtt-120"></a></var><br>
<blockquote><p>Time scale transformation:  Geocentric Coordinate Time, TCG, to
Terrestrial Time, TT.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          tcg1,tcg2  double    TCG as a 2-part Julian Date
</pre>
        <p>Returned:

     <pre class="example">          tt1,tt2    double    TT as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><li><var>tcg1</var><code> + </code><var>tcg2</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>tcg1</var>
is the Julian Day Number and <var>tcg2</var> is the fraction of a day.  The
returned <var>tt1</var>, <var>tt2</var> follow suit.
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),.  IERS
Technical Note No. 32, BKG (2004).

          <li>IAU 2000 Resolution B1.9. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTdbtcb</b> (<var>double tdb1, double tdb2, double * tcb1, double * tcb2</var>)<var><a name="index-iauTdbtcb-121"></a></var><br>
<blockquote><p>Time scale transformation:  Barycentric Dynamical Time, TDB, to
Barycentric Coordinate Time, TCB.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          tdb1,tdb2  double    TDB as a 2-part Julian Date
</pre>
        <p>Returned:

     <pre class="example">          tcb1,tcb2  double    TCB as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>tdb1</var><code> + </code><var>tdb2</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>tdb1</var>
is the Julian Day Number and <var>tdb2</var> is the fraction of a day.  The
returned <var>tcb1</var>, <var>tcb2</var> follow suit.

          <li>The 2006 IAU General Assembly introduced a conventional linear
transformation between TDB and TCB.  This transformation compensates for
the drift between TCB and terrestrial time TT, and keeps TDB
approximately centered on TT.  Because the relationship between TT and
TCB depends on the adopted solar system ephemeris, the degree of
alignment between TDB and TT over long intervals will vary according to
which ephemeris is used.  Former definitions of TDB attempted to avoid
this problem by stipulating that TDB and TT should differ only by
periodic effects.  This is a good description of the nature of the
relationship but eluded precise mathematical formulation.  The
conventional linear relationship adopted in 2006 sidestepped these
difficulties whilst delivering a TDB that in practice was consistent
with values before that date.

          <li>TDB is essentially the same as Teph, the time argument for the JPL solar
system ephemerides.
             </ol>

        <p>Reference:

          <ul>
<li>IAU 2006 Resolution B3. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTdbtt</b> (<var>double tdb1, double tdb2, double dtr, double * tt1, double * tt2 </var>)<var><a name="index-iauTdbtt-122"></a></var><br>
<blockquote><p>Time scale transformation: Barycentric Dynamical Time, TDB, to
Terrestrial Time, TT.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          tdb1,tdb2  double    TDB as a 2-part Julian Date
          dtr        double    TDB-TT in seconds
</pre>
        <p>Returned:

     <pre class="example">          tt1,tt2    double    TT as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>tdb1</var><code> + </code><var>tdb2</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>tdb1</var>
is the Julian Day Number and tdb2 is the fraction of a day.  The
returned <var>tt1</var>, <var>tt2</var> follow suit.

          <li>The argument dtr represents the quasi&ndash;periodic component of the GR
transformation between TT and TCB.  It is dependent upon the adopted
solar&ndash;system ephemeris, and can be obtained by numerical integration,
by interrogating a precomputed time ephemeris or by evaluating a model
such as that implemented in the <acronym>SOFA</acronym> function <code>iauDtdb</code>.  The
quantity is dominated by an annual term of 1.7 ms amplitude.

          <li>TDB is essentially the same as Teph, the time argument for the JPL solar
system ephemerides.
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>IAU 2006 Resolution 3. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTttai</b> (<var>double tt1, double tt2, double * tai1, double * tai2</var>)<var><a name="index-iauTttai-123"></a></var><br>
<blockquote><p>Time scale transformation: Terrestrial Time, TT, to International Atomic
Time, TAI.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          tt1,tt2    double    TT as a 2-part Julian Date
</pre>
        <p>Returned:

     <pre class="example">          tai1,tai2  double    TAI as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>tt1</var><code> + </code><var>tt2</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>tt1</var> is
the Julian Day Number and <var>tt2</var> is the fraction of a day.  The
returned <var>tai1</var>, <var>tai2</var> follow suit.
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTttcg</b> (<var>double tt1, double tt2, double * tcg1, double * tcg2</var>)<var><a name="index-iauTttcg-124"></a></var><br>
<blockquote><p>Time scale transformation: Terrestrial Time, TT, to Geocentric
Coordinate Time, TCG.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          tt1,tt2    double    TT as a 2-part Julian Date
</pre>
        <p>Returned:

     <pre class="example">          tcg1,tcg2  double    TCG as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>tt1</var><code> + </code><var>tt2</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>tt1</var> is
the Julian Day Number and <var>tt2</var> is the fraction of a day.  The
returned <var>tcg1</var>, <var>tcg2</var> follow suit.
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>IAU 2000 Resolution B1.9. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTttdb</b> (<var>double tt1, double tt2, double dtr, double * tdb1, double * tdb2</var>)<var><a name="index-iauTttdb-125"></a></var><br>
<blockquote><p>Time scale transformation:  Terrestrial Time, TT, to Barycentric
Dynamical Time, TDB.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          tt1,tt2    double    TT as a 2-part Julian Date
          dtr        double    TDB-TT in seconds
</pre>
        <p>Returned:

     <pre class="example">          tdb1,tdb2  double    TDB as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>tt1</var><code> + </code><var>tt2</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>tt1</var> is
the Julian Day Number and <var>tt2</var> is the fraction of a day.  The
returned <var>tdb1</var>, <var>tdb2</var> follow suit.

          <li>The argument <var>dtr</var> represents the quasi&ndash;periodic component of the
GR transformation between TT and TCB.  It is dependent upon the adopted
solar&ndash;system ephemeris, and can be obtained by numerical integration,
by interrogating a precomputed time ephemeris or by evaluating a model
such as that implemented in the <acronym>SOFA</acronym> function <code>iauDtdb</code>.  The
quantity is dominated by an annual term of 1.7 ms amplitude.

          <li>TDB is essentially the same as Teph, the time argument for the JPL solar
system ephemerides.
             </ol>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>IAU 2006 Resolution 3. 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTtut1</b> (<var>double tt1, double tt2, double dt, double * ut11, double * ut12</var>)<var><a name="index-iauTtut1-126"></a></var><br>
<blockquote><p>Time scale transformation: Terrestrial Time, TT, to Universal Time, UT1.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          tt1,tt2    double    TT as a 2-part Julian Date
          dt         double    TT-UT1 in seconds
</pre>
        <p>Returned:

     <pre class="example">          ut11,ut12  double    UT1 as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>tt1</var><code> + </code><var>tt2</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>tt1</var> is
the Julian Day Number and <var>tt2</var> is the fraction of a day.  The
returned <var>ut11</var>, <var>ut12</var> follow suit.

          <li>The argument <var>dt</var> is classical Delta T.
             </ol>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauUt1tai</b> (<var>double ut11, double ut12, double dta, double * tai1, double * tai2</var>)<var><a name="index-iauUt1tai-127"></a></var><br>
<blockquote><p>Time scale transformation: Universal Time, UT1, to International Atomic
Time, TAI.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          ut11,ut12  double    UT1 as a 2-part Julian Date
          dta        double    UT1-TAI in seconds
</pre>
        <p>Returned:

     <pre class="example">          tai1,tai2  double    TAI as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>ut11</var><code> + </code><var>ut12</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>ut11</var>
is the Julian Day Number and <var>ut12</var> is the fraction of a day.  The
returned <var>tai1</var>, <var>tai2</var> follow suit.

          <li>The argument <var>dta</var>, i.e. UT1-TAI, is an observed quantity, and is
available from IERS tabulations.
             </ol>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauUt1tt</b> (<var>double ut11, double ut12, double dt, double * tt1, double * tt2</var>)<var><a name="index-iauUt1tt-128"></a></var><br>
<blockquote><p>Time scale transformation: Universal Time, UT1, to Terrestrial Time, TT.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          ut11,ut12  double    UT1 as a 2-part Julian Date
          dt         double    TT-UT1 in seconds
</pre>
        <p>Returned:

     <pre class="example">          tt1,tt2    double    TT as a 2-part Julian Date
</pre>
        <p>Returned (function value):

     <pre class="example">          int       status:  0 = OK
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>ut11</var><code> + </code><var>ut12</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>ut11</var>
is the Julian Day Number and <var>ut12</var> is the fraction of a day.  The
returned <var>tt1</var>, <var>tt2</var> follow suit.

          <li>The argument <var>dt</var> is classical Delta T.
             </ol>

        <p>Reference:

          <ul>
<li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauUt1utc</b> (<var>double ut11, double ut12, double dut1, double * utc1, double * utc2</var>)<var><a name="index-iauUt1utc-129"></a></var><br>
<blockquote><p>Time scale transformation: Universal Time, UT1, to Coordinated Universal
Time, UTC.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          ut11,ut12  double   UT1 as a 2-part Julian Date (Note 1)
          dut1       double   Delta UT1: UT1-UTC in seconds (Note 2)
</pre>
        <p>Returned:

     <pre class="example">          utc1,utc2  double   UTC as a 2-part quasi Julian Date (Notes 3,4)
</pre>
        <p>Returned (function value):

     <pre class="example">          int      status: +1 = dubious year (Note 5)
                            0 = OK
                           -1 = unacceptable date
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>ut11</var><code> + </code><var>ut12</var> is Julian Date, apportioned in any
convenient way between the two arguments, for example where <var>ut11</var>
is the Julian Day Number and <var>ut12</var> is the fraction of a day.  The
returned <var>utc1</var> and <var>utc2</var> form an analogous pair, except that
a special convention is used, to deal with the problem of leap
seconds&mdash;see Note 3.

          <li>Delta UT1 can be obtained from tabulations provided by the International
Earth Rotation and Reference Systems Service.  The value changes
abruptly by 1 second at a leap second; however, close to a leap
second the algorithm used here is tolerant of the &ldquo;wrong&rdquo; choice of
value being made.

          <li>JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The convention in the present function is
that the returned quasi JD day <var>UTC1</var><code> + </code><var>utc2</var>
represents UTC days whether the length is 86399, 86400 or 86401 SI
seconds.

          <li>The function <code>iauD2dtf</code> can be used to transform the UTC quasi-JD
into calendar date and clock time, including UTC leap second handling.

          <li>The warning status &ldquo;dubious year&rdquo; flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See <code>iauDat</code> for further details.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauJd2cal</code><dd>JD to Gregorian calendar.

          <br><dt><code>iauDat</code><dd><code>delta(AT) = TAI-UTC</code>.

          <br><dt><code>iauCal2jd</code><dd>Gregorian calendar to JD. 
</dl>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauUtctai</b> (<var>double utc1, double utc2, double * tai1, double * tai2</var>)<var><a name="index-iauUtctai-130"></a></var><br>
<blockquote><p>Time scale transformation: Coordinated Universal Time, UTC, to
International Atomic Time, TAI.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          utc1,utc2  double   UTC as a 2-part quasi Julian Date (Notes 1-4)
</pre>
        <p>Returned:

     <pre class="example">          tai1,tai2  double   TAI as a 2-part Julian Date (Note 5)
</pre>
        <p>Returned (function value):

     <pre class="example">          int      status: +1 = dubious year (Note 3)
                            0 = OK
                           -1 = unacceptable date
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>utc1</var><code> + </code><var>utc2</var> is quasi Julian Date (see Note 2),
apportioned in any convenient way between the two arguments, for example
where <var>utc1</var> is the Julian Day Number and <var>utc2</var> is the
fraction of a day.

          <li>JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The convention in the present function is
that the JD day represents UTC days whether the length is 86399, 86400
or 86401 SI seconds.

          <li>The warning status &ldquo;dubious year&rdquo; flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See <code>iauDat</code> for further details.

          <li>The function <code>iauDtf2d</code> converts from calendar date and time of day
into 2-part Julian Date, and in the case of UTC implements the
leap&ndash;second&ndash;ambiguity convention described above.

          <li>The returned <var>TAI1</var>, <var>TAI2</var> are such that their sum is the TAI
Julian Date.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauJd2cal</code><dd>JD to Gregorian calendar.

          <br><dt><code>iauDat</code><dd><code>delta(AT) = TAI-UTC</code>.

          <br><dt><code>iauCal2jd</code><dd>Gregorian calendar to JD. 
</dl>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992). 
</ul>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauUtcut1</b> (<var>double utc1, double utc2, double dut1, double * ut11, double * ut12</var>)<var><a name="index-iauUtcut1-131"></a></var><br>
<blockquote><p>Time scale transformation: Coordinated Universal Time, UTC, to Universal
Time, UT1.

        <p>Status: canonical.

        <p>Given:

     <pre class="example">          utc1,utc2  double   UTC as a 2-part quasi Julian Date (Notes 1-4)
          dut1       double   Delta UT1 = UT1-UTC in seconds (Note 5)
</pre>
        <p>Returned:

     <pre class="example">          ut11,ut12  double   UT1 as a 2-part Julian Date (Note 6)
</pre>
        <p>Returned (function value):

     <pre class="example">          int      status: +1 = dubious year (Note 7)
                            0 = OK
                           -1 = unacceptable date
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li><var>utc1</var><code> + </code><var>utc2</var> is quasi Julian Date (see Note 2),
apportioned in any convenient way between the two arguments, for example
where <var>utc1</var> is the Julian Day Number and <var>utc2</var> is the
fraction of a day.

          <li>JD cannot unambiguously represent UTC during a leap second unless
special measures are taken.  The convention in the present function is
that the JD day represents UTC days whether the length is 86399, 86400
or 86401 SI seconds.

          <li>The warning status &ldquo;dubious year&rdquo; flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See <code>iauDat</code> for further details.

          <li>The function <code>iauDtf2d</code> converts from calendar date and time of day
into 2-part Julian Date, and in the case of UTC implements the
leap&ndash;second&ndash;ambiguity convention described above.

          <li>Delta UT1 can be obtained from tabulations provided by the International
Earth Rotation and Reference Systems Service.  It It is the caller's
responsibility to supply a DUT argument containing the UT1-UTC value
that matches the given UTC.

          <li>The returned <var>ut11</var>, <var>ut12</var> are such that their sum is the UT1
Julian Date.

          <li>The warning status &ldquo;dubious year&rdquo; flags UTCs that predate the
introduction of the time scale and that are too far in the future to be
trusted.  See <code>iauDat</code> for further details.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauJd2cal</code><dd>JD to Gregorian calendar.

          <br><dt><code>iauDat</code><dd><code>delta(AT) = TAI-UTC</code>.

          <br><dt><code>iauUtctai</code><dd>UTC to TAI.

          <br><dt><code>iauTaiut1</code><dd>TAI to UT1. 
</dl>

        <p>References:

          <ul>
<li>McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003), IERS
Technical Note No. 32, BKG (2004).

          <li>Explanatory Supplement to the Astronomical Almanac, P. Kenneth
Seidelmann (ed), University Science Books (1992). 
</ul>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-vector-matrix"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-consts-fortran">api consts fortran</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-astronomy">api astronomy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">5.2 Vector and matrix functions</h3>

<ul class="menu">
<li><a accesskey="1" href="#api-AngleOps">api AngleOps</a>:                 Angle operations. 
<li><a accesskey="2" href="#api-BuildRotations">api BuildRotations</a>:           Build rotations. 
<li><a accesskey="3" href="#api-CopyExtendExtract">api CopyExtendExtract</a>:        Copy extend extract. 
<li><a accesskey="4" href="#api-Initialization">api Initialization</a>:           Initialization. 
<li><a accesskey="5" href="#api-MatrixOps">api MatrixOps</a>:                Matrix operations. 
<li><a accesskey="6" href="#api-MatrixVectorProducts">api MatrixVectorProducts</a>:     Matrix vector products. 
<li><a accesskey="7" href="#api-RotationVectors">api RotationVectors</a>:          Rotation vectors. 
<li><a accesskey="8" href="#api-SeparationAndAngle">api SeparationAndAngle</a>:       Separation and angle. 
<li><a accesskey="9" href="#api-SphericalCartesian">api SphericalCartesian</a>:       Spherical cartesian. 
<li><a href="#api-VectorOps">api VectorOps</a>:                Vector operations. 
</ul>

<!-- page -->
<div class="node">
<a name="api-AngleOps"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-BuildRotations">api BuildRotations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-vector-matrix">api vector matrix</a>

</div>

<h4 class="subsection">5.2.1 Angle operations</h4>

<div class="defun">
&mdash; Function: void <b>iauA2af</b> (<var>int ndp, double angle, char * sign, int idmsf</var>[<var>4</var>])<var><a name="index-iauA2af-132"></a></var><br>
<blockquote><p>Decompose radians into degrees, arcminutes, arcseconds, fraction.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          ndp     int     resolution (Note 1)
          angle   double  angle in radians
</pre>
        <p>Returned:

     <pre class="example">          sign    char    '+' or '-'
          idmsf   int[4]  degrees, arcminutes, arcseconds, fraction
</pre>
        <p>Called:

          <dl>
<dt><code>iauD2tf</code><dd>Decompose days to hms. 
</dl>

        <p>Notes:

          <ol type=1 start=1>
<li>The argument <var>ndp</var> is interpreted as follows:

          <pre class="example">               ndp         resolution
                :      ...0000 00 00
               -7         1000 00 00
               -6          100 00 00
               -5           10 00 00
               -4            1 00 00
               -3            0 10 00
               -2            0 01 00
               -1            0 00 10
                0            0 00 01
                1            0 00 00.1
                2            0 00 00.01
                3            0 00 00.001
                :            0 00 00.000...
</pre>
          <li>The largest positive useful value for <var>ndp</var> is determined by the
size of angle, the format of doubles on the target platform, and the
risk of overflowing <code>idmsf[3]</code>.  On a typical platform, for angle
up to <code>2pi</code>, the available floating&ndash;point precision might
correspond to <code>ndp=12</code>.  However, the practical limit is typically
<code>ndp=9</code>, set by the capacity of a 32-bit int, or <code>ndp=4</code> if
<code>int</code> is only 16 bits.

          <li>The absolute value of <var>angle</var> may exceed <code>2pi</code>.  In cases where
it does not, it is up to the caller to test for and handle the case
where angle is very nearly <code>2pi</code> and rounds up to 360
degrees, by testing for <code>idmsf[0]=360</code> and setting
<code>idmsf[0-3]</code> to zero.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauA2tf</b> (<var>int ndp, double angle, char * sign, int ihmsf</var>[<var>4</var>])<var><a name="index-iauA2tf-133"></a></var><br>
<blockquote><p>Decompose radians into hours, minutes, seconds, fraction.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          ndp     int     resolution (Note 1)
          angle   double  angle in radians
</pre>
        <p>Returned:

     <pre class="example">          sign    char    '+' or '-'
          ihmsf   int[4]  hours, minutes, seconds, fraction
</pre>
        <p>Called:

          <dl>
<dt><code>iauD2tf</code><dd>Decompose days to hms. 
</dl>

        <p>Notes:

          <ol type=1 start=1>
<li>The argument <var>ndp</var> is interpreted as follows:

          <pre class="example">               ndp         resolution
                :      ...0000 00 00
               -7         1000 00 00
               -6          100 00 00
               -5           10 00 00
               -4            1 00 00
               -3            0 10 00
               -2            0 01 00
               -1            0 00 10
                0            0 00 01
                1            0 00 00.1
                2            0 00 00.01
                3            0 00 00.001
                :            0 00 00.000...
</pre>
          <li>The largest positive useful value for <var>ndp</var> is determined by the
size of <var>angle</var>, the format of doubles on the target platform, and
the risk of overflowing <code>ihmsf[3]</code>.  On a typical platform, for
<var>angle</var> up to <code>2pi</code>, the available floating&ndash;point precision
might correspond to <code>ndp=12</code>.  However, the practical limit is
typically <code>ndp=9</code>, set by the capacity of a 32-bit int, or
<code>ndp=4</code> if <code>int</code> is only 16 bits.

          <li>The absolute value of <var>angle</var> may exceed <code>2pi</code>.  In cases where
it does not, it is up to the caller to test for and handle the case
where angle is very nearly <code>2pi</code> and rounds up to 24 hours,
by testing for <code>ihmsf[0]=24</code> and setting <code>ihmsf(0-3)</code> to zero.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauAf2a</b> (<var>char s, int ideg, int iamin, double asec, double * rad</var>)<var><a name="index-iauAf2a-134"></a></var><br>
<blockquote><p>Convert degrees, arcminutes, arcseconds to radians.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          s         char    sign:  '-' = negative, otherwise positive
          ideg      int     degrees
          iamin     int     arcminutes
          asec      double  arcseconds
</pre>
        <p>Returned:

     <pre class="example">          rad       double  angle in radians
</pre>
        <p>Returned (function value):

     <pre class="example">          int     status:  0 = OK
                           1 = ideg outside range 0-359
                           2 = iamin outside range 0-59
                           3 = asec outside range 0-59.999...
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The result is computed even if any of the range checks fail.

          <li>Negative <var>ideg</var>, <var>iamin</var> and/or <var>asec</var> produce a warning
status, but the absolute value is used in the conversion.

          <li>If there are multiple errors, the status value reflects only the first,
the smallest taking precedence.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauAnp</b> (<var>double a</var>)<var><a name="index-iauAnp-135"></a></var><br>
<blockquote><p>Normalize angle into the range <code>0 &lt;= </code><var>a</var><code> &lt; 2pi</code>.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a        double     angle (radians)
</pre>
        <p>Returned (function value):

     <pre class="example">          double     angle in range 0-2pi
</pre>
        </blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauAnpm</b> (<var>double a</var>)<var><a name="index-iauAnpm-136"></a></var><br>
<blockquote><p>Normalize angle into the range <code>-pi &lt;= </code><var>a</var><code> &lt; +pi</code>.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a        double     angle (radians)
</pre>
        <p>Returned (function value):

     <pre class="example">          double     angle in range +/-pi
</pre>
        </blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauD2tf</b> (<var>int ndp, double days, char * sign, int ihmsf</var>[<var>4</var>])<var><a name="index-iauD2tf-137"></a></var><br>
<blockquote><p>Decompose days to hours, minutes, seconds, fraction.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          ndp     int     resolution (Note 1)
          days    double  interval in days
</pre>
        <p>Returned:

     <pre class="example">          sign    char    '+' or '-'
          ihmsf   int[4]  hours, minutes, seconds, fraction
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The argument <var>ndp</var> is interpreted as follows:

          <pre class="example">               ndp         resolution
                :      ...0000 00 00
               -7         1000 00 00
               -6          100 00 00
               -5           10 00 00
               -4            1 00 00
               -3            0 10 00
               -2            0 01 00
               -1            0 00 10
                0            0 00 01
                1            0 00 00.1
                2            0 00 00.01
                3            0 00 00.001
                :            0 00 00.000...
</pre>
          <li>The largest positive useful value for <var>ndp</var> is determined by the
size of days, the format of double on the target platform, and the risk
of overflowing <code>ihmsf[3]</code>.  On a typical platform, for days up to
1.0, the available floating&ndash;point precision might correspond to
<var>ndp</var><code> = 12</code>.  However, the practical limit is typically
<var>ndp</var><code> = 9</code>, set by the capacity of a 32-bit int, or
<var>ndp</var><code> = 4</code> if int is only 16 bits.

          <li>The absolute value of days may exceed 1.0.  In cases where it
does not, it is up to the caller to test for and handle the case where
days is very nearly 1.0 and rounds up to 24 hours, by testing for
<var>ihmsf</var><code>[0] = 24</code> and setting <var>ihmsf</var><code>[0-3]</code> to zero.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTf2a</b> (<var>char s, int ihour, int imin, double sec, double * rad</var>)<var><a name="index-iauTf2a-138"></a></var><br>
<blockquote><p>Convert hours, minutes, seconds to radians.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          s         char    sign:  '-' = negative, otherwise positive
          ihour     int     hours
          imin      int     minutes
          sec       double  seconds
</pre>
        <p>Returned:

     <pre class="example">          rad       double  angle in radians
</pre>
        <p>Returned (function value):

     <pre class="example">          int     status:  0 = OK
                           1 = ihour outside range 0-23
                           2 = imin outside range 0-59
                           3 = sec outside range 0-59.999...
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The result is computed even if any of the range checks fail.

          <li>Negative <var>ihour</var>, <var>imin</var> and/or <var>sec</var> produce a warning
status, but the absolute value is used in the conversion.

          <li>If there are multiple errors, the status value reflects only the first,
the smallest taking precedence.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: int <b>iauTf2d</b> (<var>char s, int ihour, int imin, double sec, double * days</var>)<var><a name="index-iauTf2d-139"></a></var><br>
<blockquote><p>Convert hours, minutes, seconds to days.

        <p>Status: support function.

        <p>Given:

     <pre class="example">          s         char    sign:  '-' = negative, otherwise positive
          ihour     int     hours
          imin      int     minutes
          sec       double  seconds
</pre>
        <p>Returned:

     <pre class="example">          days      double  interval in days
</pre>
        <p>Returned (function value):

     <pre class="example">          int     status:  0 = OK
                           1 = ihour outside range 0-23
                           2 = imin outside range 0-59
                           3 = sec outside range 0-59.999...
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The result is computed even if any of the range checks fail.

          <li>Negative <var>ihour</var>, <var>imin</var> and/or <var>sec</var> produce a warning
status, but the absolute value is used in the conversion.

          <li>If there are multiple errors, the status value reflects only the first,
the smallest taking precedence.
             </ol>
</p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-BuildRotations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-CopyExtendExtract">api CopyExtendExtract</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-AngleOps">api AngleOps</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-vector-matrix">api vector matrix</a>

</div>

<h4 class="subsection">5.2.2 Build rotations</h4>

<div class="defun">
&mdash; Function: void <b>iauRx</b> (<var>double phi, double r</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauRx-140"></a></var><br>
<blockquote><p>Rotate an <code>r</code>-matrix about the X-axis.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          phi    double          angle (radians)
</pre>
        <p>Given and returned:

     <pre class="example">          r      double[3][3]    r-matrix, rotated
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Calling this function with positive phi incorporates in the supplied
<code>r</code>-matrix <var>r</var> an additional rotation, about the X-axis,
anticlockwise as seen looking towards the origin from positive <var>x</var>.

          <li>The additional rotation can be represented by this matrix:

          <pre class="example">               (  1       0           0      )
               (  0   +cos(phi)   +sin(phi)  )
               (  0   -sin(phi)   +cos(phi)  )
</pre>
          </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauRy</b> (<var>double theta, double r</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauRy-141"></a></var><br>
<blockquote><p>Rotate an <code>r</code>-matrix about the Y-axis.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          theta  double          angle (radians)
</pre>
        <p>Given and returned:

     <pre class="example">          r      double[3][3]    r-matrix, rotated
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Calling this function with positive theta incorporates in the supplied
<code>r</code>-matrix <var>r</var> an additional rotation, about the Y-axis,
anticlockwise as seen looking towards the origin from positive Y.

          <li>The additional rotation can be represented by this matrix:

          <pre class="example">               (  +cos(theta)     0      -sin(theta)  )
               (      0           1          0        )
               (  +sin(theta)     0      +cos(theta)  )
</pre>
          </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauRz</b> (<var>double psi, double r</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauRz-142"></a></var><br>
<blockquote><p>Rotate an <code>r</code>-matrix about the Z-axis.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          psi    double          angle (radians)
</pre>
        <p>Given and returned:

     <pre class="example">          r      double[3][3]    r-matrix, rotated
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>Calling this function with positive psi incorporates in the supplied
<code>r</code>-matrix <var>r</var> an additional rotation, about the Z-axis,
anticlockwise as seen looking towards the origin from positive Z.

          <li>The additional rotation can be represented by this matrix:

          <pre class="example">               (  +cos(psi)   +sin(psi)    0  )
               (  -sin(psi)   +cos(psi)    0  )
               (      0           0        1  )
</pre>
          </ol>
</p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-CopyExtendExtract"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-Initialization">api Initialization</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-BuildRotations">api BuildRotations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-vector-matrix">api vector matrix</a>

</div>

<h4 class="subsection">5.2.3 Copy extend extract</h4>

<div class="defun">
&mdash; Function: void <b>iauCp</b> (<var>double p</var>[<var>3</var>]<var>, double c</var>[<var>3</var>])<var><a name="index-iauCp-143"></a></var><br>
<blockquote><p>Copy a <code>p</code>-vector.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          p        double[3]     p-vector to be copied
</pre>
        <p>Returned:

     <pre class="example">          c        double[3]     copy
</pre>
        </blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauCpv</b> (<var>double pv</var>[<var>2</var>][<var>3</var>]<var>, double c</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauCpv-144"></a></var><br>
<blockquote><p>Copy a position/velocity vector.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          pv     double[2][3]    position/velocity vector to be copied
</pre>
        <p>Returned:

     <pre class="example">          c      double[2][3]    copy
</pre>
        <p>Called:

          <dl>
<dt><code>iauCp</code><dd>Copy <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauCr</b> (<var>double r</var>[<var>3</var>][<var>3</var>]<var>, double c</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauCr-145"></a></var><br>
<blockquote><p>Copy an <code>r</code>-matrix.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          r        double[3][3]    r-matrix to be copied
</pre>
        <p>Returned:

     <pre class="example">          char[]     double[3][3]    copy
</pre>
        <p>Called:

          <dl>
<dt><code>iauCp</code><dd>Copy <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauP2pv</b> (<var>double p</var>[<var>3</var>]<var>, double pv</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauP2pv-146"></a></var><br>
<blockquote><p>Extend a <code>p</code>-vector to a <code>pv</code>-vector by appending a zero
velocity.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          p        double[3]       p-vector
</pre>
        <p>Returned:

     <pre class="example">          pv       double[2][3]    pv-vector
</pre>
        <p>Called:

          <dl>
<dt><code>iauCp</code><dd>Copy <code>p</code>-vector.

          <br><dt><code>iauZp</code><dd>Zero <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPv2p</b> (<var>double pv</var>[<var>2</var>][<var>3</var>]<var>, double p</var>[<var>3</var>])<var><a name="index-iauPv2p-147"></a></var><br>
<blockquote><p>Discard velocity component of a <var>pv</var>-vector.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          pv      double[2][3]     pv-vector
</pre>
        <p>Returned:

     <pre class="example">          p       double[3]        p-vector
</pre>
        <p>Called:

          <dl>
<dt><code>iauCp</code><dd>Copy <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-Initialization"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-MatrixOps">api MatrixOps</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-CopyExtendExtract">api CopyExtendExtract</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-vector-matrix">api vector matrix</a>

</div>

<h4 class="subsection">5.2.4 Initialization</h4>

<div class="defun">
&mdash; Function: void <b>iauIr</b> (<var>double r</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauIr-148"></a></var><br>
<blockquote><p>Initialize an <code>r</code>-matrix to the identity matrix.

        <p>Status: vector/matrix support function.

        <p>Returned:

     <pre class="example">          r       double[3][3]    r-matrix
</pre>
        </blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauZp</b> (<var>double p</var>[<var>3</var>])<var><a name="index-iauZp-149"></a></var><br>
<blockquote><p>Zero a <code>p</code>-vector.

        <p>Status: vector/matrix support function.

        <p>Returned:

     <pre class="example">          p        double[3]      p-vector
</pre>
        </blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauZpv</b> (<var>double pv</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauZpv-150"></a></var><br>
<blockquote><p>Zero a <code>pv</code>-vector.

        <p>Status: vector/matrix support function.

        <p>Returned:

     <pre class="example">          pv       double[2][3]      pv-vector
</pre>
        <p>Called:

          <dl>
<dt><code>iauZp</code><dd>Zero <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauZr</b> (<var>double r</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauZr-151"></a></var><br>
<blockquote><p>Initialize an <code>r</code>-matrix to the null matrix.

        <p>Status: vector/matrix support function.

        <p>Returned:

     <pre class="example">          r        double[3][3]    r-matrix
</pre>
        </blockquote></div>

<!-- page -->
<div class="node">
<a name="api-MatrixOps"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-MatrixVectorProducts">api MatrixVectorProducts</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-Initialization">api Initialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-vector-matrix">api vector matrix</a>

</div>

<h4 class="subsection">5.2.5 Matrix operations</h4>

<div class="defun">
&mdash; Function: void <b>iauRxr</b> (<var>double a</var>[<var>3</var>][<var>3</var>]<var>, double b</var>[<var>3</var>][<var>3</var>]<var>, double atb</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauRxr-152"></a></var><br>
<blockquote><p>Multiply two <code>r</code>-matrices.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a        double[3][3]    first r-matrix
          b        double[3][3]    second r-matrix
</pre>
        <p>Returned:

     <pre class="example">          atb      double[3][3]    a * b
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible to re-use the same array for any of the arguments.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauCr</code><dd>Copy <code>r</code>-matrix. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauTr</b> (<var>double r</var>[<var>3</var>][<var>3</var>]<var>, double rt</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauTr-153"></a></var><br>
<blockquote><p>Transpose an <code>r</code>-matrix.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          r        double[3][3]    r-matrix
</pre>
        <p>Returned:

     <pre class="example">          rt       double[3][3]    transpose
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible for <var>r</var> and <var>rt</var> to be the same array.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauCr</code><dd>Copy <code>r</code>-matrix. 
</dl>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-MatrixVectorProducts"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-RotationVectors">api RotationVectors</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-MatrixOps">api MatrixOps</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-vector-matrix">api vector matrix</a>

</div>

<h4 class="subsection">5.2.6 Matrix vector products</h4>

<div class="defun">
&mdash; Function: void <b>iauRxp</b> (<var>double r</var>[<var>3</var>][<var>3</var>]<var>, double p</var>[<var>3</var>]<var>, double rp</var>[<var>3</var>])<var><a name="index-iauRxp-154"></a></var><br>
<blockquote><p>Multiply a <code>p</code>-vector by an <code>r</code>-matrix.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          r        double[3][3]    r-matrix
          p        double[3]       p-vector
</pre>
        <p>Returned:

     <pre class="example">          rp       double[3]       r * p
</pre>
        <p>Notes:

          <ol type=1 start=1>
It is permissible for p and rp to be the same array.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauCp</code><dd>Copy <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauRxpv</b> (<var>double r</var>[<var>3</var>][<var>3</var>]<var>, double pv</var>[<var>2</var>][<var>3</var>]<var>, double rpv</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauRxpv-155"></a></var><br>
<blockquote><p>Multiply a <var>pv</var>-vector by an <code>r</code>-matrix.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          r        double[3][3]    r-matrix
          pv       double[2][3]    pv-vector
</pre>
        <p>Returned:

     <pre class="example">          rpv      double[2][3]    r * pv
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible for <var>pv</var> and <var>rpv</var> to be the same array.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauRxp</code><dd>Product of <code>r</code>-matrix and <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauTrxp</b> (<var>double r</var>[<var>3</var>][<var>3</var>]<var>, double p</var>[<var>3</var>]<var>, double trp</var>[<var>3</var>])<var><a name="index-iauTrxp-156"></a></var><br>
<blockquote><p>Multiply a <code>p</code>-vector by the transpose of an <code>r</code>-matrix.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          r        double[3][3]   r-matrix
          p        double[3]      p-vector
</pre>
        <p>Returned:

     <pre class="example">          trp      double[3]      r * p
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible for <var>p</var> and <var>trp</var> to be the same array.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauTr</code><dd>Transpose <code>r</code>-matrix.

          <br><dt><code>iauRxp</code><dd>Product of <code>r</code>-matrix and <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauTrxpv</b> (<var>double r</var>[<var>3</var>][<var>3</var>]<var>, double pv</var>[<var>2</var>][<var>3</var>]<var>, double trpv</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauTrxpv-157"></a></var><br>
<blockquote><p>Multiply a <var>pv</var>-vector by the transpose of an <code>r</code>-matrix.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          r        double[3][3]    r-matrix
          pv       double[2][3]    pv-vector
</pre>
        <p>Returned:

     <pre class="example">          trpv     double[2][3]    r * pv
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible for <var>pv</var> and <var>trpv</var> to be the same array.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauTr</code><dd>Transpose <code>r</code>-matrix.

          <br><dt><code>iauRxpv</code><dd>Product of <code>r</code>-matrix and <var>pv</var>-vector. 
</dl>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-RotationVectors"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-SeparationAndAngle">api SeparationAndAngle</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-MatrixVectorProducts">api MatrixVectorProducts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-vector-matrix">api vector matrix</a>

</div>

<h4 class="subsection">5.2.7 Rotation vectors</h4>

<div class="defun">
&mdash; Function: void <b>iauRm2v</b> (<var>double r</var>[<var>3</var>][<var>3</var>]<var>, double w</var>[<var>3</var>])<var><a name="index-iauRm2v-158"></a></var><br>
<blockquote><p>Express an <code>r</code>-matrix as an <code>r</code>-vector.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          r        double[3][3]    rotation matrix
</pre>
        <p>Returned:

     <pre class="example">          w        double[3]       rotation vector (Note 1)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>A rotation matrix describes a rotation through some angle about some
arbitrary axis called the Euler axis.  The &ldquo;rotation vector&rdquo; returned
by this function has the same direction as the Euler axis, and its
magnitude is the angle in radians.  (The magnitude and direction can be
separated by means of the function <code>iauPn</code>.)

          <li>If <var>r</var> is null, so is the result.  If <var>r</var> is not a rotation
matrix the result is undefined; <var>r</var> must be proper (i.e. have a
positive determinant) and real orthogonal (inverse = transpose).

          <li>The reference frame rotates clockwise as seen looking along the rotation
vector from the origin.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauRv2m</b> (<var>double w</var>[<var>3</var>]<var>, double r</var>[<var>3</var>][<var>3</var>])<var><a name="index-iauRv2m-159"></a></var><br>
<blockquote><p>Form the <code>r</code>-matrix corresponding to a given <code>r</code>-vector.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          w        double[3]      rotation vector (Note 1)
</pre>
        <p>Returned:

     <pre class="example">          r        double[3][3]    rotation matrix
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>A rotation matrix describes a rotation through some angle about some
arbitrary axis called the Euler axis.  The &ldquo;rotation vector&rdquo; supplied
to This function has the same direction as the Euler axis, and its
magnitude is the angle in radians.

          <li>If <var>w</var> is null, the unit matrix is returned.

          <li>The reference frame rotates clockwise as seen looking along the rotation
vector from the origin.
             </ol>
</p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-SeparationAndAngle"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-SphericalCartesian">api SphericalCartesian</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-RotationVectors">api RotationVectors</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-vector-matrix">api vector matrix</a>

</div>

<h4 class="subsection">5.2.8 Separation and angle</h4>

<div class="defun">
&mdash; Function: double <b>iauPap</b> (<var>double a</var>[<var>3</var>]<var>, double b</var>[<var>3</var>])<var><a name="index-iauPap-160"></a></var><br>
<blockquote><p>Position&ndash;angle from two <code>p</code>-vectors.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a      double[3]  direction of reference point
          b      double[3]  direction of point whose PA is required
</pre>
        <p>Returned (function value):

     <pre class="example">                 double     position angle of b with respect to a (radians)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The result is the position angle, in radians, of direction <var>b</var> with
respect to direction <var>a</var>.  It is in the range -pi to +pi.  The sense
is such that if <var>b</var> is a small distance &ldquo;north&rdquo; of <var>a</var> the
position angle is approximately zero, and if <var>b</var> is a small distance
&ldquo;east&rdquo; of <var>a</var> the position angle is approximately +pi/2.

          <li>The vectors <var>a</var> and <var>b</var> need not be of unit length.

          <li>Zero is returned if the two directions are the same or if either vector
is null.

          <li>If vector <var>a</var> is at a pole, the result is ill&ndash;defined.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPn</code><dd>Decompose <code>p</code>-vector into modulus and direction.

          <br><dt><code>iauPm</code><dd>Modulus of <code>p</code>-vector.

          <br><dt><code>iauPxp</code><dd>Vector product of two <code>p</code>-vectors.

          <br><dt><code>iauPmp</code><dd><code>p</code>-vector minus <code>p</code>-vector.

          <br><dt><code>iauPdp</code><dd>Scalar product of two <code>p</code>-vectors. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauPas</b> (<var>double al, double ap, double bl, double bp</var>)<var><a name="index-iauPas-161"></a></var><br>
<blockquote><p>Position&ndash;angle from spherical coordinates.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          al     double     longitude of point A (e.g. RA) in radians
          ap     double     latitude of point A (e.g. Dec) in radians
          bl     double     longitude of point B
          bp     double     latitude of point B
</pre>
        <p>Returned (function value):

     <pre class="example">                 double     position angle of B with respect to A
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>The result is the bearing (position angle), in radians, of point B with
respect to point A.  It is in the range -pi to +pi.  The sense is such
that if B is a small distance &ldquo;east&rdquo; of point A, the bearing is
approximately +pi/2.

          <li>Zero is returned if the two points are coincident.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauSepp</b> (<var>double a</var>[<var>3</var>]<var>, double b</var>[<var>3</var>])<var><a name="index-iauSepp-162"></a></var><br>
<blockquote><p>Angular separation between two <code>p</code>-vectors.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a      double[3]    first p-vector (not necessarily unit length)
          b      double[3]    second p-vector (not necessarily unit length)
</pre>
        <p>Returned (function value):

     <pre class="example">                 double       angular separation (radians, always positive)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>If either vector is null, a zero result is returned.

          <li>The angular separation is most simply formulated in terms of scalar
product.  However, this gives poor accuracy for angles near zero and
\pi.  The present algorithm uses both cross product and dot
product, to deliver full accuracy whatever the size of the angle.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPxp</code><dd>Vector product of two <code>p</code>-vectors.

          <br><dt><code>iauPm</code><dd>Modulus of <code>p</code>-vector.

          <br><dt><code>iauPdp</code><dd>Scalar product of two <code>p</code>-vectors. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauSeps</b> (<var>double al, double ap, double bl, double bp</var>)<var><a name="index-iauSeps-163"></a></var><br>
<blockquote><p>Angular separation between two sets of spherical coordinates.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          al     double       first longitude (radians)
          ap     double       first latitude (radians)
          bl     double       second longitude (radians)
          bp     double       second latitude (radians)
</pre>
        <p>Returned (function value):

     <pre class="example">                 double       angular separation (radians)
</pre>
        <p>Called:

          <dl>
<dt><code>iauS2c</code><dd>Spherical coordinates to unit vector.

          <br><dt><code>iauSepp</code><dd>Angular separation between two <code>p</code>-vectors. 
</dl>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-SphericalCartesian"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-VectorOps">api VectorOps</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-SeparationAndAngle">api SeparationAndAngle</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-vector-matrix">api vector matrix</a>

</div>

<h4 class="subsection">5.2.9 Spherical cartesian</h4>

<div class="defun">
&mdash; Function: void <b>iauC2s</b> (<var>double p</var>[<var>3</var>]<var>, double * theta, double * phi</var>)<var><a name="index-iauC2s-164"></a></var><br>
<blockquote><p><code>p</code>-vector to spherical coordinates.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          p      double[3]    p-vector
</pre>
        <p>Returned:

          <dl>
theta  double       longitude angle (radians)
phi    double       latitude angle (radians)
</dl>

        <p>Notes:

          <ol type=1 start=1>
<li>The vector <var>p</var> can have any magnitude; only its direction is used.

          <li>If <var>p</var> is null, zero <var>theta</var> and <var>phi</var> are returned.

          <li>At either pole, zero <var>theta</var> is returned.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauP2s</b> (<var>double p</var>[<var>3</var>]<var>, double * theta, double * phi, double * r</var>)<var><a name="index-iauP2s-165"></a></var><br>
<blockquote><p><code>p</code>-vector to spherical polar coordinates.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          p        double[3]    p-vector
</pre>
        <p>Returned:

     <pre class="example">          theta    double       longitude angle (radians)
          phi      double       latitude angle (radians)
          r        double       radial distance
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>If <var>p</var> is null, zero <var>theta</var>, <var>phi</var> and <var>r</var> are
returned.

          <li>At either pole, zero <var>theta</var> is returned.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauC2s</code><dd><code>p</code>-vector to spherical.

          <br><dt><code>iauPm</code><dd>Modulus of <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPv2s</b> (<var>double pv</var>[<var>2</var>][<var>3</var>]<var>, double * theta, double * phi, double * r, double * td, double * pd, double * rd</var>)<var><a name="index-iauPv2s-166"></a></var><br>
<blockquote><p>Convert position/velocity from Cartesian to spherical coordinates.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          pv       double[2][3]  pv-vector
</pre>
        <p>Returned:

     <pre class="example">          theta    double        longitude angle (radians)
          phi      double        latitude angle (radians)
          r        double        radial distance
          td       double        rate of change of theta
          pd       double        rate of change of phi
          rd       double        rate of change of r
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>If the position part of <var>pv</var> is null, <var>theta</var>, <var>phi</var>,
<var>td</var> and <var>pd</var> are indeterminate.  This is handled by
extrapolating the position through unit time by using the velocity part
of <var>pv</var>.  This moves the origin without changing the direction of
the velocity component.  If the position and velocity components of pv
are both null, zeroes are returned for all six results.

          <li>If the position is a pole, <var>theta</var>, <var>td</var> and <var>pd</var> are
indeterminate.  In such cases zeroes are returned for all three.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauS2c</b> (<var>double theta, double phi, double c</var>[<var>3</var>])<var><a name="index-iauS2c-167"></a></var><br>
<blockquote><p>Convert spherical coordinates to Cartesian.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          theta    double       longitude angle (radians)
          phi      double       latitude angle (radians)
</pre>
        <p>Returned:

     <pre class="example">          c        double[3]    direction cosines
</pre>
        </blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauS2p</b> (<var>double theta, double phi, double r, double p</var>[<var>3</var>])<var><a name="index-iauS2p-168"></a></var><br>
<blockquote><p>Convert spherical polar coordinates to <code>p</code>-vector.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          theta   double       longitude angle (radians)
          phi     double       latitude angle (radians)
          r       double       radial distance
</pre>
        <p>Returned:

     <pre class="example">          p       double[3]    Cartesian coordinates
</pre>
        <p>Called:

          <dl>
<dt><code>iauS2c</code><dd>Spherical coordinates to unit vector.

          <br><dt><code>iauSxp</code><dd>Multiply <code>p</code>-vector by scalar. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauS2pv</b> (<var>double theta, double phi, double r, double td, double pd, double rd, double pv</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauS2pv-169"></a></var><br>
<blockquote><p>Convert position/velocity from spherical to Cartesian coordinates.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          theta    double          longitude angle (radians)
          phi      double          latitude angle (radians)
          r        double          radial distance
          td       double          rate of change of theta
          pd       double          rate of change of phi
          rd       double          rate of change of r
</pre>
        <p>Returned:

     <pre class="example">          pv       double[2][3]    pv-vector
</pre>
        </blockquote></div>

<!-- page -->
<div class="node">
<a name="api-VectorOps"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-SphericalCartesian">api SphericalCartesian</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-vector-matrix">api vector matrix</a>

</div>

<h4 class="subsection">5.2.10 Vector operations</h4>

<div class="defun">
&mdash; Function: double <b>iauPdp</b> (<var>double a</var>[<var>3</var>]<var>, double b</var>[<var>3</var>])<var><a name="index-iauPdp-170"></a></var><br>
<blockquote><p><code>p</code>-vector inner (=scalar=dot) product.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a      double[3]     first p-vector
          b      double[3]     second p-vector
</pre>
        <p>Returned (function value):

     <pre class="example">                 double        a . b
</pre>
        </blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: double <b>iauPm</b> (<var>double p</var>[<var>3</var>])<var><a name="index-iauPm-171"></a></var><br>
<blockquote><p>Modulus of <code>p</code>-vector.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          p      double[3]     p-vector
</pre>
        <p>Returned (function value):

     <pre class="example">                 double        modulus
</pre>
        </blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPmp</b> (<var>double a</var>[<var>3</var>]<var>, double b</var>[<var>3</var>]<var>, double amb</var>[<var>3</var>])<var><a name="index-iauPmp-172"></a></var><br>
<blockquote><p><code>p</code>-vector subtraction.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a        double[3]      first p-vector
          b        double[3]      second p-vector
</pre>
        <p>Returned:

     <pre class="example">          amb      double[3]      a - b
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible to re-use the same array for any of the arguments.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPn</b> (<var>double p</var>[<var>3</var>]<var>, double * r, double u</var>[<var>3</var>])<var><a name="index-iauPn-173"></a></var><br>
<blockquote><p>Convert a <code>p</code>-vector into modulus and unit vector.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          p        double[3]      p-vector
</pre>
        <p>Returned:

     <pre class="example">          r        double         modulus
          u        double[3]      unit vector
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>If <var>p</var> is null, the result is null.  Otherwise the result is a unit
vector.

          <li>It is permissible to re-use the same array for any of the arguments.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPm</code><dd>Modulus of <code>p</code>-vector.

          <br><dt><code>iauZp</code><dd>Zero <code>p</code>-vector.

          <br><dt><code>iauSxp</code><dd>Multiply <code>p</code>-vector by scalar. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPpp</b> (<var>double a</var>[<var>3</var>]<var>, double b</var>[<var>3</var>]<var>, double apb</var>[<var>3</var>])<var><a name="index-iauPpp-174"></a></var><br>
<blockquote><p><code>p</code>-vector addition.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">             a        double[3]      first p-vector
             b        double[3]      second p-vector
</pre>
        <p>Returned:

     <pre class="example">             apb      double[3]      a + b
</pre>
        <p>Notes:

          <ol type=1 start=1>
It is permissible to re-use the same array for any of the arguments.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPpsp</b> (<var>double a</var>[<var>3</var>]<var>, double s, double b</var>[<var>3</var>]<var>, double apsb</var>[<var>3</var>])<var><a name="index-iauPpsp-175"></a></var><br>
<blockquote><p><code>p</code>-vector plus scaled <code>p</code>-vector.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a      double[3]     first p-vector
          s      double        scalar (multiplier for b)
          b      double[3]     second p-vector
</pre>
        <p>Returned:

     <pre class="example">          apsb   double[3]     a + s*b
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible for any of <var>a</var>, <var>b</var> and <var>apsb</var> to be the
same array.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauSxp</code><dd>Multiply <code>p</code>-vector by scalar.

          <br><dt><code>iauPpp</code><dd><code>p</code>-vector plus <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPvdpv</b> (<var>double a</var>[<var>2</var>][<var>3</var>]<var>, double b</var>[<var>2</var>][<var>3</var>]<var>, double adb</var>[<var>2</var>])<var><a name="index-iauPvdpv-176"></a></var><br>
<blockquote><p>Inner (=scalar=dot) product of two <var>pv</var>-vectors.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a        double[2][3]      first pv-vector
          b        double[2][3]      second pv-vector
</pre>
        <p>Returned:

     <pre class="example">          adb      double[2]         a . b (see note)
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>If the position and velocity components of the two <var>pv</var>-vectors are
<code>(ap, av)</code> and <code>(bp, bv)</code>, the result, <var>a</var><code> *
</code><var>b</var>, is the pair of numbers <code>(ap * bp, ap * bv + av bp)</code>.  The
two numbers are the dot&ndash;product of the two <code>p</code>-vectors and its
derivative.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPdp</code><dd>Scalar product of two <code>p</code>-vectors. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPvm</b> (<var>double pv</var>[<var>2</var>][<var>3</var>]<var>, double * r, double * s</var>)<var><a name="index-iauPvm-177"></a></var><br>
<blockquote><p>Modulus of <var>pv</var>-vector.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          pv     double[2][3]   pv-vector
</pre>
        <p>Returned:

     <pre class="example">          r      double         modulus of position component
          s      double         modulus of velocity component
</pre>
        <p>Called:

          <dl>
<dt><code>iauPm</code><dd>Modulus of <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPvmpv</b> (<var>double a</var>[<var>2</var>][<var>3</var>]<var>, double b</var>[<var>2</var>][<var>3</var>]<var>, double amb</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauPvmpv-178"></a></var><br>
<blockquote><p>Subtract one <var>pv</var>-vector from another.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a       double[2][3]      first pv-vector
          b       double[2][3]      second pv-vector
</pre>
        <p>Returned:

     <pre class="example">          amb     double[2][3]      a - b
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible to re-use the same array for any of the arguments.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPmp</code><dd><code>p</code>-vector minus <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPvppv</b> (<var>double a</var>[<var>2</var>][<var>3</var>]<var>, double b</var>[<var>2</var>][<var>3</var>]<var>, double apb</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauPvppv-179"></a></var><br>
<blockquote><p>Add one <var>pv</var>-vector to another.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a        double[2][3]      first pv-vector
          b        double[2][3]      second pv-vector
</pre>
        <p>Returned:

     <pre class="example">          apb      double[2][3]      a + b
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible to re-use the same array for any of the arguments.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPpp</code><dd><code>p</code>-vector plus <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPvu</b> (<var>double dt, double pv</var>[<var>2</var>][<var>3</var>]<var>, double upv</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauPvu-180"></a></var><br>
<blockquote><p>Update a <var>pv</var>-vector.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          dt       double           time interval
          pv       double[2][3]     pv-vector
</pre>
        <p>Returned:

     <pre class="example">          upv      double[2][3]     p updated, v unchanged
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>&ldquo;Update&rdquo; means &ldquo;refer the position component of the vector to a new
date <var>dt</var> time units from the existing date&rdquo;.

          <li>The time units of <var>dt</var> must match those of the velocity.

          <li>It is permissible for <var>pv</var> and <var>upv</var> to be the same array.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauPpsp</code><dd><code>p</code>-vector plus scaled <code>p</code>-vector.

          <br><dt><code>iauCp</code><dd>Copy <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPvup</b> (<var>double dt, double pv</var>[<var>2</var>][<var>3</var>]<var>, double p</var>[<var>3</var>])<var><a name="index-iauPvup-181"></a></var><br>
<blockquote><p>Update a <var>pv</var>-vector, discarding the velocity component.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          dt       double            time interval
          pv       double[2][3]      pv-vector
</pre>
        <p>Returned:

     <pre class="example">          p        double[3]         p-vector
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>&ldquo;Update&rdquo; means &ldquo;refer the position component of the vector to a new
date <var>dt</var> time units from the existing date&rdquo;.

          <li>The time units of <var>dt</var> must match those of the velocity.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPvxpv</b> (<var>double a</var>[<var>2</var>][<var>3</var>]<var>, double b</var>[<var>2</var>][<var>3</var>]<var>, double axb</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauPvxpv-182"></a></var><br>
<blockquote><p>Outer (=vector=cross) product of two <var>pv</var>-vectors.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a        double[2][3]      first pv-vector
          b        double[2][3]      second pv-vector
</pre>
        <p>Returned:

     <pre class="example">          axb      double[2][3]      a x b
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>If the position and velocity components of the two <var>pv</var>-vectors are
<code>(ap, av)</code> and <code>(bp, bv)</code>, the result, <code>a x b</code>, is the
pair of vectors <code>(ap x bp, ap x bv + av x bp)</code>.  The two vectors
are the cross&ndash;product of the two <code>p</code>-vectors and its derivative.

          <li>It is permissible to re-use the same array for any of the arguments.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauCpv</code><dd>Copy <code>pv</code>-vector.

          <br><dt><code>iauPxp</code><dd>Vector product of two <code>p</code>-vectors.

          <br><dt><code>iauPpp</code><dd><code>p</code>-vector plus <code>p</code>-vector. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauPxp</b> (<var>double a</var>[<var>3</var>]<var>, double b</var>[<var>3</var>]<var>, double axb</var>[<var>3</var>])<var><a name="index-iauPxp-183"></a></var><br>
<blockquote><p><code>p</code>-vector outer (=vector=cross) product.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          a        double[3]      first p-vector
          b        double[3]      second p-vector
</pre>
        <p>Returned:

     <pre class="example">          axb      double[3]      a x b
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible to re-use the same array for any of the arguments.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauS2xpv</b> (<var>double s1, double s2, double pv</var>[<var>2</var>][<var>3</var>]<var>, double spv</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauS2xpv-184"></a></var><br>
<blockquote><p>Multiply a <var>pv</var>-vector by two scalars.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          s1     double         scalar to multiply position component by
          s2     double         scalar to multiply velocity component by
          pv     double[2][3]   pv-vector
</pre>
        <p>Returned:

     <pre class="example">          spv    double[2][3]   pv-vector: p scaled by s1, v scaled by s2
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible for <var>pv</var> and <var>spv</var> to be the same array.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauSxp</code><dd>Multiply <code>p</code>-vector by scalar. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauSxp</b> (<var>double s, double p</var>[<var>3</var>]<var>, double sp</var>[<var>3</var>])<var><a name="index-iauSxp-185"></a></var><br>
<blockquote><p>Multiply a <code>p</code>-vector by a scalar.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          s      double        scalar
          p      double[3]     p-vector
</pre>
        <p>Returned:

     <pre class="example">          sp     double[3]     s * p
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible for <var>p</var> and <var>sp</var> to be the same array.
             </ol>
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void <b>iauSxpv</b> (<var>double s, double pv</var>[<var>2</var>][<var>3</var>]<var>, double spv</var>[<var>2</var>][<var>3</var>])<var><a name="index-iauSxpv-186"></a></var><br>
<blockquote><p>Multiply a <var>pv</var>-vector by a scalar.

        <p>Status: vector/matrix support function.

        <p>Given:

     <pre class="example">          s       double          scalar
          pv      double[2][3]    pv-vector
</pre>
        <p>Returned:

     <pre class="example">          spv     double[2][3]    s * pv
</pre>
        <p>Notes:

          <ol type=1 start=1>
<li>It is permissible for <var>pv</var> and <var>psv</var> to be the same array.
             </ol>

        <p>Called:

          <dl>
<dt><code>iauS2xpv</code><dd>Multiply <var>pv</var>-vector by two scalars. 
</dl>
        </p></blockquote></div>

<!-- page -->
<div class="node">
<a name="api-consts-fortran"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-consts-c">api consts c</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-vector-matrix">api vector matrix</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">5.3 Fortran language constants</h3>

<p>These must be used exactly as presented below.

     <dl>
<dt>Pi<dd>
     <pre class="example">          DOUBLE PRECISION DPI
          PARAMETER ( DPI = 3.141592653589793238462643D0 )
</pre>
     <br><dt>2Pi<dd>
     <pre class="example">          DOUBLE PRECISION D2PI
          PARAMETER ( D2PI = 6.283185307179586476925287D0 )
</pre>
     <br><dt>Radians to hours<dd>
     <pre class="example">          DOUBLE PRECISION DR2H
          PARAMETER ( DR2H = 3.819718634205488058453210D0 )
</pre>
     <br><dt>Radians to seconds<dd>
     <pre class="example">          DOUBLE PRECISION DR2S
          PARAMETER ( DR2S = 13750.98708313975701043156D0 )
</pre>
     <br><dt>Radians to degrees<dd>
     <pre class="example">          DOUBLE PRECISION DR2D
          PARAMETER ( DR2D = 57.29577951308232087679815D0 )
</pre>
     <br><dt>Radians to arc seconds<dd>
     <pre class="example">          DOUBLE PRECISION DR2AS
          PARAMETER ( DR2AS = 206264.8062470963551564734D0 )
</pre>
     <br><dt>Hours to radians<dd>
     <pre class="example">          DOUBLE PRECISION DH2R
          PARAMETER ( DH2R = 0.2617993877991494365385536D0 )
</pre>
     <br><dt>Seconds to radians<dd>
     <pre class="example">          DOUBLE PRECISION DS2R
          PARAMETER ( DS2R = 7.272205216643039903848712D-5 )
</pre>
     <br><dt>Degrees to radians<dd>
     <pre class="example">          DOUBLE PRECISION DD2R
          PARAMETER ( DD2R = 1.745329251994329576923691D-2 )
</pre>
     <br><dt>Arc seconds to radians<dd>
     <pre class="example">          DOUBLE PRECISION DAS2R
          PARAMETER ( DAS2R = 4.848136811095359935899141D-6 )
</pre>
     </dl>

<!-- page -->
<div class="node">
<a name="api-consts-c"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-consts-fortran">api consts fortran</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">5.4 C language constants</h3>

<p>The constants used by the C version of <acronym>SOFA</acronym> are defined in the header
file <samp><span class="file">sofam.h</span></samp>.

<div class="defun">
&mdash; Constant: <b>DPI</b><var><a name="index-DPI-187"></a></var><br>
<blockquote><p>Pi. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>D2PI</b><var><a name="index-D2PI-188"></a></var><br>
<blockquote><p>Twice pi. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DD2R</b><var><a name="index-DD2R-189"></a></var><br>
<blockquote><p>Degrees to radians. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DR2AS</b><var><a name="index-DR2AS-190"></a></var><br>
<blockquote><p>Radians to arcseconds. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DAS2R</b><var><a name="index-DAS2R-191"></a></var><br>
<blockquote><p>Arcseconds to radians. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DS2R</b><var><a name="index-DS2R-192"></a></var><br>
<blockquote><p>Seconds of time to radians. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>TURNAS</b><var><a name="index-TURNAS-193"></a></var><br>
<blockquote><p>Arcseconds in a full circle. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DMAS2R</b><var><a name="index-DMAS2R-194"></a></var><br>
<blockquote><p>Milliarcseconds to radians. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DTY</b><var><a name="index-DTY-195"></a></var><br>
<blockquote><p>Length of tropical year B1900 (days). 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DAYSEC</b><var><a name="index-DAYSEC-196"></a></var><br>
<blockquote><p>Seconds per day.. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DJY</b><var><a name="index-DJY-197"></a></var><br>
<blockquote><p>Days per Julian year. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DJC</b><var><a name="index-DJC-198"></a></var><br>
<blockquote><p>Days per Julian century. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DJM</b><var><a name="index-DJM-199"></a></var><br>
<blockquote><p>Days per Julian millennium. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DJ00</b><var><a name="index-DJ00-200"></a></var><br>
<blockquote><p>Reference epoch (J2000.0), Julian Date. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DJM0</b><var><a name="index-DJM0-201"></a></var><br>
<blockquote><p>Julian Date of Modified Julian Date zero. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DJM00</b><var><a name="index-DJM00-202"></a></var><br>
<blockquote><p>Reference epoch (J2000.0), Modified Julian Date. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DJM77</b><var><a name="index-DJM77-203"></a></var><br>
<blockquote><p>1977 Jan 1.0 as MJD. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>TTMTAI</b><var><a name="index-TTMTAI-204"></a></var><br>
<blockquote><p>TT minus TAI (s). 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DAU</b><var><a name="index-DAU-205"></a></var><br>
<blockquote><p>AU (m). 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>DC</b><var><a name="index-DC-206"></a></var><br>
<blockquote><p>Speed of light (AU per day). 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>ELG</b><var><a name="index-ELG-207"></a></var><br>
<blockquote><p>L_G = 1 - d(TT)/d(TCG). 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>ELB</b><var><a name="index-ELB-208"></a></var><br>
&mdash; constant: <b>TDB0</b><var><a name="index-TDB0-209"></a></var><br>
<blockquote><p><code>L_B = 1 - d(TDB)/d(TCB)</code> and TDB (s) at TAI 1977/1/1.0. 
</p></blockquote></div>

<div class="defun">
&mdash; Constant: <b>WGS84</b><var><a name="index-WGS84-210"></a></var><br>
&mdash; Constant: <b>GRS80</b><var><a name="index-GRS80-211"></a></var><br>
&mdash; Constant: <b>WGS72</b><var><a name="index-WGS72-212"></a></var><br>
<blockquote><p>Reference ellipsoids. 
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Preprocessor Macro: double <b>dint</b> (<var>double A</var>)<var><a name="index-dint-213"></a></var><br>
<blockquote><p>Truncate to nearest whole number towards zero (double). 
</p></blockquote></div>

<div class="defun">
&mdash; Preprocessor Macro: double <b>dnint</b> (<var>double A</var>)<var><a name="index-dnint-214"></a></var><br>
<blockquote><p>Round to nearest whole number. 
</p></blockquote></div>

<div class="defun">
&mdash; Preprocessor Macro: double <b>dsign</b> (<var>double A, double B</var>)<var><a name="index-dsign-215"></a></var><br>
<blockquote><p>Magnitude of <var>A</var> with sign of <var>B</var>. 
</p></blockquote></div>

<!-- page -->
<div class="node">
<a name="board"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#license">license</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api">api</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix A <acronym>IAU</acronym> Standards of Fundamental Astronomy Board</h2>

<p>Current membership:

     <dl>
<dt>John Bangert<dd>United States Naval Observatory.

     <br><dt>Steven Bell<dd>Her Majesty's Nautical Almanac Office.

     <br><dt>Mark Calabretta<dd>Australia Telescope National Facility.

     <br><dt>Nicole Capitaine<dd>Paris Observatory.

     <br><dt>William Folkner<dd>Jet Propulsion Laboratory.

     <br><dt>George Hobbs<dd>Australia Telescope National Facility.

     <br><dt>Catherine Hohenkerk<dd>Her Majesty's Nautical Almanac Office (Chair).

     <br><dt>Wen-Jing Jin<dd>Shanghai Observatory.

     <br><dt>Brian Luzum<dd>United States Naval Observatory (<acronym>IERS</acronym>).

     <br><dt>Zinovy Malkin<dd>Pulkovo Observatory, St Petersburg.

     <br><dt>Jeffrey Percival<dd>University of Wisconsin.

     <br><dt>Patrick Wallace<dd>Rutherford Appleton Laboratory. 
</dl>

   <p>Past members:

     <dl>
<dt>Wim Brouw<dd>University of Groningen.

     <br><dt>Anne-Marie Gontier<dd>Paris Observatory.

     <br><dt>George Kaplan<dd>United States Naval Observatory.

     <br><dt>Dennis McCarthy<dd>United States Naval Observatory.

     <br><dt>Skip Newhall<dd>Jet Propulsion Laboratory. 
</dl>

   <p>The e-mail for the Board chair is <a href="mailto:Catherine.Hohenkerk@ukho.gov.uk">Catherine.Hohenkerk@ukho.gov.uk</a>.

<!-- page -->
<div class="node">
<a name="license"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#references">references</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#board">board</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix B Package license</h2>

<p>The copyright of the <acronym>SOFA</acronym> Software belongs to the Standards Of
Fundamental Astronomy Board of the International Astronomical Union.

<!--  -->
<h3 class="appendixsec">B.1 <acronym>SOFA</acronym> Software License</h3>

<p>By using this software you accept the following six terms and conditions
which apply to its use.

     <ol type=1 start=1>
<li>The Software is owned by the <acronym>IAU</acronym> <acronym>SOFA</acronym> Board (&ldquo;<acronym>SOFA</acronym>&rdquo;).

     <li>Permission is granted to anyone to use the <acronym>SOFA</acronym> software for any
purpose, including commercial applications, free of charge and without
payment of royalties, subject to the conditions and restrictions listed
below.

     <li>You (the user) may copy and distribute <acronym>SOFA</acronym> source code to others,
and use and adapt its code and algorithms in your own software, on a
world&ndash;wide, royalty&ndash;free basis.  That portion of your distribution
that does not consist of intact and unchanged copies of <acronym>SOFA</acronym> source
code files is a &ldquo;derived work&rdquo; that must comply with the following
requirements:

          <ul>
<li>Your work shall be marked or carry a statement that it (i) uses routines
and computations derived by you from software provided by <acronym>SOFA</acronym> under
license to you; and (ii) does not itself constitute software provided by
and/or endorsed by <acronym>SOFA</acronym>.

          <li>The source code of your derived work must contain descriptions of how
the derived work is based upon, contains and/or differs from the
original <acronym>SOFA</acronym> software.

          <li>The names of all routines in your derived work shall not include the
prefix <code>iau</code> or <code>sofa</code> or trivial modifications thereof such
as changes of case.

          <li>The origin of the <acronym>SOFA</acronym> components of your derived work must not be
misrepresented; you must not claim that you wrote the original software,
nor file a patent application for <acronym>SOFA</acronym> software or algorithms
embedded in the <acronym>SOFA</acronym> software.

          <li>These requirements must be reproduced intact in any source distribution
and shall apply to anyone to whom you have granted a further right to
modify the source code of your derived work. 
</ul>

     <p>Note that, as originally distributed, the <acronym>SOFA</acronym> software is intended
to be a definitive implementation of the <acronym>IAU</acronym> standards, and
consequently third&ndash;party modifications are discouraged.  All
variations, no matter how minor, must be explicitly marked as such, as
explained above.

     <li>You shall not cause the <acronym>SOFA</acronym> software to be brought into disrepute,
either by misuse, or use for inappropriate tasks, or by inappropriate
modification.

     <li>The <acronym>SOFA</acronym> software is provided &ldquo;as is&rdquo; and <acronym>SOFA</acronym> makes no warranty
as to its use or performance.  <acronym>SOFA</acronym> does not and cannot warrant the
performance or results which the user may obtain by using the <acronym>SOFA</acronym>
software.  <acronym>SOFA</acronym> makes no warranties, express or implied, as to
non-infringement of third party rights, merchantability, or fitness for
any particular purpose.  In no event will <acronym>SOFA</acronym> be liable to the user
for any consequential, incidental, or special damages, including any
lost profits or lost savings, even if a <acronym>SOFA</acronym> representative has been
advised of such damages, or for any claim by any third party.

     <li>The provision of any version of the <acronym>SOFA</acronym> software under the terms and
conditions specified herein does not imply that future versions will
also be made available under the same terms and conditions.
        </ol>

   <p>Correspondence concerning <acronym>SOFA</acronym> software should be addressed as follows:

     <ul>
<li>By e-mail: <a href="mailto:sofa@ukho.gov.uk">sofa@ukho.gov.uk</a>.

     <li>By post:

     <blockquote>
IAU <acronym>SOFA</acronym> Center<br>
HM Nautical Almanac Office<br>
UK Hydrographic Office<br>
Admiralty Way<br>
Taunton, TA1 2DN<br>
United Kingdom
</blockquote>
     </ul>

<!--  -->
<h3 class="appendixsec">B.2 Acknowledgement &amp; Citation for <acronym>SOFA</acronym></h3>

<p>If your use of <acronym>SOFA</acronym> results in a publication, presentation or
product, please include a citation.  Evidence of your use of the <acronym>SOFA</acronym>
libraries is necessary to ensure continuing support of the initiative.

   <p>The following is a suitable form of words: &ldquo;Software Routines from the
IAU <acronym>SOFA</acronym> Collection were used.  Copyright &copy; International
Astronomical Union Standards of Fundamental Astronomy
(<a href="http://www.iausofa.org">http://www.iausofa.org</a>)&rdquo;.

<!-- page -->
<div class="node">
<a name="references"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#concept-index">concept index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#license">license</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix C Bibliography and references</h2>

<!-- page -->
<div class="node">
<a name="concept-index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#function-index">function index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#references">references</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix D An entry for each concept</h2>

<ul class="index-cp" compact>
</ul><div class="node">
<a name="function-index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#variable-index">variable index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#concept-index">concept index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix E An entry for each function.</h2>



<ul class="index-fn" compact>
<li><a href="#index-dint-213"><code>dint</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-dnint-214"><code>dnint</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-dsign-215"><code>dsign</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-iauA2af-132"><code>iauA2af</code></a>: <a href="#api-AngleOps">api AngleOps</a></li>
<li><a href="#index-iauA2tf-133"><code>iauA2tf</code></a>: <a href="#api-AngleOps">api AngleOps</a></li>
<li><a href="#index-iauAf2a-134"><code>iauAf2a</code></a>: <a href="#api-AngleOps">api AngleOps</a></li>
<li><a href="#index-iauAnp-135"><code>iauAnp</code></a>: <a href="#api-AngleOps">api AngleOps</a></li>
<li><a href="#index-iauAnpm-136"><code>iauAnpm</code></a>: <a href="#api-AngleOps">api AngleOps</a></li>
<li><a href="#index-iauBi00-24"><code>iauBi00</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauBp00-25"><code>iauBp00</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauBp06-26"><code>iauBp06</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauBpn2xy-27"><code>iauBpn2xy</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2i00a-28"><code>iauC2i00a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2i00b-29"><code>iauC2i00b</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2i06a-30"><code>iauC2i06a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2ibpn-31"><code>iauC2ibpn</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2ixy-32"><code>iauC2ixy</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2ixys-33"><code>iauC2ixys</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2s-164"><code>iauC2s</code></a>: <a href="#api-SphericalCartesian">api SphericalCartesian</a></li>
<li><a href="#index-iauC2t00a-34"><code>iauC2t00a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2t00b-35"><code>iauC2t00b</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2t06a-36"><code>iauC2t06a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2tcio-37"><code>iauC2tcio</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2teqx-38"><code>iauC2teqx</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2tpe-39"><code>iauC2tpe</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauC2txy-40"><code>iauC2txy</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauCal2jd-1"><code>iauCal2jd</code></a>: <a href="#api-Calendars">api Calendars</a></li>
<li><a href="#index-iauCp-143"><code>iauCp</code></a>: <a href="#api-CopyExtendExtract">api CopyExtendExtract</a></li>
<li><a href="#index-iauCpv-144"><code>iauCpv</code></a>: <a href="#api-CopyExtendExtract">api CopyExtendExtract</a></li>
<li><a href="#index-iauCr-145"><code>iauCr</code></a>: <a href="#api-CopyExtendExtract">api CopyExtendExtract</a></li>
<li><a href="#index-iauD2dtf-112"><code>iauD2dtf</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauD2tf-137"><code>iauD2tf</code></a>: <a href="#api-AngleOps">api AngleOps</a></li>
<li><a href="#index-iauDat-113"><code>iauDat</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauDtdb-114"><code>iauDtdb</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauDtf2d-115"><code>iauDtf2d</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauEe00-84"><code>iauEe00</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauEe00a-85"><code>iauEe00a</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauEe00b-86"><code>iauEe00b</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauEe06a-87"><code>iauEe06a</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauEect00-88"><code>iauEect00</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauEform-107"><code>iauEform</code></a>: <a href="#api-Geodetic_002fGeocentric">api Geodetic/Geocentric</a></li>
<li><a href="#index-iauEo06a-41"><code>iauEo06a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauEors-42"><code>iauEors</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauEpb-2"><code>iauEpb</code></a>: <a href="#api-Calendars">api Calendars</a></li>
<li><a href="#index-iauEpb2jd-3"><code>iauEpb2jd</code></a>: <a href="#api-Calendars">api Calendars</a></li>
<li><a href="#index-iauEpj-4"><code>iauEpj</code></a>: <a href="#api-Calendars">api Calendars</a></li>
<li><a href="#index-iauEpj2jd-5"><code>iauEpj2jd</code></a>: <a href="#api-Calendars">api Calendars</a></li>
<li><a href="#index-iauEpv00-8"><code>iauEpv00</code></a>: <a href="#api-Ephemerides">api Ephemerides</a></li>
<li><a href="#index-iauEqeq94-89"><code>iauEqeq94</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauEra00-90"><code>iauEra00</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauFad03-10"><code>iauFad03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFae03-11"><code>iauFae03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFaf03-12"><code>iauFaf03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFaju03-13"><code>iauFaju03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFal03-14"><code>iauFal03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFalp03-15"><code>iauFalp03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFama03-16"><code>iauFama03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFame03-17"><code>iauFame03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFane03-18"><code>iauFane03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFaom03-19"><code>iauFaom03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFapa03-20"><code>iauFapa03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFasa03-21"><code>iauFasa03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFaur03-22"><code>iauFaur03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFave03-23"><code>iauFave03</code></a>: <a href="#api-FundamentalArgs">api FundamentalArgs</a></li>
<li><a href="#index-iauFk52h-101"><code>iauFk52h</code></a>: <a href="#api-StarCatalogs">api StarCatalogs</a></li>
<li><a href="#index-iauFk5hip-102"><code>iauFk5hip</code></a>: <a href="#api-StarCatalogs">api StarCatalogs</a></li>
<li><a href="#index-iauFk5hz-103"><code>iauFk5hz</code></a>: <a href="#api-StarCatalogs">api StarCatalogs</a></li>
<li><a href="#index-iauFw2m-43"><code>iauFw2m</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauFw2xy-44"><code>iauFw2xy</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauGc2gd-108"><code>iauGc2gd</code></a>: <a href="#api-Geodetic_002fGeocentric">api Geodetic/Geocentric</a></li>
<li><a href="#index-iauGc2gde-109"><code>iauGc2gde</code></a>: <a href="#api-Geodetic_002fGeocentric">api Geodetic/Geocentric</a></li>
<li><a href="#index-iauGd2gc-110"><code>iauGd2gc</code></a>: <a href="#api-Geodetic_002fGeocentric">api Geodetic/Geocentric</a></li>
<li><a href="#index-iauGd2gce-111"><code>iauGd2gce</code></a>: <a href="#api-Geodetic_002fGeocentric">api Geodetic/Geocentric</a></li>
<li><a href="#index-iauGmst00-91"><code>iauGmst00</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauGmst06-92"><code>iauGmst06</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauGmst82-93"><code>iauGmst82</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauGst00a-94"><code>iauGst00a</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauGst00b-95"><code>iauGst00b</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauGst06-96"><code>iauGst06</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauGst06a-97"><code>iauGst06a</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauGst94-98"><code>iauGst94</code></a>: <a href="#api-RotationAndTime">api RotationAndTime</a></li>
<li><a href="#index-iauH2fk5-104"><code>iauH2fk5</code></a>: <a href="#api-StarCatalogs">api StarCatalogs</a></li>
<li><a href="#index-iauHfk5z-105"><code>iauHfk5z</code></a>: <a href="#api-StarCatalogs">api StarCatalogs</a></li>
<li><a href="#index-iauIr-148"><code>iauIr</code></a>: <a href="#api-Initialization">api Initialization</a></li>
<li><a href="#index-iauJd2cal-6"><code>iauJd2cal</code></a>: <a href="#api-Calendars">api Calendars</a></li>
<li><a href="#index-iauJdcalf-7"><code>iauJdcalf</code></a>: <a href="#api-Calendars">api Calendars</a></li>
<li><a href="#index-iauNum00a-45"><code>iauNum00a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauNum00b-46"><code>iauNum00b</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauNum06a-47"><code>iauNum06a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauNumat-48"><code>iauNumat</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauNut00a-49"><code>iauNut00a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauNut00b-50"><code>iauNut00b</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauNut06a-51"><code>iauNut06a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauNut80-52"><code>iauNut80</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauNutm80-53"><code>iauNutm80</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauObl06-54"><code>iauObl06</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauObl80-55"><code>iauObl80</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauP06e-56"><code>iauP06e</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauP2pv-146"><code>iauP2pv</code></a>: <a href="#api-CopyExtendExtract">api CopyExtendExtract</a></li>
<li><a href="#index-iauP2s-165"><code>iauP2s</code></a>: <a href="#api-SphericalCartesian">api SphericalCartesian</a></li>
<li><a href="#index-iauPap-160"><code>iauPap</code></a>: <a href="#api-SeparationAndAngle">api SeparationAndAngle</a></li>
<li><a href="#index-iauPas-161"><code>iauPas</code></a>: <a href="#api-SeparationAndAngle">api SeparationAndAngle</a></li>
<li><a href="#index-iauPb06-57"><code>iauPb06</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPdp-170"><code>iauPdp</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPfw06-58"><code>iauPfw06</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPlan94-9"><code>iauPlan94</code></a>: <a href="#api-Ephemerides">api Ephemerides</a></li>
<li><a href="#index-iauPm-171"><code>iauPm</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPmat00-59"><code>iauPmat00</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPmat06-60"><code>iauPmat06</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPmat76-61"><code>iauPmat76</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPmp-172"><code>iauPmp</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPn-173"><code>iauPn</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPn00-62"><code>iauPn00</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPn00a-63"><code>iauPn00a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPn00b-64"><code>iauPn00b</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPn06-65"><code>iauPn06</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPn06a-66"><code>iauPn06a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPnm00a-67"><code>iauPnm00a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPnm00b-68"><code>iauPnm00b</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPnm06a-69"><code>iauPnm06a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPnm80-70"><code>iauPnm80</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPom00-71"><code>iauPom00</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPpp-174"><code>iauPpp</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPpsp-175"><code>iauPpsp</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPr00-72"><code>iauPr00</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPrec76-73"><code>iauPrec76</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauPv2p-147"><code>iauPv2p</code></a>: <a href="#api-CopyExtendExtract">api CopyExtendExtract</a></li>
<li><a href="#index-iauPv2s-166"><code>iauPv2s</code></a>: <a href="#api-SphericalCartesian">api SphericalCartesian</a></li>
<li><a href="#index-iauPvdpv-176"><code>iauPvdpv</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPvm-177"><code>iauPvm</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPvmpv-178"><code>iauPvmpv</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPvppv-179"><code>iauPvppv</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPvstar-99"><code>iauPvstar</code></a>: <a href="#api-SpaceMotion">api SpaceMotion</a></li>
<li><a href="#index-iauPvu-180"><code>iauPvu</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPvup-181"><code>iauPvup</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPvxpv-182"><code>iauPvxpv</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauPxp-183"><code>iauPxp</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauRm2v-158"><code>iauRm2v</code></a>: <a href="#api-RotationVectors">api RotationVectors</a></li>
<li><a href="#index-iauRv2m-159"><code>iauRv2m</code></a>: <a href="#api-RotationVectors">api RotationVectors</a></li>
<li><a href="#index-iauRx-140"><code>iauRx</code></a>: <a href="#api-BuildRotations">api BuildRotations</a></li>
<li><a href="#index-iauRxp-154"><code>iauRxp</code></a>: <a href="#api-MatrixVectorProducts">api MatrixVectorProducts</a></li>
<li><a href="#index-iauRxpv-155"><code>iauRxpv</code></a>: <a href="#api-MatrixVectorProducts">api MatrixVectorProducts</a></li>
<li><a href="#index-iauRxr-152"><code>iauRxr</code></a>: <a href="#api-MatrixOps">api MatrixOps</a></li>
<li><a href="#index-iauRy-141"><code>iauRy</code></a>: <a href="#api-BuildRotations">api BuildRotations</a></li>
<li><a href="#index-iauRz-142"><code>iauRz</code></a>: <a href="#api-BuildRotations">api BuildRotations</a></li>
<li><a href="#index-iauS00-74"><code>iauS00</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauS00a-75"><code>iauS00a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauS00b-76"><code>iauS00b</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauS06-77"><code>iauS06</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauS06a-78"><code>iauS06a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauS2c-167"><code>iauS2c</code></a>: <a href="#api-SphericalCartesian">api SphericalCartesian</a></li>
<li><a href="#index-iauS2p-168"><code>iauS2p</code></a>: <a href="#api-SphericalCartesian">api SphericalCartesian</a></li>
<li><a href="#index-iauS2pv-169"><code>iauS2pv</code></a>: <a href="#api-SphericalCartesian">api SphericalCartesian</a></li>
<li><a href="#index-iauS2xpv-184"><code>iauS2xpv</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauSepp-162"><code>iauSepp</code></a>: <a href="#api-SeparationAndAngle">api SeparationAndAngle</a></li>
<li><a href="#index-iauSeps-163"><code>iauSeps</code></a>: <a href="#api-SeparationAndAngle">api SeparationAndAngle</a></li>
<li><a href="#index-iauSp00-79"><code>iauSp00</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauStarpm-106"><code>iauStarpm</code></a>: <a href="#api-StarCatalogs">api StarCatalogs</a></li>
<li><a href="#index-iauStarpv-100"><code>iauStarpv</code></a>: <a href="#api-SpaceMotion">api SpaceMotion</a></li>
<li><a href="#index-iauSxp-185"><code>iauSxp</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauSxpv-186"><code>iauSxpv</code></a>: <a href="#api-VectorOps">api VectorOps</a></li>
<li><a href="#index-iauTaitt-116"><code>iauTaitt</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauTaiut1-117"><code>iauTaiut1</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauTaiutc-118"><code>iauTaiutc</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauTcbtdb-119"><code>iauTcbtdb</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauTcgtt-120"><code>iauTcgtt</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauTdbtcb-121"><code>iauTdbtcb</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauTdbtt-122"><code>iauTdbtt</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauTf2a-138"><code>iauTf2a</code></a>: <a href="#api-AngleOps">api AngleOps</a></li>
<li><a href="#index-iauTf2d-139"><code>iauTf2d</code></a>: <a href="#api-AngleOps">api AngleOps</a></li>
<li><a href="#index-iauTr-153"><code>iauTr</code></a>: <a href="#api-MatrixOps">api MatrixOps</a></li>
<li><a href="#index-iauTrxp-156"><code>iauTrxp</code></a>: <a href="#api-MatrixVectorProducts">api MatrixVectorProducts</a></li>
<li><a href="#index-iauTrxpv-157"><code>iauTrxpv</code></a>: <a href="#api-MatrixVectorProducts">api MatrixVectorProducts</a></li>
<li><a href="#index-iauTttai-123"><code>iauTttai</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauTttcg-124"><code>iauTttcg</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauTttdb-125"><code>iauTttdb</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauTtut1-126"><code>iauTtut1</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauUt1tai-127"><code>iauUt1tai</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauUt1tt-128"><code>iauUt1tt</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauUt1utc-129"><code>iauUt1utc</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauUtctai-130"><code>iauUtctai</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauUtcut1-131"><code>iauUtcut1</code></a>: <a href="#api-Timescales">api Timescales</a></li>
<li><a href="#index-iauXy06-80"><code>iauXy06</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauXys00a-81"><code>iauXys00a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauXys00b-82"><code>iauXys00b</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauXys06a-83"><code>iauXys06a</code></a>: <a href="#api-PrecNutPolar">api PrecNutPolar</a></li>
<li><a href="#index-iauZp-149"><code>iauZp</code></a>: <a href="#api-Initialization">api Initialization</a></li>
<li><a href="#index-iauZpv-150"><code>iauZpv</code></a>: <a href="#api-Initialization">api Initialization</a></li>
<li><a href="#index-iauZr-151"><code>iauZr</code></a>: <a href="#api-Initialization">api Initialization</a></li>
   </ul><div class="node">
<a name="variable-index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#type-index">type index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#function-index">function index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix F An entry for each variable.</h2>



<ul class="index-vr" compact>
<li><a href="#index-D2PI-188"><code>D2PI</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DAS2R-191"><code>DAS2R</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DAU-205"><code>DAU</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DAYSEC-196"><code>DAYSEC</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DC-206"><code>DC</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DD2R-189"><code>DD2R</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DJ00-200"><code>DJ00</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DJC-198"><code>DJC</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DJM-199"><code>DJM</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DJM0-201"><code>DJM0</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DJM00-202"><code>DJM00</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DJM77-203"><code>DJM77</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DJY-197"><code>DJY</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DMAS2R-194"><code>DMAS2R</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DPI-187"><code>DPI</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DR2AS-190"><code>DR2AS</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DS2R-192"><code>DS2R</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-DTY-195"><code>DTY</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-ELB-208"><code>ELB</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-ELG-207"><code>ELG</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-GRS80-211"><code>GRS80</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-TDB0-209"><code>TDB0</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-TTMTAI-204"><code>TTMTAI</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-TURNAS-193"><code>TURNAS</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-WGS72-212"><code>WGS72</code></a>: <a href="#api-consts-c">api consts c</a></li>
<li><a href="#index-WGS84-210"><code>WGS84</code></a>: <a href="#api-consts-c">api consts c</a></li>
   </ul><div class="node">
<a name="type-index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#variable-index">variable index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix G An entry for each type.</h2>



<ul class="index-tp" compact>
   </ul>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Standards of Fundamental Astronomy</a>
<li><a name="toc_overview" href="#overview">1 Overview of the package</a>
<li><a name="toc_intro" href="#intro">2 The <acronym>IAU</acronym> <acronym>SOFA</acronym> software libraries</a>
<ul>
<li><a href="#intro">2.1 The <acronym>SOFA</acronym> initiative</a>
<li><a href="#intro">2.2 Algorithms</a>
<li><a href="#intro">2.3 Scope</a>
<li><a href="#intro">2.4 Versions</a>
<li><a href="#intro">2.5 Documentation</a>
<li><a href="#intro">2.6 Programming languages and standards</a>
<li><a href="#intro">2.7 Copyright issues</a>
<li><a href="#intro">2.8 Accuracy</a>
<li><a href="#intro">2.9 Acknowledgements</a>
</li></ul>
<li><a name="toc_astronomy" href="#astronomy">3 <acronym>SOFA</acronym> Astronomy Library</a>
<ul>
<li><a href="#astronomy">3.1 Preface</a>
<li><a href="#astronomy">3.2 Programming languages</a>
<li><a href="#astronomy">3.3 General principles</a>
<li><a href="#astronomy">3.4 Routines</a>
</li></ul>
<li><a name="toc_vector-matrix" href="#vector-matrix">4 <acronym>SOFA</acronym> Vector/Matrix Library</a>
<ul>
<li><a href="#vector-matrix">4.1 Preface</a>
<li><a href="#vector-matrix">4.2 Programming languages</a>
<li><a href="#vector-matrix">4.3 General principles</a>
<li><a href="#vector-matrix">4.4 Operations involving <code>p</code>-vectors and <code>r</code>-matrices</a>
<li><a href="#vector-matrix">4.5 Operations involving <code>pv</code>-vectors</a>
</li></ul>
<li><a name="toc_api" href="#api">5 Functions</a>
<ul>
<li><a href="#api-astronomy">5.1 Astronomy functions</a>
<ul>
<li><a href="#api-Calendars">5.1.1 Calendars</a>
<li><a href="#api-Ephemerides">5.1.2 Ephemerides</a>
<li><a href="#api-FundamentalArgs">5.1.3 Fundamental args</a>
<li><a href="#api-PrecNutPolar">5.1.4 Prec nut polar</a>
<li><a href="#api-RotationAndTime">5.1.5 Rotation and time</a>
<li><a href="#api-SpaceMotion">5.1.6 Space motion</a>
<li><a href="#api-StarCatalogs">5.1.7 Star catalogs</a>
<li><a href="#api-Geodetic_002fGeocentric">5.1.8 Geodetic geocentric</a>
<li><a href="#api-Timescales">5.1.9 Timescales</a>
</li></ul>
<li><a href="#api-vector-matrix">5.2 Vector and matrix functions</a>
<ul>
<li><a href="#api-AngleOps">5.2.1 Angle operations</a>
<li><a href="#api-BuildRotations">5.2.2 Build rotations</a>
<li><a href="#api-CopyExtendExtract">5.2.3 Copy extend extract</a>
<li><a href="#api-Initialization">5.2.4 Initialization</a>
<li><a href="#api-MatrixOps">5.2.5 Matrix operations</a>
<li><a href="#api-MatrixVectorProducts">5.2.6 Matrix vector products</a>
<li><a href="#api-RotationVectors">5.2.7 Rotation vectors</a>
<li><a href="#api-SeparationAndAngle">5.2.8 Separation and angle</a>
<li><a href="#api-SphericalCartesian">5.2.9 Spherical cartesian</a>
<li><a href="#api-VectorOps">5.2.10 Vector operations</a>
</li></ul>
<li><a href="#api-consts-fortran">5.3 Fortran language constants</a>
<li><a href="#api-consts-c">5.4 C language constants</a>
</li></ul>
<li><a name="toc_board" href="#board">Appendix A <acronym>IAU</acronym> Standards of Fundamental Astronomy Board</a>
<li><a name="toc_license" href="#license">Appendix B Package license</a>
<ul>
<li><a href="#license">B.1 <acronym>SOFA</acronym> Software License</a>
<li><a href="#license">B.2 Acknowledgement &amp; Citation for <acronym>SOFA</acronym></a>
</li></ul>
<li><a name="toc_references" href="#references">Appendix C Bibliography and references</a>
<li><a name="toc_concept-index" href="#concept-index">Appendix D An entry for each concept</a>
<li><a name="toc_function-index" href="#function-index">Appendix E An entry for each function.</a>
<li><a name="toc_variable-index" href="#variable-index">Appendix F An entry for each variable.</a>
<li><a name="toc_type-index" href="#type-index">Appendix G An entry for each type.</a>
</li></ul>
</div>

</body></html>

