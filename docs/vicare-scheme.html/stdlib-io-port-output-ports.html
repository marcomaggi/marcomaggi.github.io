<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This document describes version 0.4d1 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit and 64-bit
processors.  Vicare is pronounced the etruscan way.

The package, including its documentation, is distributed under the terms
of the GNU General Public License (GPL) and can be downloaded
from:

https://bitbucket.org/marcomaggi/vicare-scheme/downloads

the home page of the project is at:

http://marcomaggi.github.io/vicare.html

development takes place at:

http://github.com/marcomaggi/vicare/

and, as a backup, at:

https://bitbucket.org/marcomaggi/vicare-scheme/

Copyright (C) 2010-2017 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton Van Straaten.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors, see the "History" appendix for details.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library (vicare formations) is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License version 3 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see
http://www.gnu.org/licenses/.

Trademarks used herein are the property of their respective owners. -->
<!-- Created by GNU Texinfo 6.3, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Vicare Scheme: stdlib io port output ports</title>

<meta name="description" content="Vicare Scheme: stdlib io port output ports">
<meta name="keywords" content="Vicare Scheme: stdlib io port output ports">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="concept-index.html#concept-index" rel="index" title="concept index">
<link href="stdlib-io-port.html#stdlib-io-port" rel="up" title="stdlib io port">
<link href="stdlib-io-port-binary-output.html#stdlib-io-port-binary-output" rel="next" title="stdlib io port binary output">
<link href="stdlib-io-port-textual-input.html#stdlib-io-port-textual-input" rel="prev" title="stdlib io port textual input">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="stdlib-io-port-output-ports"></a>
<div class="header">
<p>
Next: <a href="stdlib-io-port-binary-output.html#stdlib-io-port-binary-output" accesskey="n" rel="next">stdlib io port binary output</a>, Previous: <a href="stdlib-io-port-textual-input.html#stdlib-io-port-textual-input" accesskey="p" rel="prev">stdlib io port textual input</a>, Up: <a href="stdlib-io-port.html#stdlib-io-port" accesskey="u" rel="up">stdlib io port</a> &nbsp; [<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Output-ports"></a>
<h4 class="subsubsection">5.8.2.10 Output ports</h4>


<p>An output port is a sink to which bytes or characters are written.  The
written data may control external devices or may produce files and other
objects that may subsequently be opened for input.
</p>

<dl>
<dt><a name="index-output_002dport_003f"></a>Procedure: <strong>output-port?</strong> <em><var>obj</var></em></dt>
<dd><p>Return <code>#t</code> if the argument is an output port (or a combined input
and output port), <code>#f</code> otherwise.
</p></dd></dl>


<dl>
<dt><a name="index-flush_002doutput_002dport"></a>Procedure: <strong>flush-output-port</strong> <em><var>output-port</var></em></dt>
<dd><p>Flushes any buffered output from the buffer of <var>output-port</var> to the
underlying file, device, or object.  The <code>flush-output-port</code>
procedure returns unspecified values.
</p></dd></dl>


<dl>
<dt><a name="index-output_002dport_002dbuffer_002dmode"></a>Procedure: <strong>output-port-buffer-mode</strong> <em><var>output-port</var></em></dt>
<dd><p>Return the symbol that represents the buffer mode of <var>output-port</var>.
</p></dd></dl>


<dl>
<dt><a name="index-open_002dfile_002doutput_002dport"></a>Procedure: <strong>open-file-output-port</strong> <em><var>filename</var></em></dt>
<dt><a name="index-open_002dfile_002doutput_002dport-1"></a>Procedure: <strong>open-file-output-port</strong> <em><var>filename</var> <var>file-options</var></em></dt>
<dt><a name="index-open_002dfile_002doutput_002dport-2"></a>Procedure: <strong>open-file-output-port</strong> <em><var>filename</var> <var>file-options</var> <var>buffer-mode</var></em></dt>
<dt><a name="index-open_002dfile_002doutput_002dport-3"></a>Procedure: <strong>open-file-output-port</strong> <em><var>filename</var> <var>file-options</var> <var>buffer-mode</var> <var>maybe-transcoder</var></em></dt>
<dd><p><var>maybe-transcoder</var> must be either a transcoder or <code>#f</code>.
</p>
<p>The <code>open-file-output-port</code> procedure returns an output port for
the named file.
</p>
<p>The <var>file-options</var> argument, which may determine various aspects of
the returned port, defaults to the value of <code>(file-options)</code>.
</p>
<p>The <var>buffer-mode</var> argument, if supplied, must be one of the symbols
that name a buffer mode.  The <var>buffer-mode</var> argument defaults to
<code>block</code>.
</p>
<p>If <var>maybe-transcoder</var> is a transcoder, it becomes the transcoder
associated with the port.
</p>
<p>If <var>maybe-transcoder</var> is <code>#f</code> or absent, the port will be a
binary port and will support the <code>port-position</code> and
<code>set-port-position!</code>  operations.  Otherwise the port will be a
textual port, and whether it supports the <code>port-position</code> and
<code>set-port-position!</code> operations is implementation&ndash;dependent (and
possibly transcoder&ndash;dependent).
</p></dd></dl>


<dl>
<dt><a name="index-open_002dbytevector_002doutput_002dport"></a>Procedure: <strong>open-bytevector-output-port</strong></dt>
<dt><a name="index-open_002dbytevector_002doutput_002dport-1"></a>Procedure: <strong>open-bytevector-output-port</strong> <em><var>maybe-transcoder</var></em></dt>
<dd><p><var>maybe-transcoder</var> must be either a transcoder or <code>#f</code>.
</p>
<p>The <code>open-bytevector-output-port</code> procedure returns two values: an
output port and an extraction procedure.  The output port accumulates
the bytes written to it for later extraction by the procedure.
</p>
<p>If <var>maybe-transcoder</var> is a transcoder, it becomes the transcoder
associated with the port.  If <var>maybe-transcoder</var> is <code>#f</code> or
absent, the port will be a binary port and will support the
<code>port-position</code> and <code>set-port-position!</code>  operations.
Otherwise the port will be a textual port, and whether it supports the
<code>port-position</code> and <code>set-port-position!</code> operations is
implementation&ndash;dependent (and possibly transcoder&ndash;dependent).
</p>
<p>The extraction procedure takes no arguments.  When called, it returns a
bytevector consisting of all the port&rsquo;s accumulated bytes (regardless of
the port&rsquo;s current position), removes the accumulated bytes from the
port, and resets the port&rsquo;s position.
</p></dd></dl>


<dl>
<dt><a name="index-call_002dwith_002dbytevector_002doutput_002dport"></a>Procedure: <strong>call-with-bytevector-output-port</strong> <em><var>proc</var></em></dt>
<dt><a name="index-call_002dwith_002dbytevector_002doutput_002dport-1"></a>Procedure: <strong>call-with-bytevector-output-port</strong> <em><var>proc</var> <var>maybe-transcoder</var></em></dt>
<dd><p><var>proc</var> must accept one argument.  <var>maybe-transcoder</var> must be
either a transcoder or <code>#f</code>.
</p>
<p>The <code>call-with-bytevector-output-port</code> procedure creates an output
port that accumulates the bytes written to it and calls <var>proc</var> with
that output port as an argument.
</p>
<p>Whenever <var>proc</var> returns, a bytevector consisting of all of the
port&rsquo;s accumulated bytes (regardless of the port&rsquo;s current position) is
returned and the port is closed.
</p>
<p>The transcoder associated with the output port is determined as for a
call to <code>open-bytevector-output-port</code>.
</p></dd></dl>


<dl>
<dt><a name="index-open_002dstring_002doutput_002dport"></a>Procedure: <strong>open-string-output-port</strong></dt>
<dd><p>Return two values: a textual output port and an extraction procedure.
The output port accumulates the characters written to it for later
extraction by the procedure.
</p>
<p>The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.  The port should support the
<code>port-position</code> and <code>set-port-position!</code> operations.
</p>
<p>The extraction procedure takes no arguments.  When called, it returns a
string consisting of all of the port&rsquo;s accumulated characters
(regardless of the current position), removes the accumulated characters
from the port, and resets the port&rsquo;s position.
</p></dd></dl>


<dl>
<dt><a name="index-call_002dwith_002dstring_002doutput_002dport"></a>Procedure: <strong>call-with-string-output-port</strong> <em><var>proc</var></em></dt>
<dd><p><var>proc</var> must accept one argument.
</p>
<p>The <code>call-with-string-output-port</code> procedure creates a textual
output port that accumulates the characters written to it and calls
<var>proc</var> with that output port as an argument.
</p>
<p>Whenever <var>proc</var> returns, a string consisting of all of the port&rsquo;s
accumulated characters (regardless of the port&rsquo;s current position) is
returned and the port is closed.
</p>
<p>The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.  The port should support the
<code>port-position</code> and <code>set-port-position!</code> operations.
</p></dd></dl>


<dl>
<dt><a name="index-standard_002doutput_002dport"></a>Procedure: <strong>standard-output-port</strong></dt>
<dt><a name="index-standard_002derror_002dport"></a>Procedure: <strong>standard-error-port</strong></dt>
<dd><p>Return a fresh binary output port connected to the standard output or
standard error respectively.  Whether the port supports the
<code>port-position</code> and <code>set-port-position!</code> operations is
implementation&ndash;dependent.
</p></dd></dl>


<dl>
<dt><a name="index-current_002doutput_002dport"></a>Procedure: <strong>current-output-port</strong></dt>
<dt><a name="index-current_002derror_002dport"></a>Procedure: <strong>current-error-port</strong></dt>
<dd><p>These return default textual ports for regular output and error output.
Normally, these default ports are associated with standard output, and
standard error, respectively.
</p>
<p>The return value of <code>current-output-port</code> can be dynamically
re&ndash;assigned using the <code>with-output-to-file</code> procedure from the
<code>(rnrs io simple (6))</code> library.  A port returned by one of these
procedures may or may not have an associated transcoder; if it does, the
transcoder is implementation&ndash;dependent.
</p></dd></dl>


<dl>
<dt><a name="index-make_002dcustom_002dbinary_002doutput_002dport"></a>Procedure: <strong>make-custom-binary-output-port</strong> <em><var>id</var> <var>write!</var> <var>get-position</var> <var>set-position!</var> <var>close</var></em></dt>
<dd><p>Return a newly created binary output port whose byte sink is an
arbitrary algorithm represented by the <var>write!</var> procedure.  <var>id</var>
must be a string naming the new port, provided for informational
purposes only.  <var>write!</var> must be a procedure and should behave as
specified below; it will be called by operations that perform binary
output.
</p>
<p>Each of the remaining arguments may be <code>#f</code>; if any of those
arguments is not <code>#f</code>, it must be a procedure and should behave as
specified in the description of <code>make-custom-binary-input-port</code>.
</p>
<dl compact="compact">
<dt><code>(<var>write!</var> <var>bytevector</var> <var>start</var> <var>count</var>)</code></dt>
<dd><p><var>start</var> and <var>count</var> will be non-negative exact integer objects,
and <var>bytevector</var> will be a bytevector whose length is at least
<var>start</var>+<var>count</var>.
</p>
<p>The <var>write!</var> procedure should write up to <var>count</var> bytes from
<var>bytevector</var> starting at index <var>start</var> to the byte sink.  In any
case, the <var>write!</var> procedure should return the number of bytes that
it wrote, as an exact integer object.
</p></dd>
</dl>

<p><strong>Implementation responsibilities:</strong> The implementation must check
the return values of <var>write!</var> only when it actually calls
<var>write!</var> as part of an I/O operation requested by the program.  The
implementation is not required to check that <var>write!</var> otherwise
behaves as described.  If it does not, however, the behavior of the
resulting port is unspecified.
</p></dd></dl>


<dl>
<dt><a name="index-make_002dcustom_002dtextual_002doutput_002dport"></a>Procedure: <strong>make-custom-textual-output-port</strong> <em><var>id</var> <var>write!</var> <var>get-position</var> <var>set-position!</var> <var>close</var></em></dt>
<dd><p>Return a newly created textual output port whose byte sink is an
arbitrary algorithm represented by the <var>write!</var> procedure.  <var>Id</var>
must be a string naming the new port, provided for informational
purposes only.  <var>write!</var> must be a procedure and should behave as
specified below; it will be called by operations that perform textual
output.
</p>
<p>Each of the remaining arguments may be <code>#f</code>; if any of those
arguments is not <code>#f</code>, it must be a procedure and should behave as
specified in the description of <code>make-custom-textual-input-port</code>.
</p>
<dl compact="compact">
<dt><code>(<var>write!</var> <var>string</var> <var>start</var> <var>count</var>)</code></dt>
<dd><p><var>start</var> and <var>count</var> will be non&ndash;negative exact integer objects,
and <var>string</var> will be a string whose length is at least
<var>start</var>+<var>count</var>.
</p>
<p>The <var>write!</var> procedure should write up to <var>count</var> characters
from <var>string</var> starting at index <var>start</var> to the character sink.
In any case, the <var>write!</var> procedure should return the number of
characters that it wrote, as an exact integer object.
</p></dd>
</dl>

<p>The port may or may not have an associated transcoder; if it does, the
transcoder is implementation&ndash;dependent.
</p>
<p><strong>Implementation responsibilities:</strong> The implementation must check
the return values of <var>write!</var> only when it actually calls
<var>write!</var> as part of an I/O operation requested by the program.  The
implementation is not required to check that <var>write!</var> otherwise
behaves as described.  If it does not, however, the behavior of the
resulting port is unspecified.
</p></dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="stdlib-io-port-binary-output.html#stdlib-io-port-binary-output" accesskey="n" rel="next">stdlib io port binary output</a>, Previous: <a href="stdlib-io-port-textual-input.html#stdlib-io-port-textual-input" accesskey="p" rel="prev">stdlib io port textual input</a>, Up: <a href="stdlib-io-port.html#stdlib-io-port" accesskey="u" rel="up">stdlib io port</a> &nbsp; [<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
