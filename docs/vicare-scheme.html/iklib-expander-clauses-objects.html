<html lang="en">
<head>
<title>iklib expander clauses objects - Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="iklib-expander-clauses.html#iklib-expander-clauses" title="iklib expander clauses">
<link rel="prev" href="iklib-expander-clauses-constr.html#iklib-expander-clauses-constr" title="iklib expander clauses constr">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d6 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  _Vicare_ is pronounced
the etruscan way.

The package, including its documentation, is distributed under the terms
of the GNU General Public License (GPL) and can be downloaded
from:

        `http://sourceforge.net/projects/vicare-scheme/files/'


the home page of the project is at:

              `http://marcomaggi.github.com/vicare.html'


development takes place at:

                `http://github.com/marcomaggi/vicare/'


and, as a backup, at:

                     `http://gitorious.org/vicare'


and at:

           `http://sourceforge.net/projects/vicare-scheme/'


this project has a mailing list:

             `http://groups.google.com/group/vicare-users'


Copyright (C) 2010-2013 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton Van Straaten.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors, see the ``History'' appendix for details.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library `(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="iklib-expander-clauses-objects"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="iklib-expander-clauses-constr.html#iklib-expander-clauses-constr">iklib expander clauses constr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="iklib-expander-clauses.html#iklib-expander-clauses">iklib expander clauses</a>
<hr>
</div>

<h5 class="subsubsection">6.8.10.4 Clause specification objects</h5>

<p>Clause specification objects are opaque objects, disjoint from all the
other Scheme object types, representing the constraints enforceable on a
syntax clause.

<div class="defun">
&mdash; Function: <b>make-syntax-clause-spec</b><var> keyword min-occur max-occur min-args max-args mutually-inclusive mutually-exclusive<a name="index-make_002dsyntax_002dclause_002dspec-1245"></a></var><br>
<blockquote><p>Build and return a new syntax clause specification object.  The
arguments are:

          <dl>
<dt><var>keyword</var><dd>An identifier representing the keyword for this clause.

          <br><dt><var>min-occur</var><dd>A non&ndash;negative real number representing the allowed minimum number of
occurrences for this clause.  &lsquo;<samp><span class="samp">0</span></samp>&rsquo; means the clause is optional;
&lsquo;<samp><span class="samp">1</span></samp>&rsquo; means the clause is mandatory.

          <br><dt><var>max-occur</var><dd>A non&ndash;negative real number representing the allowed maximum number of
occurrences for this clause.  &lsquo;<samp><span class="samp">0</span></samp>&rsquo; means the clause is forbidden;
&lsquo;<samp><span class="samp">1</span></samp>&rsquo; means the clause must appear at most once; &lsquo;<samp><span class="samp">+inf.0</span></samp>&rsquo; means
the clause can appear any number of times.

          <br><dt><var>min-args</var><dd>A non&ndash;negative real number representing the allowed minimum number of
arguments for this clause.  &lsquo;<samp><span class="samp">0</span></samp>&rsquo; means the clause can have no
arguments; &lsquo;<samp><span class="samp">1</span></samp>&rsquo; means the clause must have at least one argument.

          <br><dt><var>max-args</var><dd>A non&ndash;negative real number representing the allowed maximum number of
arguments for this clause.  &lsquo;<samp><span class="samp">0</span></samp>&rsquo; means the clause has no arguments;
&lsquo;<samp><span class="samp">1</span></samp>&rsquo; means the clause must have at most one arguments; &lsquo;<samp><span class="samp">+inf.0</span></samp>&rsquo;
means the clause can have any number of arguments.

          <br><dt><var>mutually-inclusive</var><dd>A list identifiers representing clauses keywords that must appear along
with this one.

          <br><dt><var>mutually-exclusive</var><dd>A list identifiers representing clauses keywords that must not appear
along with this one. 
</dl>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: <b>syntax-clause-spec?</b><var> obj<a name="index-syntax_002dclause_002dspec_003f-1246"></a></var><br>
<blockquote><p>Return <code>#t</code> if <var>obj</var> is a syntax clause specification object,
otherwise return <code>#f</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>syntax-clause-spec-keyword</b><var> spec<a name="index-syntax_002dclause_002dspec_002dkeyword-1247"></a></var><br>
&mdash; Function: <b>syntax-clause-spec-min-number-of-occurrences</b><var> spec<a name="index-syntax_002dclause_002dspec_002dmin_002dnumber_002dof_002doccurrences-1248"></a></var><br>
&mdash; Function: <b>syntax-clause-spec-max-number-of-occurrences</b><var> spec<a name="index-syntax_002dclause_002dspec_002dmax_002dnumber_002dof_002doccurrences-1249"></a></var><br>
&mdash; Function: <b>syntax-clause-spec-min-number-of-arguments</b><var> spec<a name="index-syntax_002dclause_002dspec_002dmin_002dnumber_002dof_002darguments-1250"></a></var><br>
&mdash; Function: <b>syntax-clause-spec-max-number-of-arguments</b><var> spec<a name="index-syntax_002dclause_002dspec_002dmax_002dnumber_002dof_002darguments-1251"></a></var><br>
&mdash; Function: <b>syntax-clause-spec-mutually-inclusive</b><var> spec<a name="index-syntax_002dclause_002dspec_002dmutually_002dinclusive-1252"></a></var><br>
&mdash; Function: <b>syntax-clause-spec-mutually-exclusive</b><var> spec<a name="index-syntax_002dclause_002dspec_002dmutually_002dexclusive-1253"></a></var><br>
<blockquote><p>Accessors for the fields of syntax clause specification objects. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>syntax-clauses-single-spec</b><var> spec unwrapped-clauses<a name="index-syntax_002dclauses_002dsingle_002dspec-1254"></a></var><br>
&mdash; Function: <b>syntax-clauses-single-spec</b><var> spec unwrapped-clauses synner<a name="index-syntax_002dclauses_002dsingle_002dspec-1255"></a></var><br>
<blockquote><p>Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of <code>syntax-clauses-unwrap</code>) verify if
there are clauses conforming to the given specification <var>spec</var>.

        <p>If successful return a (possibly empty) vector of vectors of syntax
objects; else call <var>synner</var> or raise a <code>&amp;syntax</code> exception. 
The length of the returned vector is the number of clauses from
<var>unwrapped-clauses</var> conforming to <var>spec</var>.  Each nested vector
represents the cdr of a clause matching <var>spec</var>:

          <ul>
<li>If a clause has no arguments: the corresponding nested vector is empty.

          <li>If a clause has 1 argument: the corresponding nested vector has
1 item being the syntax object representing the argument.

          <li>If a clause has N arguments: the corresponding nested vector has
N items being the syntax objects representing the arguments. 
</ul>

        <p>Examples:

     <pre class="example">          (import (vicare))
          
          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 1 1 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b 456)
                                       (d 789))))
          &rArr; #(#(456))
          
          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b)
                                       (d 789))))
          &rArr; #(#())
          
          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b 4 5 6)
                                       (d 789))))
          &rArr; #(#(4 5 6))
          
          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b 4)
                                       (b 5)
                                       (b 6)
                                       (d 789))))
          &rArr; #(#(4) #(5) #(6))
          
          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b 4 4.1)
                                       (b 5 5.1)
                                       (d 789))))
          &rArr; #(#(4 4.1) #(5 5.1))
          
          (syntax-clauses-single-spec
             (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
             (syntax-clauses-unwrap #'((a 123)
                                       (b 4 ciao 6)
                                       (d 789))))
          &rArr; #(#(4 #&lt;syntax-object expr=ciao&gt; 6))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: <b>syntax-clauses-fold-specs</b><var> combine knil specs unwrapped-clauses<a name="index-syntax_002dclauses_002dfold_002dspecs-1256"></a></var><br>
&mdash; Function: <b>syntax-clauses-fold-specs</b><var> combine knil specs unwrapped-clauses synner<a name="index-syntax_002dclauses_002dfold_002dspecs-1257"></a></var><br>
<blockquote><p>Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of <code>syntax-clauses-unwrap</code>) verify that
the clauses conform to the given <var>specs</var>, which must be a list of
syntax clause specification objects.

        <p>Combine the clause arguments with the given <var>knil</var> in a
<code>fold-left</code> fashion, if successful return the resulting <var>knil</var>;
if an invalid clause is found call <var>synner</var> or raise a
<code>&amp;syntax</code> object.

        <p>The operation is conceptually as follows:

     <pre class="example">          (fold-left
              (lambda (knil spec)
                (let ((args (syntax-clauses-single-spec spec
                               <var>unwrapped-clauses</var> <var>synner</var>)))
                  (if (fxzero? (vector-length args))
                      knil
                    (<var>combine</var> knil spec args))))
            <var>knil</var>
            <var>specs</var>)
</pre>
        <p class="noindent">notice that <var>combine</var> is called only if a clause from <var>specs</var> is
present in <var>unwrapped-clauses</var>; <var>combine</var> must return the new
value for <var>knil</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>syntax-clauses-validate-specs</b><var> list-of-specs<a name="index-syntax_002dclauses_002dvalidate_002dspecs-1258"></a></var><br>
<blockquote><p>Given a list of <code>syntax-clause-spec</code> objects: perform some
validations among them.  If successful return <var>list-of-specs</var>
itself, otherwise raise an assertion violation.

        <p>The following checks are performed:

          <ul>
<li>For every identifier listed in the <code>mutually-inclusive</code> field of
every <code>syntax-clause-spec</code>: check that such identifier is equal,
according to <code>free-identifier=?</code>, to an identifier in the
<code>keyword</code> field of another <code>syntax-clause-spec</code> object.

          <li>For every identifier listed in the <code>mutually-exclusive</code> field of
every <code>syntax-clause-spec</code>: check that such identifier is equal,
according to <code>free-identifier=?</code>, to an identifier in the
<code>keyword</code> field of another <code>syntax-clause-spec</code> object. 
</ul>
        </p></blockquote></div>

<!-- page -->
   </body></html>

