<html lang="en">
<head>
<title>scheme overview intro - Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="scheme-overview.html#scheme-overview" title="scheme overview">
<link rel="next" href="scheme-overview-basic-types.html#scheme-overview-basic-types" title="scheme overview basic types">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d6 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  _Vicare_ is pronounced
the etruscan way.

The package, including its documentation, is distributed under the terms
of the GNU General Public License (GPL) and can be downloaded
from:

        `http://sourceforge.net/projects/vicare-scheme/files/'


the home page of the project is at:

              `http://marcomaggi.github.com/vicare.html'


development takes place at:

                `http://github.com/marcomaggi/vicare/'


and, as a backup, at:

                     `http://gitorious.org/vicare'


and at:

           `http://sourceforge.net/projects/vicare-scheme/'


this project has a mailing list:

             `http://groups.google.com/group/vicare-users'


Copyright (C) 2010-2013 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton Van Straaten.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors, see the ``History'' appendix for details.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library `(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="scheme-overview-intro"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="scheme-overview-basic-types.html#scheme-overview-basic-types">scheme overview basic types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="scheme-overview.html#scheme-overview">scheme overview</a>
<hr>
</div>

<h4 class="subsection">3.1.1 Introduction</h4>

<p>Following Algol, Scheme is a statically scoped programming language. 
Each use of a variable is associated with a lexically apparent binding
of that variable.

   <p>Scheme has <dfn>latent</dfn> as opposed to <dfn>manifest</dfn> types.  Types are
associated with objects (also called values) rather than with variables. 
(Some authors refer to languages with latent types as untyped, weakly
typed or dynamically typed languages.)  Other languages with latent
types are Python, Ruby, Smalltalk, and other dialects of Lisp. 
Languages with manifest types (sometimes referred to as strongly typed
or statically typed languages) include Algol 60, C, C#, Java, Haskell,
and ML.

   <p>All objects created in the course of a Scheme computation, including
procedures and continuations, have unlimited extent.  No Scheme object
is ever destroyed.  The reason that implementations of Scheme do not
(usually!) run out of storage is that they are permitted to reclaim the
storage occupied by an object if they can prove that the object cannot
possibly matter to any future computation.  Other languages in which
most objects have unlimited extent include C#, Java, Haskell, most Lisp
dialects, ML, Python, Ruby, and Smalltalk.

   <p>Implementations of Scheme must be properly tail&ndash;recursive.  This allows
the execution of an iterative computation in constant space, even if the
iterative computation is described by a syntactically recursive
procedure.  Thus with a properly tail&ndash;recursive implementation,
iteration can be expressed using the ordinary procedure&ndash;call mechanics,
so that special iteration constructs are useful only as syntactic sugar.

   <p>Scheme was one of the first languages to support procedures as objects
in their own right.  Procedures can be created dynamically, stored in
data structures, returned as results of procedures, and so on.  Other
languages with these properties include Common Lisp, Haskell, ML, Ruby,
and Smalltalk.

   <p>One distinguishing feature of Scheme is that continuations, which in
most other languages only operate behind the scenes, also have
&ldquo;first&ndash;class&rdquo; status.  First&ndash;class continuations are useful for
implementing a wide variety of advanced control constructs, including
non&ndash;local exits, backtracking, and coroutines.

   <p>In Scheme, the argument expressions of a procedure call are evaluated
before the procedure gains control, whether the procedure needs the
result of the evaluation or not.  C, C#, Common Lisp, Python, Ruby, and
Smalltalk are other languages that always evaluate argument expressions
before invoking a procedure.  This is distinct from the lazy&ndash;evaluation
semantics of Haskell, or the call&ndash;by&ndash;name semantics of Algol 60, where
an argument expression is not evaluated unless its value is needed by
the procedure.

   <p>Scheme's model of arithmetic provides a rich set of numerical types and
operations on them.  Furthermore, it distinguishes <dfn>exact</dfn> and
<dfn>inexact</dfn> number objects: Essentially, an exact number object
corresponds to a number exactly, and an inexact number object is the
result of a computation that involved rounding or other errors.

<!-- page -->
   </body></html>

