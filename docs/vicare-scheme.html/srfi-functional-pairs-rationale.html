<html lang="en">
<head>
<title>srfi functional pairs rationale - Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="srfi-functional-pairs.html#srfi-functional-pairs" title="srfi functional pairs">
<link rel="prev" href="srfi-functional-pairs-issues.html#srfi-functional-pairs-issues" title="srfi functional pairs issues">
<link rel="next" href="srfi-functional-pairs-spec.html#srfi-functional-pairs-spec" title="srfi functional pairs spec">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d2 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  _Vicare_ is pronounced
the etruscan way.

The package, including its documentation, is distributed under the terms
of the GNU General Public License (GPL) and can be downloaded
from:

        `http://sourceforge.net/projects/vicare-scheme/files/'


the home page of the project is at:

              `http://marcomaggi.github.com/vicare.html'


development takes place at:

                `http://github.com/marcomaggi/vicare/'


and, as a backup, at:

                     `http://gitorious.org/vicare'


and at:

           `http://sourceforge.net/projects/vicare-scheme/'


this project has a mailing list:

             `http://groups.google.com/group/vicare-users'


Copyright (C) 2010-2013 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton Van Straaten.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors, see the ``History'' appendix for details.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="srfi-functional-pairs-rationale"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="srfi-functional-pairs-spec.html#srfi-functional-pairs-spec">srfi functional pairs spec</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="srfi-functional-pairs-issues.html#srfi-functional-pairs-issues">srfi functional pairs issues</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="srfi-functional-pairs.html#srfi-functional-pairs">srfi functional pairs</a>
<hr>
</div>

<h4 class="subsection">14.33.3 Rationale</h4>

<p>Functional programming and list hacking go together like peanut butter
and jelly, eval and apply, syntax and semantics, or cursing and
recursing.  But the traditional approach to implementing pairs and lists
results in index&ndash;based access (<code>list-ref</code>) requiring time
proportional the index being accessed.  Moreover, indexed&ndash;based
functional update (<code>list-set</code>) becomes so inefficient as to be
nearly unspeakable.  Instead, programmers revert the imperatives of the
state; they use a stateful data structure and imperative algorithms.

   <p>This <acronym>SRFI</acronym> intends to improve the situation by offering an alternative
implementation strategy based on Okasaki's purely functional
random&ndash;access lists [1].  Random&ndash;access pairs and lists can be used as
a replacement for traditional, linear&ndash;access pairs and lists with no
asymptotic loss of efficiency.  In other words, the typical list and
pair operations such as <code>cons</code>, <code>car</code>, and <code>cdr</code>, all
operate in O(1) time as usual.  However, random&ndash;access lists
additionally support index&ndash;based access and functional update
operations that are asymptotically cheaper; O(\log(n)) for
random&ndash;access lists versus O(n) for linear&ndash;access lists, where
n is the length of the list being access or updated.  As such,
many purely functional index&ndash;based list algorithms become feasible by
using a random&ndash;access list representation for pairs and lists.

   <p>The requirements of this <acronym>SRFI</acronym> have been designed in such a way as to
admit portable library implementations of this feature, such as the
reference implementation, while at the same time admit more radical
implementations that embrace random&ndash;access pairs as the fundamental
pair representation.

<!-- page -->
   </body></html>

