<html lang="en">
<head>
<title>stdlib arithmetic flonums - Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="stdlib-arithmetic.html#stdlib-arithmetic" title="stdlib arithmetic">
<link rel="prev" href="stdlib-arithmetic-fixnums.html#stdlib-arithmetic-fixnums" title="stdlib arithmetic fixnums">
<link rel="next" href="stdlib-arithmetic-exact-bitwise.html#stdlib-arithmetic-exact-bitwise" title="stdlib arithmetic exact bitwise">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d7 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  _Vicare_ is pronounced
the etruscan way.

The package, including its documentation, is distributed under the terms
of the GNU General Public License (GPL) and can be downloaded
from:

        `http://sourceforge.net/projects/vicare-scheme/files/'


the home page of the project is at:

              `http://marcomaggi.github.com/vicare.html'


development takes place at:

                `http://github.com/marcomaggi/vicare/'


and, as a backup, at:

                     `http://gitorious.org/vicare'


and at:

           `http://sourceforge.net/projects/vicare-scheme/'


this project has a mailing list:

             `http://groups.google.com/group/vicare-users'


Copyright (C) 2010-2013 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton Van Straaten.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors, see the ``History'' appendix for details.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library `(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="stdlib-arithmetic-flonums"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="stdlib-arithmetic-exact-bitwise.html#stdlib-arithmetic-exact-bitwise">stdlib arithmetic exact bitwise</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="stdlib-arithmetic-fixnums.html#stdlib-arithmetic-fixnums">stdlib arithmetic fixnums</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="stdlib-arithmetic.html#stdlib-arithmetic">stdlib arithmetic</a>
<hr>
</div>

<h4 class="subsection">5.11.3 Flonums</h4>

<p><a name="index-g_t_0040rsixlibrary_007barithmetic-flonums_007d_002c-library-835"></a><a name="index-Library_002c-_0040rsixlibrary_007barithmetic-flonums_007d-836"></a>

   <p>This section describes the <code>(rnrs arithmetic flonums (6))</code> library.

   <p>This section uses <var>fl</var>, <var>fl1</var>, <var>fl2</var>, etc., as parameter
names for arguments that must be flonums, and <var>ifl</var> as a name for
arguments that must be integer&ndash;valued flonums, i.e., flonums for which
the <code>integer-valued?</code> predicate returns true.

<div class="defun">
&mdash; Procedure: <b>flonum?</b><var> obj<a name="index-flonum_003f-837"></a></var><br>
<blockquote><p>Return <code>#t</code> if <var>obj</var> is a flonum, <code>#f</code> otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>real-&gt;flonum</b><var> x<a name="index-real_002d_003eflonum-838"></a></var><br>
<blockquote><p>Return the best flonum representation of <var>x</var>.

        <p>The value returned is a flonum that is numerically closest to the
argument.

        <blockquote>
<strong>NOTE</strong> If flonums are represented in binary floating point, then
implementations should break ties by preferring the floating&ndash;point
representation whose least significant bit is zero. 
</blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fl=?</b><var> fl1 fl2 fl3 <small class="dots">...</small><a name="index-fl_003d_003f-839"></a></var><br>
&mdash; Procedure: <b>fl&lt;?</b><var> fl1 fl2 fl3 <small class="dots">...</small><a name="index-fl_003c_003f-840"></a></var><br>
&mdash; Procedure: <b>fl&lt;=?</b><var> fl1 fl2 fl3 <small class="dots">...</small><a name="index-fl_003c_003d_003f-841"></a></var><br>
&mdash; Procedure: <b>fl&gt;?</b><var> fl1 fl2 fl3 <small class="dots">...</small><a name="index-fl_003e_003f-842"></a></var><br>
&mdash; Procedure: <b>fl&gt;=?</b><var> fl1 fl2 fl3 <small class="dots">...</small><a name="index-fl_003e_003d_003f-843"></a></var><br>
<blockquote><p>These procedures return <code>#t</code> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing, <code>#f</code> otherwise. 
These predicates must be transitive.

     <pre class="example">          (fl=? +inf.0 +inf.0)            &rArr; #t
          (fl=? -inf.0 +inf.0)            &rArr; #f
          (fl=? -inf.0 -inf.0)            &rArr; #t
          (fl=? 0.0 -0.0)                 &rArr; #t
          (fl&lt;? 0.0 -0.0)                 &rArr; #f
          (fl=? +nan.0 fl)                &rArr; #f
          (fl&lt;? +nan.0 fl)                &rArr; #f
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flinteger?</b><var> fl<a name="index-flinteger_003f-844"></a></var><br>
&mdash; Procedure: <b>flzero?</b><var> fl<a name="index-flzero_003f-845"></a></var><br>
&mdash; Procedure: <b>flpositive?</b><var> fl<a name="index-flpositive_003f-846"></a></var><br>
&mdash; Procedure: <b>flnegative?</b><var> fl<a name="index-flnegative_003f-847"></a></var><br>
&mdash; Procedure: <b>flodd?</b><var> ifl<a name="index-flodd_003f-848"></a></var><br>
&mdash; Procedure: <b>fleven?</b><var> ifl<a name="index-fleven_003f-849"></a></var><br>
&mdash; Procedure: <b>flfinite?</b><var> fl<a name="index-flfinite_003f-850"></a></var><br>
&mdash; Procedure: <b>flinfinite?</b><var> fl<a name="index-flinfinite_003f-851"></a></var><br>
&mdash; Procedure: <b>flnan?</b><var> fl<a name="index-flnan_003f-852"></a></var><br>
<blockquote><p>These numerical predicates test a flonum for a particular property,
returning <code>#t</code> or <code>#f</code>:

          <dl>
<dt><code>flinteger?</code><dd>procedure tests whether the number object is an integer,

          <br><dt><code>flzero?</code><dd>tests whether it is <code>fl=?</code> to zero,

          <br><dt><code>flpositive?</code><dd>tests whether it is greater than zero,

          <br><dt><code>flnegative?</code><dd>tests whether it is less than zero,

          <br><dt><code>flodd?</code><dd>tests whether it is odd,

          <br><dt><code>fleven?</code><dd>tests whether it is even,

          <br><dt><code>flfinite?</code><dd>tests whether it is not an infinity and not a NaN,

          <br><dt><code>flinfinite?</code><dd>tests whether it is an infinity,

          <br><dt><code>flnan?</code><dd>tests whether it is a NaN. 
</dl>

     <pre class="example">          (flnegative? -0.0)              &rArr; #f
          (flfinite?   +inf.0)            &rArr; #f
          (flfinite?   5.0)               &rArr; #t
          (flinfinite? 5.0)               &rArr; #f
          (flinfinite? +inf.0)            &rArr; #t
</pre>
        <blockquote>
<strong>NOTE</strong> <code>(flnegative? -0.0)</code> must return <code>#f</code>, else it
would lose the correspondence with <code>(fl&lt; -0.0 0.0)</code>, which is
<code>#f</code> according to <acronym>IEEE</acronym> 754. 
</blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flmax</b><var> fl1 fl2 <small class="dots">...</small><a name="index-flmax-853"></a></var><br>
&mdash; Procedure: <b>flmin</b><var> fl1 fl2 <small class="dots">...</small><a name="index-flmin-854"></a></var><br>
<blockquote><p>These procedures return the maximum or minimum of their arguments.  They
always return a NaN when one or more of the arguments is a NaN. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fl+</b><var> fl1 <small class="dots">...</small><a name="index-fl_002b-855"></a></var><br>
&mdash; Procedure: <b>fl*</b><var> fl1 <small class="dots">...</small><a name="index-fl_002a-856"></a></var><br>
<blockquote><p>These procedures return the flonum sum or product of their flonum
arguments.  In general, they should return the flonum that best
approximates the mathematical sum or product.  (For implementations that
represent flonums using <acronym>IEEE</acronym> binary floating point, the meaning of
&ldquo;best&rdquo; is defined by the <acronym>IEEE</acronym> standards.)

     <pre class="example">          (fl+ +inf.0 -inf.0)             &rArr;  +nan.0
          (fl+ +nan.0 <var>fl</var>)           &rArr;  +nan.0
          (fl* +nan.0 <var>fl</var>)           &rArr;  +nan.0
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fl-</b><var> fl1 fl2 <small class="dots">...</small><a name="index-fl_002d-857"></a></var><br>
&mdash; Procedure: <b>fl-</b><var> fl<a name="index-fl_002d-858"></a></var><br>
&mdash; Procedure: <b>fl/</b><var> fl1 fl2 <small class="dots">...</small><a name="index-fl_002f-859"></a></var><br>
&mdash; Procedure: <b>fl/</b><var> fl<a name="index-fl_002f-860"></a></var><br>
<blockquote><p>With two or more arguments, these procedures return the flonum
difference or quotient of their flonum arguments, associating to the
left.

        <p>With one argument, however, they return the additive or multiplicative
flonum inverse of their argument.

        <p>In general, they should return the flonum that best approximates the
mathematical difference or quotient.  (For implementations that
represent flonums using <acronym>IEEE</acronym> binary floating point, the meaning of
&ldquo;best&rdquo; is reasonably well&ndash;defined by the <acronym>IEEE</acronym> standards.)

     <pre class="example">          (fl- +inf.0 +inf.0)             &rArr;  +nan.0
</pre>
        <p>For undefined quotients, <code>fl/</code> behaves as specified by the <acronym>IEEE</acronym>
standards:

     <pre class="example">          (fl/ 1.0 0.0)                   &rArr; +inf.0
          (fl/ -1.0 0.0)                  &rArr; -inf.0
          (fl/ 0.0 0.0)                   &rArr; +nan.0
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flabs</b><var> fl<a name="index-flabs-861"></a></var><br>
<blockquote><p>Return the absolute value of <var>fl</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fldiv-and-mod</b><var> fl1 fl2<a name="index-fldiv_002dand_002dmod-862"></a></var><br>
&mdash; Procedure: <b>fldiv</b><var> fl1 fl2<a name="index-fldiv-863"></a></var><br>
&mdash; Procedure: <b>flmod</b><var> fl1 fl2<a name="index-flmod-864"></a></var><br>
&mdash; Procedure: <b>fldiv0-and-mod0</b><var> fl1 fl2<a name="index-fldiv0_002dand_002dmod0-865"></a></var><br>
&mdash; Procedure: <b>fldiv0</b><var> fl1 fl2<a name="index-fldiv0-866"></a></var><br>
&mdash; Procedure: <b>flmod0</b><var> fl1 fl2<a name="index-flmod0-867"></a></var><br>
<blockquote><p>These procedures implement number&ndash;theoretic integer division and return
the results of the corresponding mathematical operations specified in
report section <a href="baselib-math-semantics-integer.html#baselib-math-semantics-integer">baselib math semantics integer</a>.

        <p>In the cases where the mathematical requirements in <a href="baselib-math-semantics.html#baselib-math-semantics">baselib math semantics</a> cannot be satisfied by any number object, either an exception
is raised with condition type <code>&amp;implementation-restriction</code>, or
unspecified flonums (one for <code>fldiv</code>, <code>flmod</code>, <code>fldiv0</code>
and <code>flmod0</code>, two for <code>fldiv-and-mod</code> and
<code>fldiv0-and-mod0</code>) are returned.

     <pre class="example">          (fldiv <var>fl1</var> <var>fl2</var>)         &rArr; <var>fl1</var> div <var>fl2</var>
          (flmod <var>fl1</var> <var>fl2</var>)         &rArr; <var>fl1</var> mod <var>fl2</var>
          (fldiv-and-mod <var>fl1</var> <var>fl2</var>) &rArr; <var>fl1</var> div <var>fl2</var>, <var>fl1</var> mod <var>fl2</var>
                                                  ; two return values
          (fldiv0 <var>fl1</var> <var>fl2</var>)        &rArr; <var>fl1</var> div_0 <var>fl2</var>
          (flmod0 <var>fl1</var> <var>fl2</var>)        &rArr; <var>fl1</var> mod_0 <var>fl2</var>
          (fldiv0-and-mod0 <var>fl1</var> <var>fl2</var>)
          &rArr; <var>fl1</var> div_0 <var>fl2</var>, <var>fl1</var> mod_0 <var>fl2</var>
             ; two return values
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flnumerator</b><var> fl<a name="index-flnumerator-868"></a></var><br>
&mdash; Procedure: <b>fldenominator</b><var> fl<a name="index-fldenominator-869"></a></var><br>
<blockquote><p>These procedures return the numerator or denominator of <var>fl</var> as a
flonum; the result is computed as if <var>fl</var> was represented as a
fraction in lowest terms.  The denominator is always positive.  The
denominator of 0.0 is defined to be 1.0.

     <pre class="example">          (flnumerator +inf.0)           &rArr; +inf.0
          (flnumerator -inf.0)           &rArr; -inf.0
          (fldenominator +inf.0)         &rArr; 1.0
          (fldenominator -inf.0)         &rArr; 1.0
          (flnumerator 0.75)             &rArr; 3.0 ; probably
          (fldenominator 0.75)           &rArr; 4.0 ; probably
</pre>
        <p>Implementations should implement following behavior:

     <pre class="example">          (flnumerator -0.0)             &rArr; -0.0
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flfloor</b><var> fl<a name="index-flfloor-870"></a></var><br>
&mdash; Procedure: <b>flceiling</b><var> fl<a name="index-flceiling-871"></a></var><br>
&mdash; Procedure: <b>fltruncate</b><var> fl<a name="index-fltruncate-872"></a></var><br>
&mdash; Procedure: <b>flround</b><var> fl<a name="index-flround-873"></a></var><br>
<blockquote><p>These procedures return integral flonums for flonum arguments that are
not infinities or NaNs.

          <dl>
<dt><code>flfloor</code><dd>Returns the largest integral flonum not larger than <var>fl</var>.

          <br><dt><code>flceiling</code><dd>Returns the smallest integral flonum not smaller than <var>fl</var>.

          <br><dt><code>fltruncate</code><dd>Returns the integral flonum closest to <var>fl</var> whose absolute value is
not larger than the absolute value of <var>fl</var>.

          <br><dt><code>flround</code><dd>Returns the closest integral flonum to <var>fl</var>, rounding to even when
<var>fl</var> represents a number halfway between two integers. 
</dl>

        <p>Although infinities and NaNs are not integer objects, these procedures
return an infinity when given an infinity as an argument, and a NaN when
given a NaN:

     <pre class="example">          (flfloor +inf.0)                &rArr; +inf.0
          (flceiling -inf.0)              &rArr; -inf.0
          (fltruncate +nan.0)             &rArr; +nan.0
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flexp</b><var> fl<a name="index-flexp-874"></a></var><br>
&mdash; Procedure: <b>fllog</b><var> fl<a name="index-fllog-875"></a></var><br>
&mdash; Procedure: <b>fllog</b><var> fl1 fl2<a name="index-fllog-876"></a></var><br>
&mdash; Procedure: <b>flsin</b><var> fl<a name="index-flsin-877"></a></var><br>
&mdash; Procedure: <b>flcos</b><var> fl<a name="index-flcos-878"></a></var><br>
&mdash; Procedure: <b>fltan</b><var> fl<a name="index-fltan-879"></a></var><br>
&mdash; Procedure: <b>flasin</b><var> fl<a name="index-flasin-880"></a></var><br>
&mdash; Procedure: <b>flacos</b><var> fl<a name="index-flacos-881"></a></var><br>
&mdash; Procedure: <b>flatan</b><var> fl<a name="index-flatan-882"></a></var><br>
&mdash; Procedure: <b>flatan</b><var> fl1 fl2<a name="index-flatan-883"></a></var><br>
<blockquote><p>These procedures compute the usual transcendental functions.

          <dl>
<dt><code>flexp</code><dd>Computes the base-E exponential of <var>fl</var>.

          <br><dt><code>fllog</code><dd>With a single argument computes the natural logarithm of <var>fl</var> (not
the base ten logarithm); <code>(fllog </code><var>fl1</var> <var>fl2</var><code>)</code> computes
the base&ndash;<var>fl2</var> logarithm of <var>fl1</var>.

          <br><dt><code>flasin</code><dt><code>flacos</code><dt><code>flatan</code><dd>Compute arcsine, arccosine, and arctangent, respectively.  <code>(flatan
</code><var>fl1</var> <var>fl2</var><code>)</code> computes the arc tangent of <var>fl1</var>/<var>fl2</var>. 
</dl>

        <p><a href="baselib-math-ops-trascend.html#baselib-math-ops-trascend">baselib math ops trascend</a> for the underlying mathematical
operations.  In the event that these operations do not yield a real
result for the given arguments, the result may be a NaN, or may be some
unspecified flonum.

        <p>Implementations that use <acronym>IEEE</acronym> binary floating&ndash;point arithmetic
should follow the relevant standards for these procedures.

     <pre class="example">          (flexp +inf.0)          &rArr; +inf.0
          (flexp -inf.0)          &rArr; 0.0
          (fllog +inf.0)          &rArr; +inf.0
          (fllog 0.0)             &rArr; -inf.0
          (fllog -0.0)            &rArr; unspecified ; if -0.0 is distinguished
          (fllog -inf.0)          &rArr; +nan.0
          (flatan -inf.0)         &rArr; -1.5707963267948965  ; approximately
          (flatan +inf.0)         &rArr; 1.5707963267948965   ; approximately
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flsqrt</b><var> fl<a name="index-flsqrt-884"></a></var><br>
<blockquote><p>Returns the principal square root of <var>fl</var>.  For -0.0,
<code>flsqrt</code> should return -0.0; for other negative arguments,
the result may be a NaN or some unspecified flonum.

     <pre class="example">          (flsqrt +inf.0)         &rArr; +inf.0
          (flsqrt -0.0)           &rArr; -0.0
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flexpt</b><var> fl1 fl2<a name="index-flexpt-885"></a></var><br>
<blockquote><p>Either <var>fl1</var> should be non&ndash;negative, or, if <var>fl1</var> is negative,
<var>fl2</var> should be an integer object.

        <p>The <code>flexpt</code> procedure returns <var>fl1</var> raised to the power
<var>fl2</var>.  If <var>fl1</var> is negative and <var>fl2</var> is not an integer
object, the result may be a NaN, or may be some unspecified flonum.

        <p>If <var>fl1</var> and <var>fl2</var> are both zero, the result is 1.0.  If
<var>fl1</var> is zero and <var>fl2</var> is positive, the result is zero.  If
<var>fl1</var> is negative, the result may be a NaN, or may be some
unspecified flonum. 
</p></blockquote></div>

   <p><a name="index-g_t_0026no_002dinfinities-886"></a>

<div class="defun">
&mdash; Condition Type: <b>&amp;no-infinities</b><var><a name="index-g_t_0026no_002dinfinities-887"></a></var><br>
&mdash; Procedure: <b>make-no-infinities-violation</b><var><a name="index-make_002dno_002dinfinities_002dviolation-888"></a></var><br>
&mdash; Procedure: <b>no-infinities-violation?</b><var> obj<a name="index-no_002dinfinities_002dviolation_003f-889"></a></var><br>
&mdash; Condition Type: <b>&amp;no-nans</b><var><a name="index-g_t_0026no_002dnans-890"></a></var><br>
&mdash; Procedure: <b>make-no-nans-violation</b><var><a name="index-make_002dno_002dnans_002dviolation-891"></a></var><br>
&mdash; Procedure: <b>no-nans-violation?</b><var> obj<a name="index-no_002dnans_002dviolation_003f-892"></a></var><br>
<blockquote><p>These condition types could be defined by the following code:

     <pre class="example">          (define-condition-type &amp;no-infinities
              &amp;implementation-restriction
            make-no-infinities-violation
            no-infinities-violation?)
          
          (define-condition-type &amp;no-nans
              &amp;implementation-restriction
            make-no-nans-violation no-nans-violation?)
</pre>
        <p>These types describe that a program has executed an arithmetic
operations that is specified to return an infinity or a NaN,
respectively, on a Scheme implementation that is not able to represent
the infinity or NaN.  <a href="baselib-math-infinities.html#baselib-math-infinities">baselib math infinities</a>. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fixnum-&gt;flonum</b><var> fx<a name="index-fixnum_002d_003eflonum-893"></a></var><br>
<blockquote><p>Return a flonum that is numerically closest to <var>fx</var>.

        <blockquote>
<strong>NOTE</strong> The result of this procedure may not be numerically equal
to <var>fx</var>, because the fixnum precision may be greater than the flonum
precision. 
</blockquote>
        </p></blockquote></div>

<!-- page -->
   </body></html>

