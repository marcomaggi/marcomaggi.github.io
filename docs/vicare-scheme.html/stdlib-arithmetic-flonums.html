<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This document describes version 0.4d1 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit and 64-bit
processors.  Vicare is pronounced the etruscan way.

The package, including its documentation, is distributed under the terms
of the GNU General Public License (GPL) and can be downloaded
from:

https://bitbucket.org/marcomaggi/vicare-scheme/downloads

the home page of the project is at:

http://marcomaggi.github.io/vicare.html

development takes place at:

http://github.com/marcomaggi/vicare/

and, as a backup, at:

https://bitbucket.org/marcomaggi/vicare-scheme/

Copyright (C) 2010-2017 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton Van Straaten.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors, see the "History" appendix for details.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library (vicare formations) is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License version 3 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see
http://www.gnu.org/licenses/.

Trademarks used herein are the property of their respective owners. -->
<!-- Created by GNU Texinfo 6.3, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Vicare Scheme: stdlib arithmetic flonums</title>

<meta name="description" content="Vicare Scheme: stdlib arithmetic flonums">
<meta name="keywords" content="Vicare Scheme: stdlib arithmetic flonums">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="concept-index.html#concept-index" rel="index" title="concept index">
<link href="stdlib-arithmetic.html#stdlib-arithmetic" rel="up" title="stdlib arithmetic">
<link href="stdlib-arithmetic-exact-bitwise.html#stdlib-arithmetic-exact-bitwise" rel="next" title="stdlib arithmetic exact bitwise">
<link href="stdlib-arithmetic-fixnums.html#stdlib-arithmetic-fixnums" rel="prev" title="stdlib arithmetic fixnums">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="stdlib-arithmetic-flonums"></a>
<div class="header">
<p>
Next: <a href="stdlib-arithmetic-exact-bitwise.html#stdlib-arithmetic-exact-bitwise" accesskey="n" rel="next">stdlib arithmetic exact bitwise</a>, Previous: <a href="stdlib-arithmetic-fixnums.html#stdlib-arithmetic-fixnums" accesskey="p" rel="prev">stdlib arithmetic fixnums</a>, Up: <a href="stdlib-arithmetic.html#stdlib-arithmetic" accesskey="u" rel="up">stdlib arithmetic</a> &nbsp; [<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Flonums"></a>
<h4 class="subsection">5.11.3 Flonums</h4>


<a name="index-_0028rnrs-arithmetic-flonums-_00286_0029_0029_002c-library"></a>
<a name="index-Library_002c-_0028rnrs-arithmetic-flonums-_00286_0029_0029"></a>



<p>This section describes the <code>(rnrs arithmetic flonums (6))</code> library.
</p>
<p>This section uses <var>fl</var>, <var>fl1</var>, <var>fl2</var>, etc., as parameter
names for arguments that must be flonums, and <var>ifl</var> as a name for
arguments that must be integer&ndash;valued flonums, i.e., flonums for which
the <code>integer-valued?</code> predicate returns true.
</p>

<dl>
<dt><a name="index-flonum_003f"></a>Procedure: <strong>flonum?</strong> <em><var>obj</var></em></dt>
<dd><p>Return <code>#t</code> if <var>obj</var> is a flonum, <code>#f</code> otherwise.
</p></dd></dl>


<dl>
<dt><a name="index-real_002d_003eflonum"></a>Procedure: <strong>real-&gt;flonum</strong> <em><var>x</var></em></dt>
<dd><p>Return the best flonum representation of <var>x</var>.
</p>
<p>The value returned is a flonum that is numerically closest to the
argument.
</p>
<blockquote>
<p><strong>NOTE</strong> If flonums are represented in binary floating point, then
implementations should break ties by preferring the floating&ndash;point
representation whose least significant bit is zero.
</p></blockquote>
</dd></dl>


<dl>
<dt><a name="index-fl_003d_003f"></a>Procedure: <strong>fl=?</strong> <em><var>fl1</var> <var>fl2</var> <var>fl3</var> &hellip;</em></dt>
<dt><a name="index-fl_003c_003f"></a>Procedure: <strong>fl&lt;?</strong> <em><var>fl1</var> <var>fl2</var> <var>fl3</var> &hellip;</em></dt>
<dt><a name="index-fl_003c_003d_003f"></a>Procedure: <strong>fl&lt;=?</strong> <em><var>fl1</var> <var>fl2</var> <var>fl3</var> &hellip;</em></dt>
<dt><a name="index-fl_003e_003f"></a>Procedure: <strong>fl&gt;?</strong> <em><var>fl1</var> <var>fl2</var> <var>fl3</var> &hellip;</em></dt>
<dt><a name="index-fl_003e_003d_003f"></a>Procedure: <strong>fl&gt;=?</strong> <em><var>fl1</var> <var>fl2</var> <var>fl3</var> &hellip;</em></dt>
<dd><p>These procedures return <code>#t</code> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing, <code>#f</code> otherwise.
These predicates must be transitive.
</p>
<div class="example">
<pre class="example">(fl=? +inf.0 +inf.0)            &rArr; #t
(fl=? -inf.0 +inf.0)            &rArr; #f
(fl=? -inf.0 -inf.0)            &rArr; #t
(fl=? 0.0 -0.0)                 &rArr; #t
(fl&lt;? 0.0 -0.0)                 &rArr; #f
(fl=? +nan.0 fl)                &rArr; #f
(fl&lt;? +nan.0 fl)                &rArr; #f
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-flinteger_003f"></a>Procedure: <strong>flinteger?</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flzero_003f"></a>Procedure: <strong>flzero?</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flpositive_003f"></a>Procedure: <strong>flpositive?</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flnegative_003f"></a>Procedure: <strong>flnegative?</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flodd_003f"></a>Procedure: <strong>flodd?</strong> <em><var>ifl</var></em></dt>
<dt><a name="index-fleven_003f"></a>Procedure: <strong>fleven?</strong> <em><var>ifl</var></em></dt>
<dt><a name="index-flfinite_003f"></a>Procedure: <strong>flfinite?</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flinfinite_003f"></a>Procedure: <strong>flinfinite?</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flnan_003f"></a>Procedure: <strong>flnan?</strong> <em><var>fl</var></em></dt>
<dd><p>These numerical predicates test a flonum for a particular property,
returning <code>#t</code> or <code>#f</code>:
</p>
<dl compact="compact">
<dt><code>flinteger?</code></dt>
<dd><p>procedure tests whether the number object is an integer,
</p>
</dd>
<dt><code>flzero?</code></dt>
<dd><p>tests whether it is <code>fl=?</code> to zero,
</p>
</dd>
<dt><code>flpositive?</code></dt>
<dd><p>tests whether it is greater than zero,
</p>
</dd>
<dt><code>flnegative?</code></dt>
<dd><p>tests whether it is less than zero,
</p>
</dd>
<dt><code>flodd?</code></dt>
<dd><p>tests whether it is odd,
</p>
</dd>
<dt><code>fleven?</code></dt>
<dd><p>tests whether it is even,
</p>
</dd>
<dt><code>flfinite?</code></dt>
<dd><p>tests whether it is not an infinity and not a NaN,
</p>
</dd>
<dt><code>flinfinite?</code></dt>
<dd><p>tests whether it is an infinity,
</p>
</dd>
<dt><code>flnan?</code></dt>
<dd><p>tests whether it is a NaN.
</p></dd>
</dl>

<div class="example">
<pre class="example">(flnegative? -0.0)              &rArr; #f
(flfinite?   +inf.0)            &rArr; #f
(flfinite?   5.0)               &rArr; #t
(flinfinite? 5.0)               &rArr; #f
(flinfinite? +inf.0)            &rArr; #t
</pre></div>

<blockquote>
<p><strong>NOTE</strong> <code>(flnegative? -0.0)</code> must return <code>#f</code>, else it
would lose the correspondence with <code>(fl&lt; -0.0 0.0)</code>, which is
<code>#f</code> according to <acronym>IEEE</acronym> 754.
</p></blockquote>
</dd></dl>


<dl>
<dt><a name="index-flmax"></a>Procedure: <strong>flmax</strong> <em><var>fl1</var> <var>fl2</var> &hellip;</em></dt>
<dt><a name="index-flmin"></a>Procedure: <strong>flmin</strong> <em><var>fl1</var> <var>fl2</var> &hellip;</em></dt>
<dd><p>These procedures return the maximum or minimum of their arguments.  They
always return a NaN when one or more of the arguments is a NaN.
</p></dd></dl>


<dl>
<dt><a name="index-fl_002b"></a>Procedure: <strong>fl+</strong> <em><var>fl1</var> &hellip;</em></dt>
<dt><a name="index-fl_002a"></a>Procedure: <strong>fl*</strong> <em><var>fl1</var> &hellip;</em></dt>
<dd><p>These procedures return the flonum sum or product of their flonum
arguments.  In general, they should return the flonum that best
approximates the mathematical sum or product.  (For implementations that
represent flonums using <acronym>IEEE</acronym> binary floating point, the meaning of
&ldquo;best&rdquo; is defined by the <acronym>IEEE</acronym> standards.)
</p>
<div class="example">
<pre class="example">(fl+ +inf.0 -inf.0)             &rArr;  +nan.0
(fl+ +nan.0 <var>fl</var>)           &rArr;  +nan.0
(fl* +nan.0 <var>fl</var>)           &rArr;  +nan.0
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-fl_002d"></a>Procedure: <strong>fl-</strong> <em><var>fl1</var> <var>fl2</var> &hellip;</em></dt>
<dt><a name="index-fl_002d-1"></a>Procedure: <strong>fl-</strong> <em><var>fl</var></em></dt>
<dt><a name="index-fl_002f"></a>Procedure: <strong>fl/</strong> <em><var>fl1</var> <var>fl2</var> &hellip;</em></dt>
<dt><a name="index-fl_002f-1"></a>Procedure: <strong>fl/</strong> <em><var>fl</var></em></dt>
<dd><p>With two or more arguments, these procedures return the flonum
difference or quotient of their flonum arguments, associating to the
left.
</p>
<p>With one argument, however, they return the additive or multiplicative
flonum inverse of their argument.
</p>
<p>In general, they should return the flonum that best approximates the
mathematical difference or quotient.  (For implementations that
represent flonums using <acronym>IEEE</acronym> binary floating point, the meaning of
&ldquo;best&rdquo; is reasonably well&ndash;defined by the <acronym>IEEE</acronym> standards.)
</p>
<div class="example">
<pre class="example">(fl- +inf.0 +inf.0)             &rArr;  +nan.0
</pre></div>

<p>For undefined quotients, <code>fl/</code> behaves as specified by the <acronym>IEEE</acronym>
standards:
</p>
<div class="example">
<pre class="example">(fl/ 1.0 0.0)                   &rArr; +inf.0
(fl/ -1.0 0.0)                  &rArr; -inf.0
(fl/ 0.0 0.0)                   &rArr; +nan.0
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-flabs"></a>Procedure: <strong>flabs</strong> <em><var>fl</var></em></dt>
<dd><p>Return the absolute value of <var>fl</var>.
</p></dd></dl>


<dl>
<dt><a name="index-fldiv_002dand_002dmod"></a>Procedure: <strong>fldiv-and-mod</strong> <em><var>fl1</var> <var>fl2</var></em></dt>
<dt><a name="index-fldiv"></a>Procedure: <strong>fldiv</strong> <em><var>fl1</var> <var>fl2</var></em></dt>
<dt><a name="index-flmod"></a>Procedure: <strong>flmod</strong> <em><var>fl1</var> <var>fl2</var></em></dt>
<dt><a name="index-fldiv0_002dand_002dmod0"></a>Procedure: <strong>fldiv0-and-mod0</strong> <em><var>fl1</var> <var>fl2</var></em></dt>
<dt><a name="index-fldiv0"></a>Procedure: <strong>fldiv0</strong> <em><var>fl1</var> <var>fl2</var></em></dt>
<dt><a name="index-flmod0"></a>Procedure: <strong>flmod0</strong> <em><var>fl1</var> <var>fl2</var></em></dt>
<dd><p>These procedures implement number&ndash;theoretic integer division and return
the results of the corresponding mathematical operations specified in
report section <a href="baselib-math-semantics-integer.html#baselib-math-semantics-integer">baselib math semantics integer</a>.
</p>
<p>In the cases where the mathematical requirements in <a href="baselib-math-semantics.html#baselib-math-semantics">baselib math semantics</a> cannot be satisfied by any number object, either an exception
is raised with condition type <code>&amp;implementation-restriction</code>, or
unspecified flonums (one for <code>fldiv</code>, <code>flmod</code>, <code>fldiv0</code>
and <code>flmod0</code>, two for <code>fldiv-and-mod</code> and
<code>fldiv0-and-mod0</code>) are returned.
</p>
<div class="example">
<pre class="example">(fldiv <var>fl1</var> <var>fl2</var>)         &rArr; <var>fl1</var> div <var>fl2</var>
(flmod <var>fl1</var> <var>fl2</var>)         &rArr; <var>fl1</var> mod <var>fl2</var>
(fldiv-and-mod <var>fl1</var> <var>fl2</var>) &rArr; <var>fl1</var> div <var>fl2</var>, <var>fl1</var> mod <var>fl2</var>
                                        ; two return values
(fldiv0 <var>fl1</var> <var>fl2</var>)        &rArr; <var>fl1</var> div_0 <var>fl2</var>
(flmod0 <var>fl1</var> <var>fl2</var>)        &rArr; <var>fl1</var> mod_0 <var>fl2</var>
(fldiv0-and-mod0 <var>fl1</var> <var>fl2</var>)
&rArr; <var>fl1</var> div_0 <var>fl2</var>, <var>fl1</var> mod_0 <var>fl2</var>
   ; two return values
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-flnumerator"></a>Procedure: <strong>flnumerator</strong> <em><var>fl</var></em></dt>
<dt><a name="index-fldenominator"></a>Procedure: <strong>fldenominator</strong> <em><var>fl</var></em></dt>
<dd><p>These procedures return the numerator or denominator of <var>fl</var> as a
flonum; the result is computed as if <var>fl</var> was represented as a
fraction in lowest terms.  The denominator is always positive.  The
denominator of <em>0.0</em> is defined to be <em>1.0</em>.
</p>
<div class="example">
<pre class="example">(flnumerator +inf.0)           &rArr; +inf.0
(flnumerator -inf.0)           &rArr; -inf.0
(fldenominator +inf.0)         &rArr; 1.0
(fldenominator -inf.0)         &rArr; 1.0
(flnumerator 0.75)             &rArr; 3.0 ; probably
(fldenominator 0.75)           &rArr; 4.0 ; probably
</pre></div>

<p>Implementations should implement following behavior:
</p>
<div class="example">
<pre class="example">(flnumerator -0.0)             &rArr; -0.0
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-flfloor"></a>Procedure: <strong>flfloor</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flceiling"></a>Procedure: <strong>flceiling</strong> <em><var>fl</var></em></dt>
<dt><a name="index-fltruncate"></a>Procedure: <strong>fltruncate</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flround"></a>Procedure: <strong>flround</strong> <em><var>fl</var></em></dt>
<dd><p>These procedures return integral flonums for flonum arguments that are
not infinities or NaNs.
</p>
<dl compact="compact">
<dt><code>flfloor</code></dt>
<dd><p>Returns the largest integral flonum not larger than <var>fl</var>.
</p>
</dd>
<dt><code>flceiling</code></dt>
<dd><p>Returns the smallest integral flonum not smaller than <var>fl</var>.
</p>
</dd>
<dt><code>fltruncate</code></dt>
<dd><p>Returns the integral flonum closest to <var>fl</var> whose absolute value is
not larger than the absolute value of <var>fl</var>.
</p>
</dd>
<dt><code>flround</code></dt>
<dd><p>Returns the closest integral flonum to <var>fl</var>, rounding to even when
<var>fl</var> represents a number halfway between two integers.
</p></dd>
</dl>

<p>Although infinities and NaNs are not integer objects, these procedures
return an infinity when given an infinity as an argument, and a NaN when
given a NaN:
</p>
<div class="example">
<pre class="example">(flfloor +inf.0)                &rArr; +inf.0
(flceiling -inf.0)              &rArr; -inf.0
(fltruncate +nan.0)             &rArr; +nan.0
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-flexp"></a>Procedure: <strong>flexp</strong> <em><var>fl</var></em></dt>
<dt><a name="index-fllog"></a>Procedure: <strong>fllog</strong> <em><var>fl</var></em></dt>
<dt><a name="index-fllog-1"></a>Procedure: <strong>fllog</strong> <em><var>fl1</var> <var>fl2</var></em></dt>
<dt><a name="index-flsin"></a>Procedure: <strong>flsin</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flcos"></a>Procedure: <strong>flcos</strong> <em><var>fl</var></em></dt>
<dt><a name="index-fltan"></a>Procedure: <strong>fltan</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flasin"></a>Procedure: <strong>flasin</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flacos"></a>Procedure: <strong>flacos</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flatan"></a>Procedure: <strong>flatan</strong> <em><var>fl</var></em></dt>
<dt><a name="index-flatan-1"></a>Procedure: <strong>flatan</strong> <em><var>fl1</var> <var>fl2</var></em></dt>
<dd><p>These procedures compute the usual transcendental functions.
</p>
<dl compact="compact">
<dt><code>flexp</code></dt>
<dd><p>Computes the base-E exponential of <var>fl</var>.
</p>
</dd>
<dt><code>fllog</code></dt>
<dd><p>With a single argument computes the natural logarithm of <var>fl</var> (not
the base ten logarithm); <code>(fllog <var>fl1</var> <var>fl2</var>)</code> computes
the base&ndash;<var>fl2</var> logarithm of <var>fl1</var>.
</p>
</dd>
<dt><code>flasin</code></dt>
<dt><code>flacos</code></dt>
<dt><code>flatan</code></dt>
<dd><p>Compute arcsine, arccosine, and arctangent, respectively.  <code>(flatan
<var>fl1</var> <var>fl2</var>)</code> computes the arc tangent of <var>fl1</var>/<var>fl2</var>.
</p></dd>
</dl>

<p><a href="baselib-math-ops-trascend.html#baselib-math-ops-trascend">baselib math ops trascend</a> for the underlying mathematical
operations.  In the event that these operations do not yield a real
result for the given arguments, the result may be a NaN, or may be some
unspecified flonum.
</p>
<p>Implementations that use <acronym>IEEE</acronym> binary floating&ndash;point arithmetic
should follow the relevant standards for these procedures.
</p>
<div class="example">
<pre class="example">(flexp +inf.0)          &rArr; +inf.0
(flexp -inf.0)          &rArr; 0.0
(fllog +inf.0)          &rArr; +inf.0
(fllog 0.0)             &rArr; -inf.0
(fllog -0.0)            &rArr; unspecified ; if -0.0 is distinguished
(fllog -inf.0)          &rArr; +nan.0
(flatan -inf.0)         &rArr; -1.5707963267948965  ; approximately
(flatan +inf.0)         &rArr; 1.5707963267948965   ; approximately
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-flsqrt"></a>Procedure: <strong>flsqrt</strong> <em><var>fl</var></em></dt>
<dd><p>Returns the principal square root of <var>fl</var>.  For <em>-0.0</em>,
<code>flsqrt</code> should return <em>-0.0</em>; for other negative arguments,
the result may be a NaN or some unspecified flonum.
</p>
<div class="example">
<pre class="example">(flsqrt +inf.0)         &rArr; +inf.0
(flsqrt -0.0)           &rArr; -0.0
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-flexpt"></a>Procedure: <strong>flexpt</strong> <em><var>fl1</var> <var>fl2</var></em></dt>
<dd><p>Either <var>fl1</var> should be non&ndash;negative, or, if <var>fl1</var> is negative,
<var>fl2</var> should be an integer object.
</p>
<p>The <code>flexpt</code> procedure returns <var>fl1</var> raised to the power
<var>fl2</var>.  If <var>fl1</var> is negative and <var>fl2</var> is not an integer
object, the result may be a NaN, or may be some unspecified flonum.
</p>
<p>If <var>fl1</var> and <var>fl2</var> are both zero, the result is <em>1.0</em>.  If
<var>fl1</var> is zero and <var>fl2</var> is positive, the result is zero.  If
<var>fl1</var> is negative, the result may be a NaN, or may be some
unspecified flonum.
</p></dd></dl>


<a name="index-_0026no_002dinfinities-1"></a>
<dl>
<dt><a name="index-_0026no_002dinfinities"></a>Condition Type: <strong>&amp;no-infinities</strong></dt>
<dt><a name="index-make_002dno_002dinfinities_002dviolation"></a>Procedure: <strong>make-no-infinities-violation</strong></dt>
<dt><a name="index-no_002dinfinities_002dviolation_003f"></a>Procedure: <strong>no-infinities-violation?</strong> <em><var>obj</var></em></dt>
<dt><a name="index-_0026no_002dnans"></a>Condition Type: <strong>&amp;no-nans</strong></dt>
<dt><a name="index-make_002dno_002dnans_002dviolation"></a>Procedure: <strong>make-no-nans-violation</strong></dt>
<dt><a name="index-no_002dnans_002dviolation_003f"></a>Procedure: <strong>no-nans-violation?</strong> <em><var>obj</var></em></dt>
<dd><p>These condition types could be defined by the following code:
</p>
<div class="example">
<pre class="example">(define-condition-type &amp;no-infinities
    &amp;implementation-restriction
  make-no-infinities-violation
  no-infinities-violation?)

(define-condition-type &amp;no-nans
    &amp;implementation-restriction
  make-no-nans-violation no-nans-violation?)
</pre></div>

<p>These types describe that a program has executed an arithmetic
operations that is specified to return an infinity or a NaN,
respectively, on a Scheme implementation that is not able to represent
the infinity or NaN.  <a href="baselib-math-infinities.html#baselib-math-infinities">baselib math infinities</a>.
</p></dd></dl>


<dl>
<dt><a name="index-fixnum_002d_003eflonum"></a>Procedure: <strong>fixnum-&gt;flonum</strong> <em><var>fx</var></em></dt>
<dd><p>Return a flonum that is numerically closest to <var>fx</var>.
</p>
<blockquote>
<p><strong>NOTE</strong> The result of this procedure may not be numerically equal
to <var>fx</var>, because the fixnum precision may be greater than the flonum
precision.
</p></blockquote>
</dd></dl>


<hr>
<div class="header">
<p>
Next: <a href="stdlib-arithmetic-exact-bitwise.html#stdlib-arithmetic-exact-bitwise" accesskey="n" rel="next">stdlib arithmetic exact bitwise</a>, Previous: <a href="stdlib-arithmetic-fixnums.html#stdlib-arithmetic-fixnums" accesskey="p" rel="prev">stdlib arithmetic fixnums</a>, Up: <a href="stdlib-arithmetic.html#stdlib-arithmetic" accesskey="u" rel="up">stdlib arithmetic</a> &nbsp; [<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
