<html lang="en">
<head>
<title>srfi strings spec fold - Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="srfi-strings-spec.html#srfi-strings-spec" title="srfi strings spec">
<link rel="prev" href="srfi-strings-spec-append.html#srfi-strings-spec-append" title="srfi strings spec append">
<link rel="next" href="srfi-strings-spec-replicate.html#srfi-strings-spec-replicate" title="srfi strings spec replicate">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d4 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  _Vicare_ is pronounced
the etruscan way.

The package, including its documentation, is distributed under the terms
of the GNU General Public License (GPL) and can be downloaded
from:

        `http://sourceforge.net/projects/vicare-scheme/files/'


the home page of the project is at:

              `http://marcomaggi.github.com/vicare.html'


development takes place at:

                `http://github.com/marcomaggi/vicare/'


and, as a backup, at:

                     `http://gitorious.org/vicare'


and at:

           `http://sourceforge.net/projects/vicare-scheme/'


this project has a mailing list:

             `http://groups.google.com/group/vicare-users'


Copyright (C) 2010-2013 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton Van Straaten.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors, see the ``History'' appendix for details.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library `(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="srfi-strings-spec-fold"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="srfi-strings-spec-replicate.html#srfi-strings-spec-replicate">srfi strings spec replicate</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="srfi-strings-spec-append.html#srfi-strings-spec-append">srfi strings spec append</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="srfi-strings-spec.html#srfi-strings-spec">srfi strings spec</a>
<hr>
</div>

<h5 class="subsubsection">14.8.3.12 Fold, unfold and map</h5>

<div class="defun">
&mdash; Function: <b>string-map</b><var> proc str<a name="index-string_002dmap-4455"></a></var><br>
&mdash; Function: <b>string-map</b><var> proc str start<a name="index-string_002dmap-4456"></a></var><br>
&mdash; Function: <b>string-map</b><var> proc str start end<a name="index-string_002dmap-4457"></a></var><br>
<blockquote><p><var>proc</var> is a char&ndash;to&ndash;char procedure and it is mapped over the
selected substring of <var>str</var>; return the result string and does not
alter its <var>str</var> parameter.

        <blockquote>
<strong>NOTE</strong> The order in which <var>proc</var> is applied to the elements
of <var>str</var> is not specified. 
</blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: <b>string-map!</b><var> proc str<a name="index-string_002dmap_0021-4458"></a></var><br>
&mdash; Function: <b>string-map!</b><var> proc str start<a name="index-string_002dmap_0021-4459"></a></var><br>
&mdash; Function: <b>string-map!</b><var> proc str start end<a name="index-string_002dmap_0021-4460"></a></var><br>
<blockquote><p>In&ndash;place side&ndash;effecting variant. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>string-for-each</b><var> proc str<a name="index-string_002dfor_002deach-4461"></a></var><br>
&mdash; Function: <b>string-for-each</b><var> proc str start<a name="index-string_002dfor_002deach-4462"></a></var><br>
&mdash; Function: <b>string-for-each</b><var> proc str start end<a name="index-string_002dfor_002deach-4463"></a></var><br>
<blockquote><p>Apply <var>proc</var> to each character in <var>str</var> from start to end in
increasing order.  Return unspecified values. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>string-for-each-index</b><var> proc str<a name="index-string_002dfor_002deach_002dindex-4464"></a></var><br>
&mdash; Function: <b>string-for-each-index</b><var> proc str start<a name="index-string_002dfor_002deach_002dindex-4465"></a></var><br>
&mdash; Function: <b>string-for-each-index</b><var> proc str start end<a name="index-string_002dfor_002deach_002dindex-4466"></a></var><br>
<blockquote><p>Apply <var>proc</var> to each index of the selected substring of <var>str</var>,
in increasing order from start to end.  This is simply a method of
looping over a string that is guaranteed to be safe and correct. 
Example:

     <pre class="example">          (let* ((len (string-length s))
                 (ans (make-string len)))
            (string-for-each-index
              (lambda (i)
                (string-set! ans (- len i) (string-ref s i)))
              s)
            ans)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: <b>string-fold</b><var> kons knil str<a name="index-string_002dfold-4467"></a></var><br>
&mdash; Function: <b>string-fold</b><var> kons knil str start<a name="index-string_002dfold-4468"></a></var><br>
&mdash; Function: <b>string-fold</b><var> kons knil str start end<a name="index-string_002dfold-4469"></a></var><br>
&mdash; Function: <b>string-fold-right</b><var> kons knil str<a name="index-string_002dfold_002dright-4470"></a></var><br>
&mdash; Function: <b>string-fold-right</b><var> kons knil str start<a name="index-string_002dfold_002dright-4471"></a></var><br>
&mdash; Function: <b>string-fold-right</b><var> kons knil str start end<a name="index-string_002dfold_002dright-4472"></a></var><br>
<blockquote><p>These are the fundamental iterators for strings.

        <p>The left&ndash;fold operator maps the <var>kons</var> procedure across the string
from left to right:

     <pre class="example">          (... (kons s[2] (kons s[1] (kons s[0] knil))))
</pre>
        <p class="noindent">in other words, <code>string-fold</code> obeys the (tail) recursion:

     <pre class="example">          (string-fold kons knil s start end)
          == (string-fold kons (kons s[start] knil) start+1 end)
</pre>
        <p>The right&ndash;fold operator maps the <var>kons</var> procedure across the string
from right to left:

     <pre class="example">          (kons s[0]
                (... (kons s[end-3]
                           (kons s[end-2]
                                 (kons s[end-1] knil)))))
</pre>
        <p class="noindent">obeying the (tail) recursion:

     <pre class="example">          (string-fold-right kons knil s start end)
          == (string-fold-right kons (kons s[end-1] knil) start end-1)
</pre>
        <p>Examples:

     <pre class="example">          ;;; Convert a string to a list of chars.
          (string-fold-right cons '() s)
          
          ;;; Count the number of lower-case characters in a string.
          (string-fold (lambda (c count)
                         (if (char-lower-case? c)
                             (+ count 1)
                           count))
                        0
                        s)
          
          ;;; Double every backslash character in S.
          (let* ((ans-len (string-fold (lambda (c sum)
                                         (+ sum (if (char=? c #\\)
                                                    2
                                                  1)))
                                       0 s))
                 (ans     (make-string ans-len)))
            (string-fold (lambda (c i)
                           (let ((i (if (char=? c #\\)
                                        (begin
                                          (string-set! ans i #\\)
                                          (+ i 1))
                                      i)))
                              (string-set! ans i c)
                              (+ i 1)))
                         0 s)
            ans)
</pre>
        <p>The right&ndash;fold combinator is sometimes called a &ldquo;catamorphism&rdquo;. 
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: <b>string-unfold</b><var> stop? seed-&gt;char make-seed first-seed<a name="index-string_002dunfold-4473"></a></var><br>
&mdash; Function: <b>string-unfold</b><var> stop? seed-&gt;char make-seed first-seed base-str<a name="index-string_002dunfold-4474"></a></var><br>
&mdash; Function: <b>string-unfold</b><var> stop? seed-&gt;char make-seed first-seed base-str make-final<a name="index-string_002dunfold-4475"></a></var><br>
<blockquote><p>This is a fundamental constructor for strings.

          <dl>
<dt><var>make-seed</var><dd>Is used to generate a series of &ldquo;seed&rdquo; values from the initial seed:

          <pre class="example">               <var>first-seed</var>
               (<var>make-seed</var> <var>first-seed</var>)      &rArr; seed2
               (<var>make-seed</var> seed2)           &rArr; seed3
               (<var>make-seed</var> seed3)           &rArr; seed4
               ...
</pre>
          <br><dt><var>stop?</var><dd>Tells us when to stop; when it returns true when applied to one of the
seed values.

          <br><dt><var>seed-&gt;char</var><dd>Maps each seed value to the corresponding character in the result
string.  These chars are assembled into the string in a left&ndash;to&ndash;right
order.

          <br><dt><var>base-string</var><dd>Is the optional initial/leftmost portion of the constructed string; it
defaults to the empty string.

          <br><dt><var>make-final</var><dd>Is applied to the terminal seed value (on which <var>stop?</var> returns
true) to produce the final/rightmost portion of the constructed string. 
It defaults to:

          <pre class="example">               (lambda (x) "")
</pre>
          </dl>

        <p>More precisely, the following (simple, inefficient) definitions hold:

     <pre class="example">          ;;; Iterative
          (define (string-unfold stop? seed-&gt;char make-seed
                                 first-seed base-str make-final)
            (let loop ((seed first-seed)
                       (ans  base-str))
              (if (stop? seed)
                  (string-append ans (make-final seed))
                (loop (make-seed seed)
                      (string-append ans (string (seed-&gt;char seed)))))))
          
          ;;; Recursive
          (define (string-unfold stop? seed-&gt;char make-seed
                                 first-seed base-str make-final)
            (string-append
               base-str
               (let recur ((seed first-seed))
                 (if (stop? seed)
                     (make-final seed)
                   (string-append (string (seed-&gt;char seed))
                                  (recur  (make-seed  seed)))))))
</pre>
        <p><code>string-unfold</code> is a fairly powerful string constructor; we can use
it to convert a list to a string, read a port into a string, reverse a
string, copy a string, and so forth.  Examples:

     <pre class="example">          (port-&gt;string p)
          == (string-unfold eof-object? values
                       (lambda (x) (read-char p))
                       (read-char p))
          
          (list-&gt;string lis)
          == (string-unfold null? car cdr lis)
          
          (string-tabulate f size)
          == (string-unfold
                       (lambda (i) (= i size))
                       f add1 0)
</pre>
        <p class="noindent">to map <var>seed-&gt;char</var> over a list <var>lis</var>, producing a string:

     <pre class="example">          (string-unfold null? (compose f car) cdr lis)
</pre>
        <p>Interested functional programmers may enjoy noting that
<code>string-fold-right</code> and <code>string-unfold</code> are in some sense
inverses.  That is, given operations <var>knull?</var>, <var>kar</var>, <var>kdr</var>,
<var>kons</var>, and <var>knil</var> satisfying:

     <pre class="example">          (kons (kar x) (kdr x))  == x
          (knull? knil)           == #t
</pre>
        <p class="noindent">then:

     <pre class="example">          (string-fold-right kons knil
             (string-unfold knull? kar kdr x))
          == x
</pre>
        <p class="noindent">and:

     <pre class="example">          (string-unfold knull? kar kdr
             (string-fold-right kons knil s))
          == s
</pre>
        <p>The final string constructed does not share storage with either
<var>base-str</var> or the value produced by <var>make-final</var>.

        <p>This combinator sometimes is called an &ldquo;anamorphism&rdquo;. 
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: <b>string-unfold-right</b><var> stop? seed-&gt;char make-seed first-seed<a name="index-string_002dunfold_002dright-4476"></a></var><br>
&mdash; Function: <b>string-unfold-right</b><var> stop? seed-&gt;char make-seed first-seed base-str<a name="index-string_002dunfold_002dright-4477"></a></var><br>
&mdash; Function: <b>string-unfold-right</b><var> stop? seed-&gt;char make-seed first-seed base-str make-final<a name="index-string_002dunfold_002dright-4478"></a></var><br>
<blockquote><p>This is a fundamental constructor for strings.

          <dl>
<dt><var>make-seed</var><dd>Is used to generate a series of &ldquo;seed&rdquo; values from the initial
<var>first-seed</var>:

          <pre class="example">               <var>first-seed</var>
               (<var>make-seed</var> <var>first-seed</var>)      &rArr; seed2
               (<var>make-seed</var> seed2)           &rArr; seed3
               (<var>make-seed</var> seed3)           &rArr; seed4
               ...
</pre>
          <br><dt><var>stop?</var><dd>Tells us when to stop; when it returns true when applied to one of these
seed values.

          <br><dt><var>seed-&gt;char</var><dd>Maps each seed value to the corresponding character in the result
string.  These chars are assembled into the string in a right&ndash;to&ndash;left
order.

          <br><dt><var>base-str</var><dd>Is the optional initial/rightmost portion of the constructed string; it
defaults to the empty string.

          <br><dt><var>make-final</var><dd>Is applied to the terminal seed value (on which <var>stop?</var> returns
true) to produce the final/leftmost portion of the constructed string. 
It defaults to:

          <pre class="example">               (lambda (x) "")
</pre>
          </dl>

        <p>More precisely, the following (simple, inefficient) definitions hold:

     <pre class="example">          ;;; Iterative
          (define (string-unfold-right stop? seed-&gt;char make-seed
                                       first-seed base-str make-final)
            (let loop ((seed first-seed)
                       (ans  base-str))
              (if (stop? seed)
                  (string-append (make-final seed) ans)
                (loop (make-seed seed)
                      (string-append (string (seed-&gt;char seed)) ans)))))
          
          ;;; Recursive
          (define (string-unfold-right stop? seed-&gt;char make-seed
                                       first-seed base-str make-final)
            (string-append
               (let recur ((seed first-seed))
                 (if (stop? seed)
                     (make-final seed)
                   (string-append (recur  (make-seed  seed))
                                  (string (seed-&gt;char seed)))))
               base-str))
</pre>
        <p>Interested functional programmers may enjoy noting that
<code>string-fold</code> and <code>string-unfold-right</code> are in some sense
inverses.  That is, given operations <var>knull?</var>, <var>kar</var>, <var>kdr</var>,
<var>kons</var>, and <var>knil</var> satisfying:

     <pre class="example">          (kons (kar x) (kdr x))  == x
          (knull? knil)           == #t
</pre>
        <p class="noindent">then:

     <pre class="example">          (string-fold kons knil
            (string-unfold-right knull? kar kdr x))
          == x
</pre>
        <p class="noindent">and:

     <pre class="example">          (string-unfold-right knull? kar kdr
            (string-fold kons knil s))
          == s
</pre>
        <p>The final string constructed does not share storage with either
<var>base-str</var> or the value produced by <code>make-final</code>. 
</p></blockquote></div>

<!-- page -->
   </body></html>

