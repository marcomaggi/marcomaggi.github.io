<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This document describes version 0.4d1 of Vicare Scheme, an
R6RS compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit and 64-bit
processors.  Vicare is pronounced the etruscan way.

The package, including its documentation, is distributed under the terms
of the GNU General Public License (GPL) and can be downloaded
from:

https://bitbucket.org/marcomaggi/vicare-scheme/downloads

the home page of the project is at:

http://marcomaggi.github.io/vicare.html

development takes place at:

http://github.com/marcomaggi/vicare/

and, as a backup, at:

https://bitbucket.org/marcomaggi/vicare-scheme/

Copyright (C) 2010-2017 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

Copyright (C) Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton Van Straaten.

This document is derived from the original Ikarus documentation by the
Vicare Scheme contributors, see the "History" appendix for details.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library (vicare formations) is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

This program is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License version 3 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see
http://www.gnu.org/licenses/.

Trademarks used herein are the property of their respective owners. -->
<!-- Created by GNU Texinfo 6.3, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Vicare Scheme: stdlib enum</title>

<meta name="description" content="Vicare Scheme: stdlib enum">
<meta name="keywords" content="Vicare Scheme: stdlib enum">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="concept-index.html#concept-index" rel="index" title="concept index">
<link href="stdlib.html#stdlib" rel="up" title="stdlib">
<link href="stdlib-complib.html#stdlib-complib" rel="next" title="stdlib complib">
<link href="stdlib-hashtable-hash-functions.html#stdlib-hashtable-hash-functions" rel="prev" title="stdlib hashtable hash functions">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="stdlib-enum"></a>
<div class="header">
<p>
Next: <a href="stdlib-complib.html#stdlib-complib" accesskey="n" rel="next">stdlib complib</a>, Previous: <a href="stdlib-hashtable.html#stdlib-hashtable" accesskey="p" rel="prev">stdlib hashtable</a>, Up: <a href="stdlib.html#stdlib" accesskey="u" rel="up">stdlib</a> &nbsp; [<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Enumerations"></a>
<h3 class="section">5.14 Enumerations</h3>


<a name="index-_0028rnrs-enums-_00286_0029_0029_002c-library"></a>
<a name="index-Library_002c-_0028rnrs-enums-_00286_0029_0029"></a>



<p>This chapter describes the <code>(rnrs enums (6))</code> library for dealing with
enumerated values and sets of enumerated values.  Enumerated values are
represented by ordinary symbols, while finite sets of enumerated values
form a separate type, known as the <em>enumeration sets</em>.  The
enumeration sets are further partitioned into sets that share the same
<em>universe</em> and <em>enumeration type</em>.  These universes and
enumeration types are created by the <code>make-enumeration</code> procedure.
Each call to that procedure creates a new enumeration type.
</p>
<p>This library interprets each enumeration set with respect to its
specific universe of symbols and enumeration type.  This facilitates
efficient implementation of enumeration sets and enables the complement
operation.
</p>
<p>In the descriptions of the following procedures, <var>enum-set</var> ranges
over the enumeration sets, which are defined as the subsets of the
universes that can be defined using <code>make-enumeration</code>.
</p>

<dl>
<dt><a name="index-make_002denumeration"></a>Procedure: <strong>make-enumeration</strong> <em><var>symbol-list</var></em></dt>
<dd><p><var>symbol-list</var> must be a list of symbols.
</p>
<p>The <code>make-enumeration</code> procedure creates a new enumeration type
whose universe consists of those symbols (in canonical order of their
first appearance in the list) and returns that universe as an
enumeration set whose universe is itself and whose enumeration type is
the newly created enumeration type.
</p></dd></dl>


<dl>
<dt><a name="index-enum_002dset_002duniverse"></a>Procedure: <strong>enum-set-universe</strong> <em><var>enum-set</var></em></dt>
<dd><p>Return the set of all symbols that comprise the universe of its
argument, as an enumeration set.
</p></dd></dl>


<dl>
<dt><a name="index-enum_002dset_002dindexer"></a>Procedure: <strong>enum-set-indexer</strong> <em><var>enum-set</var></em></dt>
<dd><p>Return a unary procedure that, given a symbol that is in the universe of
<var>enum-set</var>, returns its 0&ndash;origin index within the canonical
ordering of the symbols in the universe; given a symbol not in the
universe, the unary procedure returns <code>#f</code>.
</p>
<div class="example">
<pre class="example">(let* ((e (make-enumeration '(red green blue)))
       (i (enum-set-indexer e)))
  (list (i 'red) (i 'green) (i 'blue) (i 'yellow)))
&rArr; (0 1 2 #f)
</pre></div>

<p>The <code>enum-set-indexer</code> procedure could be defined as follows using
the <code>memq</code> procedure from the <code>(rnrs lists (6))</code> library:
</p>
<div class="example">
<pre class="example">(define (enum-set-indexer set)
  (let* ((symbols (enum-set-&gt;list
                    (enum-set-universe set)))
         (cardinality (length symbols)))
    (lambda (x)
      (cond
       ((memq x symbols)
        =&gt; (lambda (probe)
             (- cardinality (length probe))))
       (else #f)))))
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-enum_002dset_002dconstructor"></a>Procedure: <strong>enum-set-constructor</strong> <em><var>enum-set</var></em></dt>
<dd><p>Return a unary procedure that, given a list of symbols that belong to
the universe of <var>enum-set</var>, returns a subset of that universe that
contains exactly the symbols in the list.  The values in the list must
all belong to the universe.
</p></dd></dl>


<dl>
<dt><a name="index-enum_002dset_002d_003elist"></a>Procedure: <strong>enum-set-&gt;list</strong> <em><var>enum-set</var></em></dt>
<dd><p>Return a list of the symbols that belong to its argument, in the
canonical order of the universe of <var>enum-set</var>.
</p>
<div class="example">
<pre class="example">(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (enum-set-&gt;list (c '(blue red))))    &rArr; (red blue)
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-enum_002dset_002dmember_003f"></a>Procedure: <strong>enum-set-member?</strong> <em><var>symbol</var> <var>enum-set</var></em></dt>
<dt><a name="index-enum_002dset_002dsubset_003f"></a>Procedure: <strong>enum-set-subset?</strong> <em><var>enum-set1</var> <var>enum-set2</var></em></dt>
<dt><a name="index-enum_002dset_003d_003f"></a>Procedure: <strong>enum-set=?</strong> <em><var>enum-set1</var> <var>enum-set2</var></em></dt>
<dd><p>The <code>enum-set-member?</code> procedure returns <code>#t</code> if its first
argument is an element of its second argument, <code>#f</code> otherwise.
</p>
<p>The <code>enum-set-subset?</code> procedure returns <code>#t</code> if the universe of
<var>enum-set1</var> is a subset of the universe of <var>enum-set2</var>
(considered as sets of symbols) and every element of <var>enum-set1</var> is
a member of <var>enum-set2</var>.  It returns <code>#f</code> otherwise.
</p>
<p>The <code>enum-set=?</code> procedure returns <code>#t</code> if <var>enum-set1</var> is a
subset of <var>enum-set2</var> and vice versa, as determined by the
<code>enum-set-subset?</code> procedure.  This implies that the universes of
the two sets are equal as sets of symbols, but does not imply that they
are equal as enumeration types.  Otherwise, <code>#f</code> is returned.
</p>
<div class="example">
<pre class="example">(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (list
   (enum-set-member? 'blue (c '(red blue)))
   (enum-set-member? 'green (c '(red blue)))
   (enum-set-subset? (c '(red blue)) e)
   (enum-set-subset? (c '(red blue)) (c '(blue red)))
   (enum-set-subset? (c '(red blue)) (c '(red)))
   (enum-set=? (c '(red blue)) (c '(blue red)))))
&rArr; (#t #f #t #t #f #t)
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-enum_002dset_002dunion"></a>Procedure: <strong>enum-set-union</strong> <em><var>enum-set1</var> <var>enum-set2</var></em></dt>
<dt><a name="index-enum_002dset_002dintersection"></a>Procedure: <strong>enum-set-intersection</strong> <em><var>enum-set1</var> <var>enum-set2</var></em></dt>
<dt><a name="index-enum_002dset_002ddifference"></a>Procedure: <strong>enum-set-difference</strong> <em><var>enum-set1</var> <var>enum-set2</var></em></dt>
<dd><p><var>enum-set1</var> and <var>enum-set2</var> must be enumeration sets that have
the same enumeration type.
</p>
<p>The <code>enum-set-union</code> procedure returns the union of <var>enum-set1</var>
and <var>enum-set2</var>.  The <code>enum-set-intersection</code> procedure
returns the intersection of <var>enum-set1</var> and <var>enum-set2</var>.  The
<code>enum-set-difference</code> procedure returns the difference of
<var>enum-set1</var> and <var>enum-set2</var>.
</p>
<div class="example">
<pre class="example">(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (list (enum-set-&gt;list
         (enum-set-union (c '(blue)) (c '(red))))
        (enum-set-&gt;list
         (enum-set-intersection (c '(red green))
                                (c '(red blue))))
        (enum-set-&gt;list
         (enum-set-difference (c '(red green))
                              (c '(red blue))))))
&rArr; ((red blue) (red) (green))
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-enum_002dset_002dcomplement"></a>Procedure: <strong>enum-set-complement</strong> <em><var>enum-set</var></em></dt>
<dd><p>Return <var>enum-set</var>&rsquo;s complement with respect to its universe.
</p>
<div class="example">
<pre class="example">(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (enum-set-&gt;list
    (enum-set-complement (c '(red)))))
&rArr; (green blue)
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-enum_002dset_002dprojection"></a>Procedure: <strong>enum-set-projection</strong> <em><var>enum-set1</var> <var>enum-set2</var></em></dt>
<dd><p>Project <var>enum-set1</var> into the universe of <var>enum-set2</var>, dropping
any elements of <var>enum-set1</var> that do not belong to the universe of
<var>enum-set2</var>.  (If <var>enum-set1</var> is a subset of the universe of
<var>enum-set2</var>, no elements are dropped, and the injection is
returned.)
</p>
<div class="example">
<pre class="example">(let ((e1 (make-enumeration
            '(red green blue black)))
      (e2 (make-enumeration
            '(red black white))))
  (enum-set-&gt;list
    (enum-set-projection e1 e2))))
&rArr; (red black)
</pre></div>
</dd></dl>


<dl>
<dt><a name="index-define_002denumeration"></a>Syntax: <strong>define-enumeration</strong> <em><var>?type-name</var> (<var>?symbol</var> &hellip;) <var>?constructor-syntax</var></em></dt>
<dd><p>The <code>define-enumeration</code> form defines an enumeration type and
provides two macros for constructing its members and sets of its
members.
</p>
<p>A <code>define-enumeration</code> form is a definition and can appear anywhere
any other <var>?definition</var> can appear.
</p>
<p><var>?type-name</var> is an identifier that is bound as a syntactic keyword;
<var>?symbol</var> &hellip; are the symbols that comprise the universe of the
enumeration (in order).
</p>
<p><code>(<var>?type-name</var> <var>?symbol</var>)</code> checks at macro-expansion time
whether the name of <var>?symbol</var> is in the universe associated with
<var>?type-name</var>.  If it is, <code>(<var>?type-name</var> <var>?symbol</var>)</code>
is equivalent to <code><var>?symbol</var></code>.  It is a syntax violation if it
is not.
</p>
<p><var>?constructor-syntax</var> is an identifier that is bound to a macro
that, given any finite sequence of the symbols in the universe, possibly
with duplicates, expands into an expression that evaluates to the
enumeration set of those symbols.
</p>
<p><code>(<var>?constructor-syntax</var> <var>?symbol</var> ...)</code> checks at
macro-expansion time whether every <var>?symbol</var> ... is in the universe
associated with <var>?type-name</var>.  It is a syntax violation if one or
more is not.  Otherwise:
</p>
<div class="example">
<pre class="example">(<var>?constructor-syntax</var> <var>?symbol</var> ...)
</pre></div>

<p>is equivalent to:
</p>
<div class="example">
<pre class="example">((enum-set-constructor (<var>?constructor-syntax</var>))
 '(<var>?symbol</var> ...))
</pre></div>

<p>Example:
</p>
<div class="example">
<pre class="example">(define-enumeration color
  (black white purple maroon)
  color-set)

(color black)                      &rArr; black
(color purpel)                     &rArr; exception &amp;syntax
(enum-set-&gt;list (color-set))       &rArr; ()
(enum-set-&gt;list
  (color-set maroon white))        &rArr; (white maroon)
</pre></div>

<blockquote>
<p><strong>NOTE</strong> In the forms:
</p>
<div class="example">
<pre class="example">(<var>?type-name</var> <var>?symbol</var>)
(<var>?constructor-syntax</var> <var>?symbol</var> ...)
</pre></div>

<p>only the names of the <var>?symbol</var>s are significant.
</p></blockquote>
</dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="stdlib-complib.html#stdlib-complib" accesskey="n" rel="next">stdlib complib</a>, Previous: <a href="stdlib-hashtable.html#stdlib-hashtable" accesskey="p" rel="prev">stdlib hashtable</a>, Up: <a href="stdlib.html#stdlib" accesskey="u" rel="up">stdlib</a> &nbsp; [<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
