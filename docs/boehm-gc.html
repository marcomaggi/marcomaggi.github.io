<html lang="en">
<head>
<title>Boehm--Demers--Weiser Garbage Collection Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Boehm--Demers--Weiser Garbage Collection Library">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 7.1 of GC, the
Boehm--Demers--Weiser Garbage Collection Library; it is a Texinfo
reformatting of the documentation available from the GC website:

            `http://www.hpl.hp.com/personal/Hans_Boehm/gc/'


or included with the distribution; some adjustment has been done.  This
document is *unofficial* documentation of the library.

Copyright (C) 1988, 1989, 2008 Hans--J. Boehm, Alan J. Demers

Copyright (C) 1991--1996 by Xerox Corporation.  All rights reserved.

Copyright (C) 1996--1999 by Silicon Graphics.  All rights reserved.

Copyright (C) 1999--2005 Hewlett--Packard Development Company, L.P.

Texinfo reformatting and minor changes by Marco Maggi
<marcomaggi@gna.org>.

     THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
     EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.

     Permission is hereby granted to use or copy this document for any
     purpose, provided the above notices are retained on all copies.
     Permission to modify this document and to distribute modified
     copies of this document is granted, provided the above notices are
     retained, and a notice that the document was modified is included
     with the above copyright notice.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">Boehm--Demers--Weiser Garbage Collection Library</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#overview">overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Boehm Demers Garbage Collection Library</h2>

<p>This document describes version 7.1 of <acronym>GC</acronym>, the
Boehm&ndash;Demers&ndash;Weiser Garbage Collection Library; it is a Texinfo
reformatting of the documentation available from the <acronym>GC</acronym> website:

<div align="center"><a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">http://www.hpl.hp.com/personal/Hans_Boehm/gc/</a></div>

<p class="noindent">or included with the distribution; some adjustment has been done.  This
document is <strong>unofficial</strong> documentation of the library.

<p class="noindent">Copyright &copy; 1988, 1989, 2008 Hans&ndash;J. Boehm, Alan J. Demers<br>
Copyright &copy; 1991&ndash;1996 by Xerox Corporation.  All rights reserved.<br>
Copyright &copy; 1996&ndash;1999 by Silicon Graphics.  All rights reserved.<br>
Copyright &copy; 1999&ndash;2005 Hewlett&ndash;Packard Development Company, L.P.

   <p>Texinfo reformatting and minor changes by Marco Maggi
<a href="mailto:marcomaggi@gna.org">marcomaggi@gna.org</a>.

   <blockquote>
THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.

   <p>Permission is hereby granted to use or copy this document for any
purpose, provided the above notices are retained on all copies. 
Permission to modify this document and to distribute modified copies of
this document is granted, provided the above notices are retained, and a
notice that the document was modified is included with the above
copyright notice. 
</blockquote>

<ul class="menu">
<li><a accesskey="1" href="#overview">overview</a>:                     Overview of the library. 
<li><a accesskey="2" href="#install">install</a>:                      Installation and portability. 
<li><a accesskey="3" href="#api">api</a>:                          The C interface to the allocator. 
<li><a accesskey="4" href="#bugs">bugs</a>:                         Bugs.

</li></ul>
<p>Appendices

</p>
<ul class="menu">
<li><a accesskey="5" href="#tutorial">tutorial</a>:                     Using the garbage collector:
                                a simple example. 
<li><a accesskey="6" href="#cord">cord</a>:                         The cord string interface.

<li><a accesskey="7" href="#Package-License">Package License</a>:              Package License. 
<li><a accesskey="8" href="#Documentation-License">Documentation License</a>:        Documentation License. 
<li><a accesskey="9" href="#References">References</a>:                   Bibliography and references.

</li></ul>
<p>Indexes

</p>
<ul class="menu">
<li><a href="#Concept-Index">Concept Index</a>:                An entry for each concept. 
<li><a href="#Function-Index">Function Index</a>:               An entry for each function. 
<li><a href="#Variable-Index">Variable Index</a>:               An entry for each variable. 
<li><a href="#Type-Index">Type Index</a>:                   An entry for each type.

</li></ul>
<p>--- The Detailed Node Listing ---

<p>Overview of this document

</p>
<ul class="menu">
<li><a href="#overview-algorithm">overview algorithm</a>:           Conservative garbage collection:
                                algorithmic overview. 
<li><a href="#overview-finalisation">overview finalisation</a>:        Objects finalisation. 
<li><a href="#overview-scalability">overview scalability</a>:         Garbage collector scalability. 
<li><a href="#overview-leak">overview leak</a>:                Using the garbage collector as
                                leak detector. 
<li><a href="#overview-notes">overview notes</a>:               Notes on the garbage collector.

</li></ul>
<p>The C interface to the allocator

</p>
<ul class="menu">
<li><a href="#api-typedefs">api typedefs</a>:                 Type definitions. 
<li><a href="#api-variables">api variables</a>:                Public variables. 
<li><a href="#api-macros">api macros</a>:                   Function wrappers. 
<li><a href="#api-init">api init</a>:                     Library initialisation. 
<li><a href="#api-base">api base</a>:                     Basic interface functions. 
<li><a href="#api-debug">api debug</a>:                    Debugging facilities. 
<li><a href="#api-inspect">api inspect</a>:                  Inspecting objects. 
<li><a href="#api-stubborn">api stubborn</a>:                 Stubborn objects. 
<li><a href="#api-roots">api roots</a>:                    Root memory blocks. 
<li><a href="#api-finalisation">api finalisation</a>:             Finalisation functions. 
<li><a href="#api-operations">api operations</a>:               Miscellaneous operations. 
<li><a href="#api-threads">api threads</a>:                  Handling threads. 
<li><a href="#api-cplusplus">api cplusplus</a>:                The C++ interface to the allocator. 
<li><a href="#api-leak">api leak</a>:                     Use as leak detector. 
<li><a href="#api-collector">api collector</a>:                Incremental/generational collection. 
<li><a href="#api-version">api version</a>:                  Library version informations. 
<li><a href="#api-misc">api misc</a>:                     Miscellaneous stuff.

</li></ul>
<p>Debugging facilities

</p>
<ul class="menu">
<li><a href="#api-debug-special">api debug special</a>:            Special debugging functions. 
<li><a href="#api-debug-validation">api debug validation</a>:         Validation functions. 
<li><a href="#api-debug-pointer">api debug pointer</a>:            Pointer operation macros.

   </ul>

<!--  -->
<!-- page -->
<div class="node">
<a name="overview"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#install">install</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Overview of this document</h2>

<p><a name="index-Object_002c-a-block-of-garbage-collectable-memory-1"></a>

<ul class="menu">
<li><a accesskey="1" href="#overview-algorithm">overview algorithm</a>:           Conservative garbage collection:
                                algorithmic overview. 
<li><a accesskey="2" href="#overview-finalisation">overview finalisation</a>:        Objects finalisation. 
<li><a accesskey="3" href="#overview-scalability">overview scalability</a>:         Garbage collector scalability. 
<li><a accesskey="4" href="#overview-leak">overview leak</a>:                Using the garbage collector as
                                leak detector. 
<li><a accesskey="5" href="#overview-notes">overview notes</a>:               Notes on the garbage collector. 
</ul>

<p class="noindent">The Boehm&ndash;Demers&ndash;Weiser conservative garbage collector can be used as
a garbage collecting replacement for the standard C language
<code>malloc()</code> function or the C++ language <code>new</code> operator.  It
allows to allocate memory basically as we normally would, without
explicitly deallocating objects that are no longer useful.  The
collector automatically recycles memory when it determines that it can
no longer be otherwise accessed.  <a href="#tutorial">tutorial</a> for a quick
introduction.

   <p>The collector is also used by a number of programming language
implementations that either: use C as intermediate code; want to
facilitate easier interoperation with C libraries; or just prefer the
simple collector interface.

   <p>Alternatively, the garbage collector can be used as a leak detector for
C or C++ programs, though that is not its primary goal.

   <p>This document describes version 7.1 of <acronym>GC</acronym> and it is a Texinfo
reformatting of the documentation available from the <acronym>GC</acronym> website:

<div align="center"><a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">http://www.hpl.hp.com/personal/Hans_Boehm/gc/</a></div>

<p class="noindent">or included with the distribution; some adjustment has been done.  This
document is <strong>unofficial</strong> documentation of the library.

   <p>In this document: an &ldquo;object&rdquo; is defined to be a region of memory
allocated by the <acronym>GC</acronym> routines, and so subject to garbage collection. 
Memory blocks allocated by the standard <code>malloc()</code> or other functions are
called &ldquo;blocks&rdquo;.

   <p>When this document states that a function &ldquo;fails conspicuously&rdquo; in
case of error, it means that the program will be aborted.  This happens
with functions that have to be used somewhat like the standard C
<code>assert()</code> facility.

<!--  -->
<!-- page -->
<div class="node">
<a name="overview-algorithm"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#overview-finalisation">overview finalisation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#overview">overview</a>

</div>

<h3 class="section">1.1 Conservative garbage collection: algorithmic overview</h3>

<div align="center"><strong>This is for <acronym>GC</acronym> version 7.1</strong></div>

<p class="noindent">This is a description of the algorithms and data structures used in
<acronym>GC</acronym>'s conservative garbage collector.  This description is targeted
primarily at someone trying to understand the source code.  It
specifically refers to variable and function names.  It may also be
useful for understanding the algorithms at a higher level.

   <p>The description here assumes that the collector is used in default mode. 
In particular, we assume that it is used as a garbage collector, and not
just a leak detector.  We initially assume that it is used in
stop&ndash;the&ndash;world, non&ndash;incremental mode, though the presence of the
incremental collector will be apparent in the design.  We assume the
default finalisation model, but the code affected by that is very
localised.

<!--  -->
<h4 class="subsection">1.1.1 Introduction</h4>

<p class="noindent">The garbage collector uses a modified mark&ndash;sweep algorithm. 
Conceptually it operates roughly in four phases, which are performed
occasionally as part of a memory allocation.

     <dl>
<dt><em>Preparation</em><dd>Each object has an associated mark bit.  Clear all mark bits, indicating
that all objects are potentially unreachable.

     <br><dt><em>Mark phase</em><dd>Marks all objects that can be reachable via chains of pointers from
variables.  Often the collector has no real information about the
location of pointer variables in the heap, so it views all static data
areas, stacks and registers as potentially containing pointers.

     <p>Any bit patterns that represent addresses inside heap objects managed by
the collector are viewed as pointers.  Unless the client program has
made heap object layout information available to the collector, any heap
objects found to be reachable from variables are again scanned
similarly.

     <br><dt><em>Sweep phase</em><dd>Scans the heap for inaccessible, and hence unmarked, objects, and
returns them to an appropriate free list for reuse.  This is not really
a separate phase; even in non&ndash;incremental mode this operation is
usually performed on demand during an allocation that discovers an empty
free list.  Thus the sweep phase is very unlikely to touch a page that
would not have been touched shortly thereafter anyway.

     <br><dt><em>Finalisation phase</em><dd>Unreachable objects which had been registered for finalisation are
enqueued for finalisation outside the collector. 
</dl>

   <p>The remaining sections describe the memory allocation data structures,
and then the last 3 collection phases in more detail.  We conclude by
outlining some of the additional features implemented in the collector.

<!--  -->
<h4 class="subsection">1.1.2 Allocation</h4>

<p class="noindent">The collector includes its own memory allocator.  The allocator obtains
memory from the system in a platform&ndash;dependent way.  Under Unix, it
uses either <code>malloc()</code>, <code>sbrk()</code>, or <code>mmap()</code>.

   <p>Most static data used by the allocator, as well as that needed by the
rest of the garbage collector is stored inside the <code>_GC_arrays</code>
structure.  This allows the garbage collector to easily ignore the
collectors own data structures when it searches for root pointers. 
Other allocator and collector internal data structures are allocated
dynamically with <code>GC_scratch_alloc()</code>. 
<code>GC_scratch_alloc()</code> does not allow for deallocation, and is
therefore used only for permanent data structures.

   <p>The allocator allocates objects of different kinds.  Different kinds are
handled somewhat differently by certain parts of the garbage collector. 
Certain kinds are scanned for pointers, others are not.  Some may have
per&ndash;object type descriptors that determine pointer locations.  Or a
specific kind may correspond to one specific object layout.  Two
built&ndash;in kinds are uncollectable.  One (<code>STUBBORN</code>) is immutable
without special precautions.  In spite of that, it is very likely that
most C clients of the collector currently use at most two kinds:
<code>NORMAL</code> and <code>PTRFREE</code> objects.  The <samp><span class="command">gcj</span></samp> run time
(the <acronym>GNU</acronym> compiler for Java) also makes heavy use of a kind (allocated
with <code>GC_gcj_malloc()</code>) that stores type information at a known
offset in method tables.

   <p>The collector uses a two level allocator.  A large block is defined to
be one larger than half of <code>HBLKSIZE</code>, which is a power of 2,
typically on the order of the page size.

   <p>Large block sizes are rounded up to the next multiple of <code>HBLKSIZE</code>
and then allocated by <code>GC_allochblk()</code>.  Recent versions of the
collector use an approximate best fit algorithm by keeping free lists
for several large block sizes.  The actual implementation of
<code>GC_allochblk()</code> is significantly complicated by black&ndash;listing
issues.

   <p>Small blocks are allocated in chunks of size <code>HBLKSIZE</code>.  Each
chunk is dedicated to only one object size and kind.  The allocator
maintains separate free lists for each size and kind of object.

   <p>Once a large block is split for use in smaller objects, it can only be
used for objects of that size, unless the collector discovers a
completely empty chunk.  Completely empty chunks are restored to the
appropriate large block free list.

   <p>In order to avoid allocating blocks for too many distinct object sizes,
the collector normally does not directly allocate objects of every
possible requested size.  Instead requests are rounded up to one of a
smaller number of allocated sizes, for which free lists are maintained. 
The exact allocated sizes are computed on demand, but subject to the
constraint that they increase roughly in geometric progression.  Thus
objects requested early in the execution are likely to be allocated with
exactly the requested size, subject to alignment constraints.  See
<code>GC_init_size_map()</code> for details.

   <p>The actual size rounding operation during small object allocation is
implemented as a table look&ndash;up in <code>GC_size_map()</code>.

   <p>Both collector initialisation and computation of allocated sizes are
handled carefully so that they do not slow down the small object fast
allocation path.  An attempt to allocate before the collector is
uninitialised, or before the appropriate <code>GC_size_map</code> entry is
computed, will take the same path as an allocation attempt with an empty
free list.  This results in a call to the slow path code
(<code>GC_generic_malloc_inner()</code>) which performs the appropriate
initialisation checks.

   <p>In non&ndash;incremental mode, we make a decision about whether to garbage
collect whenever an allocation would otherwise have failed with the
current heap size.  If the total amount of allocation since the last
collection is less than the heap size divided by
<code>GC_free_space_divisor</code>, we try to expand the heap.  Otherwise, we
initiate a garbage collection.  This ensures that the amount of garbage
collection work per allocated byte remains constant.

   <p>The above is in fact an oversimplification of the real heap expansion
and <acronym>GC</acronym> triggering heuristic, which adjusts slightly for root size and
certain kinds of fragmentation.  In particular:

     <ul>
<li>Programs with a large root set size and little live heap memory will
expand the heap to amortise the cost of scanning the roots.

     <li>Versions 5.x of the collector actually collects more frequently in
non&ndash;incremental mode.  The large block allocator usually refuses to
split large heap blocks once the garbage collection threshold is
reached.  This often has the effect of collecting well before the heap
fills up, thus reducing fragmentation and working set size at the
expense of collection time.

     <li>Versions 6.x choose an intermediate strategy depending on how much large
object allocation has taken place in the past.  (If the collector is
configured to unmap unused pages, versions 6.x use the 5.x strategy.)

     <li>In calculating the amount of allocation since the last collection we
give partial credit for objects we expect to be explicitly deallocated. 
Even if all objects are explicitly managed, it is often desirable to
collect on rare occasion, since that is our only mechanism for
coalescing completely empty chunks. 
</ul>

   <p>It has been suggested that this should be adjusted so that we favour
expansion if the resulting heap still fits into physical memory.  In
many cases, that would no doubt help.  But it is tricky to do this in a
way that remains robust if multiple application are contending for a
single pool of physical memory.

<!--  -->
<h4 class="subsection">1.1.3 Mark phase</h4>

<p class="noindent">At each collection, the collector marks all objects that are possibly
reachable from pointer variables.  Since it cannot generally tell where
pointer variables are located, it scans the following root segments for
pointers:

     <dl>
<dt><em>The registers</em><dd>Depending on the architecture, this may be done using assembly code, or
by calling a <code>setjmp()</code> like function which saves register
contents on the stack.

     <br><dt><em>The stack(s)</em><dd>In the case of a single threaded application, on most platforms this is
done by scanning the memory between (an approximation of) the current
stack pointer and <code>GC_stackbottom</code> (for Itanium, the register stack
is scanned separately).

     <p>The <code>GC_stackbottom</code> variable is set in a highly platform&ndash;specific
way depending on the appropriate configuration information in
<samp><span class="file">gcconfig.h</span></samp>.  Note that the currently active stack needs to be
scanned carefully, since callee&ndash;saved registers of client code may
appear inside collector stack frames, which may change during the mark
process.  This is addressed by scanning some sections of the stack
&ldquo;eagerly&rdquo;, effectively capturing a snapshot at one point in time.

     <br><dt><em>Static data region(s)</em><dd>In the simplest case, this is the region between <code>DATASTART</code> and
<code>DATAEND</code>, as defined in <samp><span class="file">gcconfig.h</span></samp>.  However, in most
cases, this will also involve static data regions associated with
dynamic libraries.  These are identified by the mostly
platform&ndash;specific code in <samp><span class="file">dyn_load.c</span></samp>. 
</dl>

   <p>The marker maintains an explicit stack of memory regions that are known
to be accessible, but that have not yet been searched for contained
pointers.  Each stack entry contains the starting address of the block
to be scanned, as well as a descriptor of the block.  If no layout
information is available for the block, then the descriptor is simply a
length.  (For other possibilities, see <samp><span class="file">gc_mark.h</span></samp>.)

   <p>At the beginning of the mark phase, all root segments (as described
above) are pushed on the stack by <code>GC_push_roots()</code>.  (Registers
and eagerly processed stack sections are processed by pushing the
referenced objects instead of the stack section itself.) If
<code>ALL_INTERIOR_POINTERS</code> is not defined, then stack roots require
special treatment.  In this case, the normal marking code ignores
interior pointers, but <code>GC_push_all_stack()</code> explicitly checks
for interior pointers and pushes descriptors for target objects.

   <p>The marker is structured to allow incremental marking.  Each call to
<code>GC_mark_some()</code> performs a small amount of work towards marking
the heap.  It maintains explicit state in the form of
<code>GC_mark_state()</code>, which identifies a particular sub&ndash;phase.  Some
other pieces of state, most notably the mark stack, identify how much
work remains to be done in each sub&ndash;phase.  The normal progression of
mark states for a stop&ndash;the&ndash;world collection is:

     <ol type=1 start=1>
<li><code>MS_INVALID</code> indicating that there may be accessible unmarked
objects.  In this case <code>GC_objects_are_marked</code> will simultaneously
be false, so the mark state is advanced to

     <li><code>MS_PUSH_UNCOLLECTABLE</code> indicating that it suffices to push
uncollectable objects, roots, and then mark everything reachable from
them.  <code>scan_ptr</code> is advanced through the heap until all
uncollectable objects are pushed, and objects reachable from them are
marked.  At that point, the next call to <code>GC_mark_some()</code> calls
<code>GC_push_roots()</code> to push the roots.  It the advances the mark
state to

     <li><code>MS_ROOTS_PUSHED</code> asserting that once the mark stack is empty, all
reachable objects are marked.  Once in this state, we work only on
emptying the mark stack.  Once this is completed, the state changes to

     <li><code>MS_NONE</code> indicating that reachable objects are marked.
        </ol>

   <p>The core mark routine <code>GC_mark_from()</code>, is called repeatedly by
several of the sub&ndash;phases when the mark stack starts to fill up.  It is
also called repeatedly in <code>MS_ROOTS_PUSHED</code> state to empty the mark
stack.  The routine is designed to only perform a limited amount of
marking at each call, so that it can also be used by the incremental
collector.  It is fairly carefully tuned, since it usually consumes a
large majority of the garbage collection time.

   <p>The fact that it perform a only a small amount of work per call also
allows it to be used as the core routine of the parallel marker.  In
that case it is normally invoked on thread&ndash;private mark stacks instead
of the global mark stack.

   <p>The marker correctly handles mark stack overflows.  Whenever the mark
stack overflows, the mark state is reset to <code>MS_INVALID</code>.  Since
there are already marked objects in the heap, this eventually forces a
complete scan of the heap, searching for pointers, during which any
unmarked objects referenced by marked objects are again pushed on the
mark stack.  This process is repeated until the mark phase completes
without a stack overflow.  Each time the stack overflows, an attempt is
made to grow the mark stack.  All pieces of the collector that push
regions onto the mark stack have to be careful to ensure forward
progress, even in case of repeated mark stack overflows.  Every mark
attempt results in additional marked objects.

   <p>Each mark stack entry is processed by examining all candidate pointers
in the range described by the entry.  If the region has no associated
type information, then this typically requires that each 4-byte aligned
quantity (8-byte aligned with 64-bit pointers) be considered a candidate
pointer.

   <p>We determine whether a candidate pointer is actually the address of a
heap block.  This is done in the following steps:

     <ul>
<li>The candidate pointer is checked against rough heap bounds.  These heap
bounds are maintained such that all actual heap objects fall between
them.  In order to facilitate black&ndash;listing (see below) we also include
address regions that the heap is likely to expand into.  Most
non&ndash;pointers fail this initial test.

     <li>The candidate pointer is divided into two pieces; the most significant
bits identify a <code>HBLKSIZE</code>&ndash;sized page in the address space, and
the least significant bits specify an offset within that page.  (A
hardware page may actually consist of multiple such pages. 
<code>HBLKSIZE</code> is usually the page size divided by a small power of
two.)

     <li>The page address part of the candidate pointer is looked up in a table. 
Each table entry contains either 0, indicating that the page is not part
of the garbage collected heap, a small integer <em>n</em>, indicating that
the page is part of large object, starting at least <em>n</em> pages back,
or a pointer to a descriptor for the page.  In the first case, the
candidate pointer is not a true pointer and can be safely ignored.  In
the last two cases, we can obtain a descriptor for the page containing
the beginning of the object.

     <li>The starting address of the referenced object is computed.  The page
descriptor contains the size of the object(s) in that page, the object
kind, and the necessary mark bits for those objects.  The size
information can be used to map the candidate pointer to the object
starting address.  To accelerate this process, the page header also
contains a pointer to a precomputed map of page offsets to displacements
from the beginning of an object.  The use of this map avoids a
potentially slow integer remainder operation in computing the object
start address.

     <li>The mark bit for the target object is checked and set.  If the object
was previously unmarked, the object is pushed on the mark stack.  The
descriptor is read from the page descriptor.  (This is computed from
information <code>GC_obj_kinds</code> when the page is first allocated.) 
</ul>

   <p>At the end of the mark phase, mark bits for left&ndash;over free lists are
cleared, in case a free list was accidentally marked due to a stray
pointer.

<!--  -->
<h4 class="subsection">1.1.4 Sweep phase</h4>

<p class="noindent">At the end of the mark phase, all blocks in the heap are examined. 
Unmarked large objects are immediately returned to the large object free
list.  Each small object page is checked to see if all mark bits are
clear.  If so, the entire page is returned to the large object free
list.  Small object pages containing some reachable object are queued
for later sweeping, unless we determine that the page contains very
little free space, in which case it is not examined further.

   <p>This initial sweep pass touches only block headers, not the blocks
themselves.  Thus it does not require significant paging, even if large
sections of the heap are not in physical memory.

   <p>Non&ndash;empty small object pages are swept when an allocation attempt
encounters an empty free list for that object size and kind.  Pages for
the correct size and kind are repeatedly swept until at least one empty
block is found.  Sweeping such a page involves scanning the mark bit
array in the page header, and building a free list linked through the
first words in the objects themselves.  This does involve touching the
appropriate data page, but in most cases it will be touched only just
before it is used for allocation.  Hence any paging is essentially
unavoidable.

   <p>Except in the case of pointer&ndash;free objects, we maintain the invariant
that any object in a small object free list is cleared (except possibly
for the link field).  Thus it becomes the burden of the small object
sweep routine to clear objects.  This has the advantage that we can
easily recover from accidentally marking a free list, though that could
also be handled by other means.  The collector currently spends a fair
amount of time clearing objects, and this approach should probably be
revisited.

   <p>In most configurations, we use specialised sweep routines to handle
common small object sizes.  Since we allocate one mark bit per word, it
becomes easier to examine the relevant mark bits if the object size
divides the word length evenly.  We also suitably unroll the inner sweep
loop in each case.  (It is conceivable that profile&ndash;based procedure
cloning in the compiler could make this unnecessary and
counterproductive.  I know of no existing compiler to which this
applies.)

   <p>The sweeping of small object pages could be avoided completely at the
expense of examining mark bits directly in the allocator.  This would
probably be more expensive, since each allocation call would have to
reload a large amount of state (e.g. next object address to be swept,
position in mark bit table) before it could do its work.  The current
scheme keeps the allocator simple and allows useful optimisations in the
sweeper.

<!--  -->
<h4 class="subsection">1.1.5 Finalisation</h4>

<p class="noindent">Both <code>GC_register_disappearing_link()</code> and
<code>GC_register_finalizer()</code> add the request to a corresponding
hash table.  The hash table is allocated out of collected memory, but
the reference to the finalisable object is hidden from the collector. 
Currently finalisation requests are processed non&ndash;incrementally at the
end of a mark cycle.

   <p>The collector makes an initial pass over the table of finalisable
objects, pushing the contents of unmarked objects onto the mark
stack.  After pushing each object, the marker is invoked to mark all
objects reachable from it.  The object itself is not explicitly
marked.  This assures that objects on which a finalizer depends are
neither collected nor finalised.

   <p>If in the process of marking from an object the object itself becomes
marked, we have uncovered a cycle involving the object.  This usually
results in a warning from the collector.  Such objects are not
finalised, since it may be unsafe to do so.  <a href="#overview-finalisation">overview finalisation</a>
for a detailed discussion of finalisation semantics.

   <p>Any object remaining unmarked at the end of this process are added to a
queue of objects whose finalise functions can be run.  Depending on collector
configuration, finalise functions are dequeued and run either implicitly during
allocation calls, or explicitly in response to a user request.  (Note
that the former is unfortunately both the default and not generally
safe.  If finalise functions perform synchronisation, it may result in
deadlocks.  Nontrivial finalise functions generally need to perform
synchronisation, and thus require a different collector configuration.)

   <p>The collector provides a mechanism for replacing the procedure that is
used to mark through objects.  This is used both to provide support for
Java&ndash;style unordered finalisation, and to ignore certain kinds of
cycles, e.g. those arising from C++ implementations of virtual
inheritance.

<!--  -->
<h4 class="subsection">1.1.6 Generational Collection and Dirty Bits</h4>

<p class="noindent">We basically use the concurrent and generational garbage collection
algorithm described in &ldquo;Mostly Parallel Garbage Collection&rdquo;, by Boehm,
Demers, and Shenker.

   <p>The most significant modification is that the collector always starts
running in the allocating thread.  There is no separate garbage
collector thread.  (If parallel collection is enabled, helper threads
may also be woken up.)  If an allocation attempt either requests a large
object, or encounters an empty small object free list, and notices that
there is a collection in progress, it immediately performs a small
amount of marking work as described above.

   <p>This change was made both because we wanted to easily accommodate single
threaded environments, and because a separate collection thread requires
very careful control over the scheduler to prevent the mutator from
out&ndash;running the collector, and hence provoking unneeded heap growth.

   <p>In incremental mode, the heap is always expanded when we encounter
insufficient space for an allocation.  Garbage collection is triggered
whenever we notice that more than

<pre class="example">     GC_heap_size / 2 * GC_free_space_divisor
</pre>
   <p class="noindent">bytes of allocation have taken place.  After <code>GC_full_freq</code> minor
collections a major collection is started.

   <p>All collections initially run interrupted until a predetermined amount
of time (50 milliseconds by default) has expired.  If this allows the
collection to complete entirely, we can avoid correcting for data
structure modifications during the collection.  If it does not complete,
we return control to the mutator, and perform small amounts of
additional collection work during those later allocations that cannot be
satisfied from small object free lists.  When marking completes, the set
of modified pages is retrieved, and we mark once again from marked
objects on those pages, this time with the mutator stopped.

   <p>We keep track of modified pages using one of several distinct
mechanisms:

     <ol type=1 start=1>
<li>Through explicit mutator cooperation.  Currently this requires the use
of <code>GC_malloc_stubborn()</code>, and is rarely used.

     <li>(<code>MPROTECT_VDB</code>) By write&ndash;protecting physical pages and catching
write faults.  This is implemented for many Unix&ndash;like systems and for
Win32.  It is not possible in a few environments.

     <li>(<code>PROC_VDB</code>) By retrieving dirty bit information from <samp><span class="file">/proc</span></samp>. 
(Currently only Sun's Solaris supports this.  Though this is
considerably cleaner, performance may actually be better with mprotect
and signals.)

     <li>(<code>PCR_VDB</code>) By relying on an external dirty bit implementation, in
this case the one in Xerox PCR.

     <li>(<code>DEFAULT_VDB</code>) By treating all pages as dirty.  This is the
default if none of the other techniques is known to be usable, and
<code>GC_malloc_stubborn()</code> is not used.  Practical only for testing,
or if the vast majority of objects use <code>GC_malloc_stubborn()</code>.
        </ol>

<!--  -->
<h4 class="subsection">1.1.7 Black&ndash;listing</h4>

<p class="noindent">The collector implements black&ndash;listing of pages, as described in Boehm,
&ldquo;Space Efficient Conservative Collection&rdquo;, PLDI '93.

   <p>During the mark phase, the collector tracks &ldquo;near misses&rdquo;,
i.e. attempts to follow a &ldquo;pointer&rdquo; to just outside the
garbage&ndash;collected heap, or to a currently unallocated page inside the
heap.  Pages that have been the targets of such near misses are likely
to be the targets of misidentified &ldquo;pointers&rdquo; in the future.  To
minimise the future damage caused by such misidentifications they will
be allocated only to small pointer&ndash;free objects.

   <p>The collector understands two different kinds of black&ndash;listing.  A page
may be black listed for interior pointer references
(<code>GC_add_to_black_list_stack()</code>), if it was the target of a near
miss from a location that requires interior pointer recognition,
e.g. the stack, or the heap if <code>GC_all_interior_pointers</code> is set. 
In this case, we also avoid allocating large blocks that include this
page.

   <p>If the near miss came from a source that did not require interior
pointer recognition, it is black&ndash;listed with
<code>GC_add_to_black_list_normal()</code>.  A page black&ndash;listed in this
way may appear inside a large object, so long as it is not the first
page of a large object.

   <p>The <code>GC_allochblk()</code> routine respects black&ndash;listing when
assigning a block to a particular object kind and size.  It occasionally
drops (i.e. allocates and forgets) blocks that are completely
black&ndash;listed in order to avoid excessively long large block free lists
containing only unusable blocks.  This would otherwise become an issue
if there is low demand for small pointer&ndash;free objects.

<!--  -->
<h4 class="subsection">1.1.8 Thread support</h4>

<p class="noindent">We support several different threading models.  Unfortunately Pthreads,
the only reasonably well standardised thread model, supports too narrow
an interface for conservative garbage collection.  There appears to be
no completely portable way to allow the collector to coexist with
various Pthreads implementations.  Hence we currently support only the
more common Pthreads implementations.

   <p>In particular, it is very difficult for the collector to stop all other
threads in the system and examine the register contents.  This is
currently accomplished with very different mechanisms for some Pthreads
implementations.  The Solaris implementation temporarily disables much
of the user&ndash;level threads implementation by stopping kernel&ndash;level
threads (<code>lwp</code>s).  The Linux/HPUX/OSF1 and Irix implementations
send signals to individual Pthreads and have them wait in the signal
handler.

   <p>The Linux and Irix implementations use only documented Pthreads calls,
but rely on extensions to their semantics.  The Linux implementation
<samp><span class="file">linux_threads.c</span></samp> relies on only very mild extensions to the
Pthreads semantics, and already supports a large number of other
Unix&ndash;like Pthreads implementations.  Our goal is to make this the only
Pthreads support in the collector.

   <p>(The Irix implementation is separate only for historical reasons and
should clearly be merged.  The current Solaris implementation probably
performs better in the uniprocessor case, but does not support thread
operations in the collector.  Hence it cannot support the parallel
marker.)

   <p>All implementations must intercept thread creation and a few other
thread&ndash;specific calls to allow enumeration of threads and location of
thread stacks.  This is current accomplished with defines in <samp><span class="file">gc.h</span></samp>
(really <samp><span class="file">gc_pthread_redirects.h</span></samp>), or optionally by using <code>ld</code>'s
function call wrapping mechanism under Linux.

   <p>Recent versions of the collector support several facilities to enhance
the processor&ndash;scalability and thread performance of the collector.  We
briefly outline the data approach to thread&ndash;local allocation in the
next section.

<!--  -->
<h4 class="subsection">1.1.9 Thread&ndash;local allocation</h4>

<p class="noindent">If thread&ndash;local allocation is enabled, the collector keeps separate
arrays of free lists for each thread.  Thread&ndash;local allocation is
currently only supported on a few platforms.

   <p>The free list arrays associated with each thread are only used to
satisfy requests for objects that are both very small, and belong to one
of a small number of well known kinds.  These currently include
&ldquo;normal&rdquo; and pointer&ndash;free objects.  Depending on the configuration,
<code>gcj</code> objects may also be included.

   <p>Thread&ndash;local free list entries contain either a pointer to the first
element of a free list, or they contain a counter of the number of
allocation &ldquo;granules&rdquo; allocated so far.  Initially they contain the
value one, i.e. a small counter value.

   <p>Thread&ndash;local allocation allocates directly through the global
allocator, if the object is of a size or kind not covered by the local
free lists.

   <p>If there is an appropriate local free list, the allocator checks whether
it contains a sufficiently small counter value.  If so, the counter is
simply incremented by the counter value, and the global allocator is
used.  In this way, the initial few allocations of a given size bypass
the local allocator.  A thread that only allocates a handful of objects
of a given size will not build up its own free list for that size.  This
avoids wasting space for unpopular objects sizes or kinds.

   <p>Once the counter passes a threshold, <code>GC_malloc_many()</code> is
called to allocate roughly <code>HBLKSIZE</code> space and put it on the
corresponding local free list.  Further allocations of that size and
kind then use this free list, and no longer need to acquire the
allocation lock.  The allocation procedure is otherwise similar to the
global free lists.  The local free lists are also linked using the first
word in the object.  In most cases this means they require considerably
less time.

   <p>Local free lists are treated buy most of the rest of the collector as
though they were in&ndash;use reachable data.  This requires some care, since
pointer&ndash;free objects are not normally traced, and hence a special
tracing procedure is required to mark all objects on pointer&ndash;free and
<code>gcj</code> local free lists.

   <p>On thread exit, any remaining thread&ndash;local free list entries are
transferred back to the global free list.

   <p>Note that if the collector is configured for thread&ndash;local allocation,
<acronym>GC</acronym> versions before 7.0 do not invoke the thread&ndash;local allocator by
default: <code>GC_malloc()</code> only uses thread&ndash;local allocation in
version 7 and later.  In <acronym>GC</acronym> vesions earlier that 7.0,
<code>GC_MALLOC()</code> (all caps) may be directed to use thread&ndash;local
allocation by using the following instead of including <samp><span class="file">gc.h</span></samp>:

<pre class="example">     #define GC_REDIRECT_TO_LOCAL
     #include "gc_local_alloc.h"
</pre>
   <p class="noindent">for versions after 7.0, this happens implicitly if the collector is
built with thread&ndash;local allocation enabled.

<!--  -->
<!-- page -->
<div class="node">
<a name="overview-finalisation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#overview-scalability">overview scalability</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#overview-algorithm">overview algorithm</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#overview">overview</a>

</div>

<h3 class="section">1.2 Objects finalisation</h3>

<p class="noindent">Many garbage collectors provide a facility for executing user code just
before an object is collected.  It can be used to reclaim any system
resources or non&ndash;garbage&ndash;collected memory associated with the object. 
Experience has shown that this can be a useful facility.  It is
indispensable in cases in which system resources are embedded in complex
data structures (e.g. file descriptors in the Cord package).

   <p><acronym>GC</acronym> provides the necessary functionality through the function
<code>GC_register_finalizer()</code>, declared in <samp><span class="file">gc.h</span></samp>, or by
inheriting from <code>gc_cleanup</code> in <samp><span class="file">gc_cpp.h</span></samp>.

   <p>However, finalisation should not be used in the same way as C++
destructors.  In well written programs there will typically be very few
uses of finalisation; garbage collected programs that interact with
explicitly memory managed libraries may be an exception.

   <p>In general the following guidelines should be followed:

     <ul>
<li>actions that must be executed promptly do not belong in finalisers; they
should be handled by explicit calls in the code (or C++ destructors); if
we expect the action to occur at a specific point, this is probably not
hard;

     <li>finalisers are intended for resource reclamation;

     <li>scarce system resources should be managed explicitly whenever
convenient; we should use finalisers only as a backup mechanism for the
cases that would be hard to handle explicitly;

     <li>if scarce resources are managed with finalisation, the allocation
routine for that resource (e.g. <code>open()</code> for file handles)
should force a garbage collection (two if that doesn't suffice) if it
finds itself short of the resource;

     <li>if extremely scarce resources are managed by finalisation (e.g. file
descriptors on systems which have a limit of 20 open files), it may be
necessary to introduce a descriptor caching scheme to hide the resource
limit;

     <p>e.g., the program would keep real file descriptors for the 20 most
recently used logically open files; any other needed files would be
closed after saving their state; they would then be reopened on demand;
finalisation would logically close the file, closing the real descriptor
only if it happened to be cached;

     <p>note that most modern systems (e.g. Irix) allow hundreds or thousands of
open files, and this is typically not an issue;

     <li>finalisation code may be run whenever an allocation or other call to
<acronym>GC</acronym> takes place; in multithreaded programs, finalisers have to obey
the normal locking conventions to ensure safety; code run directly from
finalisers should not acquire locks that may be held during allocation;
this restriction can be easily circumvented by registering a finaliser
which enqueues the real action for execution in a separate thread. 
</ul>

   <p>In single threaded code, it is also often easiest to have finalisers
queue actions, which are then explicitly run during an explicit call by
the user's program.

<!--  -->
<h4 class="subsection">1.2.1 Topologically ordered finalisation</h4>

<p class="noindent"><acronym>GC</acronym> implements a form of finalisation in which objects are finalised
in topological order: if <code>A</code> points to <code>B</code>, and both are
registered for finalisation, it is guaranteed that <code>A</code> will be
finalised first.  This usually guarantees that finalisation procedures
only see unfinalised objects.

   <p>This decision is often questioned, particularly since it has an obvious
disadvantage: it finalises long chains of finalisable objects one per
collection.  This is hard to avoid, since the first finaliser invoked
may store a pointer to the rest of the chain in a global variable,
making it accessible again, or it may mutate the rest of the chain.

   <p>Cycles involving one or more finalisable objects are never finalised.

<!--  -->
<h4 class="subsection">1.2.2 Why topological ordering?</h4>

<p class="noindent">It is important to keep in mind that the choice of finalisation ordering
matters only in relatively rare cases.  In spite of the fact that it has
received a lot of discussion, it is not one of the more important
decisions in designing a system.  Many, especially smaller, applications
will never notice the difference.  Nonetheless, <acronym>GC</acronym>'s authors believe
that topologically ordered finalisation is the right choice.

   <p>To understand the justification, observe that if <code>A</code> points to
<code>B</code> and the finalisation procedure of <code>A</code> does not refer to
<code>B</code>, we could fairly easily have avoided the dependency.  We could
have split <code>A</code> into <code>A1</code> and <code>A2</code> such that any
references to <code>A</code> become references to <code>A1</code>, <code>A1</code> points
to <code>A2</code> but not vice&ndash;versa, only fields needed for finalisation
are stored in <code>A2</code>, and <code>A2</code> is enabled for finalisation
(<code>GC_register_disappearing_link()</code> provides an alternative
mechanism that does not require breaking up objects).

   <p>Thus assume that <code>A</code> actually does need access to <code>B</code> during
finalisation.  To make things concrete, assume that <code>B</code> has a
finalisation function because it holds a pointer to a <code>C</code> object,
which must be explicitly deallocated (this is likely to be one of the
most common uses of finalisation):

<pre class="example">     | allocated with GC_malloc() | allocated with malloc() |
     
     
      A |======|   B |=======|         C |======|
           |          ^  |                ^
           |          |  |                |
            ----------    ----------------
     
     void
     A_final (void * object, void * client_data)
     {
       A_data_t * A = object;
     
       do_somethig_with(A-&gt;B);
     }
     
     void
     B_final (void * object, void * client_data)
     {
       B_data_t * B = object;
     
       free(B-&gt;C);
     }
</pre>
   <p>If <code>B</code> happens to be finalised first (that is: <code>B_final()</code>
is applied to <code>B</code> before <code>A_final()</code> is applied to
<code>A</code>), <code>A</code> will see a dangling pointer during its finalisation. 
But a main goal of garbage collection is to avoid dangling pointers!

   <p>Note that the client program could enforce topological ordering even if
the system didn't.  A pointer to <code>B</code> could be stored in some
globally visible place, where it is cleared only by the finaliser of
<code>A</code>.  But this puts the burden to ensure safety back on the
programmer.

   <p>With topologically ordered finalisation, the programmer can fail to
split an object, thus leaving an accidental cycle.  This results in a
leak, which is arguably less dangerous than a dangling pointer.  More
importantly, it is much easier to diagnose, since the garbage collector
would have to go out of its way not to notice finalisation cycles.  It
can trivially report them.

   <p>Furthermore unordered finalisation does not really solve the problem of
cycles.  Consider an object <code>A</code> whose finalisation procedure
depends on <code>B</code>, and thus a pointer to <code>B</code> is stored in a
global data structure, to be cleared by the finaliser of <code>A</code>:

<pre class="example">         .............
        .             .accidental reference
        v             .
     A |======|  B |========|  global_table |============|
                    ^                           |
                    |                           |wanted reference
                     ---------------------------
     
     void
     A_final (void * object, void * client_data)
     {
       do_something_with(object, global_table-&gt;B);
       global_table-&gt;B = NULL;
     }
</pre>
   <p class="noindent">if there is an accidental pointer from <code>B</code> back to <code>A</code>, and
thus a cycle, neither <code>B</code> nor <code>A</code> will become unreachable. 
The leak is there, just as in the topologically ordered case, but it is
hidden from easy diagnosis.

   <p>A number of alternative finalisation orderings have been proposed,
e.g. based on statically assigned priorities.  In the opinion of <acronym>GC</acronym>
authors, these are much more likely to require complex programming
discipline to use in a large modular system.  (Some of them,
e.g. Guardians proposed by Dybvig, Bruggeman, and Eby, do avoid some
problems which arise in combination with certain other collection
algorithms.)

   <p>Fundamentally, a garbage collector assumes that objects reachable via
pointer chains may be accessed, and thus should be preserved. 
Topologically ordered finalisation simply extends this to object
finalisation; any finalisable object reachable from another finaliser
via a pointer chain is presumed to be accessible by the finaliser, and
thus should not be finalised.

<!--  -->
<h4 class="subsection">1.2.3 Programming with topological finalisation</h4>

<p class="noindent">Experience with Cedar has shown that cycles or long chains of
finalisable objects are typically not a problem.  Finalisable objects
are typically rare.  There are several ways to reduce spurious
dependencies between finalisable objects.  Splitting objects as
discussed above is one technique.  The collector also provides
<code>GC_register_disappearing_link()</code>, which explicitly sets to
<acronym>NULL</acronym> a pointer before determining finalisation ordering.

   <p>Some so called &ldquo;operating systems&rdquo; fail to clean up some resources
associated with a process.  These resources must be deallocated at all
costs before the process exits whether or not they are still referenced. 
Probably the best way to deal with those is not to rely exclusively on
finalisation.  They should be registered in a table of weak pointers
(implemented as disguised pointers cleared by the finalisation procedure
that deallocates the resource).  If any references are still left when
the process exits, they can be explicitly deallocated at that time.

<!--  -->
<h4 class="subsection">1.2.4 Getting around topological finalisation ordering</h4>

<p class="noindent">There are certain situations in which cycles between finalisable objects
are genuinely unavoidable; most notably, C++ compilers introduce
self&ndash;cycles to represent inheritance.  The function
<code>GC_register_finalizer_ignore_self()</code> tells the finalisation
part of the collector to ignore self cycles.  This is used by the C++
interface.

   <p><samp><span class="file">finalize.c</span></samp> actually contains an intentionally undocumented
mechanism for registering a finalisable object with user defined
dependencies.  The problem is that this dependency information is also
used for memory reclamation, not just finalisation ordering.  Thus
misuse can result in dangling pointers even if finalisation doesn't
create any.  The risk of dangling pointers can be eliminated by building
the collector with <code>-DJAVA_FINALIZATION</code>.  This forces objects
reachable from finalisers to be marked, even though this dependency is
not considered for finalisation ordering.

<!--  -->
<!-- page -->
<div class="node">
<a name="overview-scalability"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#overview-leak">overview leak</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#overview-finalisation">overview finalisation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#overview">overview</a>

</div>

<h3 class="section">1.3 Garbage collector scalability</h3>

<p class="noindent">In its default configuration, the Boehm&ndash;Demers&ndash;Weiser garbage
collector is not thread&ndash;safe.  It can be made thread&ndash;safe for a number
of environments by building the collector with the appropriate
<code>-DXXX-THREADS</code> compilation flag.  This has primarily two effects:

     <ol type=1 start=1>
<li>it causes the garbage collector to stop all other threads when it needs
to see a consistent memory state;

     <li>it causes the collector to acquire a lock around essentially all
allocation and garbage collection activity.
        </ol>

   <p>Since a single lock is used for all allocation&ndash;related activity, only
one thread can be allocating or collecting at one point. This inherently
limits performance of multithreaded applications on multiprocessors.

   <p>On most platforms, the allocator/collector lock is implemented as a spin
lock with exponential back&ndash;off.  Longer wait times are implemented by
yielding and/or sleeping.  If a collection is in progress, the pure
spinning stage is skipped.  This has the advantage that uncontested and
thus most uniprocessor lock acquisitions are very cheap. It has the
disadvantage that the application may sleep for small periods of time
even when there is work to be done.  And threads may be unnecessarily
woken up for short periods.  Nonetheless, this scheme empirically
outperforms native queue&ndash;based mutual exclusion implementations in most
cases, sometimes drastically so.

<!--  -->
<h4 class="subsection">1.3.1 Options for enhanced scalability</h4>

<p class="noindent">Version 6.0 of the collector adds two facilities to enhance collector
scalability on multiprocessors.  As of 6.0alpha1, these are supported
only under Linux on X86 and IA64 processors, though ports to other
otherwise supported Pthreads platforms should be straightforward.  They
are intended to be used together.

     <ul>
<li>Building the collector with <code>-DPARALLEL_MARK</code> allows the collector
to run the mark phase in parallel in multiple threads, and thus on
multiple processors.  The mark phase typically consumes the large
majority of the collection time.  Thus this largely parallelises the
garbage collector itself, though not the allocation process.  Currently
the marking is performed by the thread that triggered the collection,
together with <code>N-1</code> dedicated threads, where <code>N</code> is the number
of processors detected by the collector.  The dedicated threads are
created once at initialisation time.

     <p>A second effect of this flag is to switch to a more concurrent
implementation of <code>GC_malloc_many()</code>, so that free lists can be
built, and memory can be cleared, by more than one thread concurrently.

     <li>Building the collector with <code>-DTHREAD_LOCAL_ALLOC</code> adds support for
thread local allocation.  Before <acronym>GC</acronym> version 7.0, it did not, by
itself, cause thread&ndash;local allocation to be used.  Since version 7.0,
this causes <code>GC_malloc()</code>, <code>GC_malloc_atomic()</code>, and
<code>GC_gcj_malloc()</code> to be redefined to perform thread&ndash;local
allocation.

     <p>Memory returned from thread&ndash;local allocators is completely
interchangeable with that returned by the other <acronym>GC</acronym> allocators.  It
may be used by other threads.  The only difference is that, if the
thread allocates enough memory of a certain kind, it will build a
thread&ndash;local free list for objects of that kind, and allocate from
that.  This greatly reduces locking.  The thread&ndash;local free lists are
refilled using <code>GC_malloc_many()</code>.

     <p>An important side effect of this flag is to replace the default
spin&ndash;then&ndash;sleep lock to be replace by a spin&ndash;then&ndash;queue based
implementation.  This reduces performance for the standard allocation
functions, though it usually improves performance when thread&ndash;local
allocation is used heavily, and thus the number of short&ndash;duration lock
acquisitions is greatly reduced. 
</ul>

   <p>The easiest way to switch an application to thread&ndash;local allocation in
a pre&ndash;version&ndash;7.0 collector was to:

     <ol type=1 start=1>
<li>define the macro <code>GC_REDIRECT_TO_LOCAL</code>, and then include the
<samp><span class="file">gc.h</span></samp> header in each client source file;

     <li>invoke <code>GC_thr_init()</code> before any allocation;

     <li>allocate using <code>GC_MALLOC()</code>, <code>GC_MALLOC_ATOMIC()</code>,
and/or <code>GC_GCJ_MALLOC()</code>.
        </ol>

<!--  -->
<h4 class="subsection">1.3.2 The parallel marking algorithm</h4>

<p class="noindent">We use an algorithm similar to that developed by Endo, Taura, and
Yonezawa at the University of Tokyo.  However, the data structures and
implementation are different, and represent a smaller change to the
original collector source, probably at the expense of extreme
scalability.  Some of the refinements they suggest, e.g. splitting large
objects, were also incorporated into our approach.

   <p>The global mark stack is transformed into a global work queue.  Unlike
the usual case, it never shrinks during a mark phase.  The mark threads
remove objects from the queue by copying them to a local mark stack and
changing the global descriptor to zero, indicating that there is no more
work to be done for this entry.  This removal is done with no
synchronisation.  Thus it is possible for more than one worker to remove
the same entry, resulting in some work duplication.

   <p>The global work queue grows only if a marker thread decides to return
some of its local mark stack to the global one.  This is done if the
global queue appears to be running low, or if the local stack is in
danger of overflowing.  It does require synchronisation, but should be
relatively rare.

   <p>The sequential marking code is reused to process local mark stacks. 
Hence the amount of additional code required for parallel marking is
minimal.

   <p>It should be possible to use generational collection in the presence of
the parallel collector, by calling <code>GC_enable_incremental()</code>. 
This does not result in fully incremental collection, since parallel
mark phases cannot currently be interrupted, and doing so may be too
expensive.

   <p><code>gcj</code>&ndash;style mark descriptors do not currently mix with the
combination of local allocation and incremental collection.  They should
work correctly with one or the other, but not both.

   <p>The number of marker threads is set on start&ndash;up to the number of
available processors (or to the value of the <code>GC_NPROCS</code>
environment variable).  If only a single processor is detected, parallel
marking is disabled.

   <p>Note that setting <code>GC_NPROCS</code> to 1 also causes some lock
acquisitions inside the collector to immediately yield the processor
instead of busy waiting first.  In the case of a multiprocessor and a
client with multiple simultaneously runnable threads, this may have
disastrous performance consequences (e.g. a factor of 10 slowdown).

<!--  -->
<h4 class="subsection">1.3.3 Performance</h4>

<p class="noindent">We conducted some simple experiments with a version of our <acronym>GC</acronym>
benchmark that was slightly modified to run multiple concurrent client
threads in the same address space.  Each client thread does the same
work as the original benchmark, but they share a heap.  This benchmark
involves very little work outside of memory allocation.  This was run
with <acronym>GC</acronym> 6.0alpha3 on a dual processor Pentium III/500 machine under
Linux 2.2.12.

   <p>Running with a thread&ndash;unsafe collector, the benchmark ran in 9 seconds. 
With the simple thread&ndash;safe collector, built with
<code>-DLINUX_THREADS</code>, the execution time increased to 10.3 seconds, or
23.5 elapsed seconds with two clients.

   <p>The times for the <code>malloc()</code> and <code>free()</code> version with
the <acronym>GNU</acronym> C Library are 10.51 (standard library, Pthreads not linked),
20.90 (one thread, Pthreads linked), and 24.55 seconds respectively. 
The benchmark favours a garbage collector, since most objects are small.

   <p>The following table gives execution times for the collector built with
parallel marking and thread&ndash;local allocation support
(<code>-DGC_LINUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC</code>).  We
tested the client using either one or two marker threads, and running
one or two client threads.  Note that the client uses thread local
allocation exclusively.  With <code>-DTHREAD_LOCAL_ALLOC</code> the collector
switches to a locking strategy that is better tuned to less frequent
lock acquisition.  The standard allocation primitives thus perform
slightly worse than without <code>-DTHREAD_LOCAL_ALLOC</code>, and should be
avoided in time&ndash;critical code.

   <p>(The results using <code>pthread_mutex_lock()</code> directly for
allocation locking would have been worse still, at least for older
versions of LinuxThreads.  With <code>THREAD_LOCAL_ALLOC</code>, we first
repeatedly try to acquire the lock with
<code>pthread_mutex_try_lock()</code>, busy waiting between attempts. 
After a fixed number of attempts, we use
<code>pthread_mutex_lock()</code>.)

   <p>These measurements do not use incremental collection, nor was
prefetching enabled in the marker.  We used the C version of the
benchmark.  All measurements are in elapsed seconds on an unloaded
machine.

   <p><table summary=""><tr align="left"><th valign="top">Number of threads </th><th valign="top">1 marker thread (secs.) </th><th valign="top">2 marker threads (secs.) 
<br></th></tr><tr align="left"><td valign="top">1 client </td><td valign="top">10.45 </td><td valign="top">7.85
<br></td></tr><tr align="left"><td valign="top">2 clients	</td><td valign="top">19.95 </td><td valign="top">12.3
   <br></td></tr></table>

   <p>The execution time for the single threaded case is slightly worse than
with simple locking.  However, even the single&ndash;threaded benchmark runs
faster than even the thread&ndash;unsafe version if a second processor is
available.  The execution time for two clients with thread local
allocation time is only 1.4 times the sequential execution time for a
single thread in a thread&ndash;unsafe environment, even though it involves
twice the client work.  That represents close to a factor of 2
improvement over the 2 client case with the old collector.  The old
collector clearly still suffered from some contention overhead, in spite
of the fact that the locking scheme had been fairly well tuned.

   <p>Full linear speedup (i.e. the same execution time for 1 client on one
processor as 2 clients on 2 processors) is probably not achievable on
this kind of hardware even with such a small number of processors, since
the memory system is a major constraint for the garbage collector, the
processors usually share a single memory bus, and thus the aggregate
memory bandwidth does not increase in proportion to the number of
processors.

   <p>These results are likely to be very sensitive to both hardware and OS
issues.  Preliminary experiments with an older Pentium Pro machine
running an older kernel were far less encouraging.

<!--  -->
<!-- page -->
<div class="node">
<a name="overview-leak"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#overview-notes">overview notes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#overview-scalability">overview scalability</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#overview">overview</a>

</div>

<h3 class="section">1.4 Using the garbage collector as leak detector</h3>

<p class="noindent">The garbage collector may be used as a leak detector. In this case, the
primary function of the collector is to report objects that were
allocated (typically with <code>GC_MALLOC()</code>), not deallocated
(normally with <code>GC_FREE()</code>), but are no longer accessible. 
Since the object is no longer accessible, there is normally no way to
deallocate the object at a later time; thus it can be safely assumed
that the object has been &ldquo;leaked&rdquo;.

   <p>This is substantially different from counting leak detectors, which
simply verify that all allocated objects are eventually deallocated.  A
garbage collector based leak detector can provide somewhat more precise
information when an object was leaked.  More importantly, it does not
report objects that are never deallocated because they are part of
&ldquo;permanent&rdquo; data structures.  Thus it does not require all objects to
be deallocated at process exit time, a potentially useless activity that
often triggers large amounts of paging.

   <p>All non&ndash;ancient versions of the garbage collector provide leak
detection support.  Version 5.3 adds the following features:

     <ol type=1 start=1>
<li>leak detection mode can be initiated at run time by setting
<code>GC_find_leak()</code> instead of building the collector with
<code>FIND_LEAK</code> defined; this variable should be set to a non&ndash;zero
value at program start&ndash;up;

     <li>leaked objects should be reported and then correctly garbage collected;
prior versions either reported leaks or functioned as a garbage
collector.
        </ol>

   <p>For the rest of this description we will give instructions that work
with any reasonable version of the collector.

   <p>To use the collector as a leak detector, follow the following steps:

     <ol type=1 start=1>
<li>build the collector with <code>-DFIND_LEAK</code>; otherwise use default build
options;

     <li>change the program so that all allocation and deallocation goes through
the garbage collector;

     <li>arrange to call <code>GC_gcollect()</code> at appropriate points to check
for leaks (for sufficiently long running programs, this will happen
implicitly, but probably not with sufficient frequency).
        </ol>

   <p>The second step can usually be accomplished with the
<code>-DREDIRECT_MALLOC=GC_malloc</code> option when the collector is built,
or by defining <code>malloc()</code>, <code>calloc()</code>,
<code>realloc()</code> and <code>free()</code> to call the corresponding
garbage collector functions.  But this, by itself, will not yield very
informative diagnostics, since the collector does not keep track of
information about how objects were allocated.  The error reports will
include only object addresses.

   <p>For more precise error reports, as much of the program as possible
should use the all uppercase variants of these functions, after defining
<code>GC_DEBUG</code>, and then including <samp><span class="file">gc.h</span></samp>.  In this environment
<code>GC_MALLOC</code> is a macro which causes at least the file name and line
number at the allocation point to be saved as part of the object.  Leak
reports will then also include this information.

   <p>Many collector features (e.g stubborn objects, finalisation, and
disappearing links) are less useful in this context, and are not fully
supported.  Their use will usually generate additional bogus leak
reports, since the collector itself drops some associated objects.

   <p>The same is generally true of thread support.  However, as of 6.0alpha4,
correct leak reports should be generated with LinuxThreads.

   <p>On a few platforms (currently Solaris/SPARC, Irix, and, with
-DSAVE_CALL_CHAIN, Linux/X86), <code>GC_MALLOC()</code> also causes some
more information about its call stack to be saved in the object.  Such
information is reproduced in the error reports in very non&ndash;symbolic
form, but it can be very useful with the aid of a debugger.

<!--  -->
<h4 class="subsection">1.4.1 An example</h4>

<p class="noindent">The following header file <samp><span class="file">leak_detector.h</span></samp> is included in the
<samp><span class="file">include</span></samp> sub&ndash;directory of the distribution:

<pre class="example">     #define GC_DEBUG
     #include "gc.h"
     #define malloc(n)       GC_MALLOC(n)
     #define calloc(m,n)     GC_MALLOC((m)*(n))
     #define free(p)         GC_FREE(p)
     #define realloc(p,n)    GC_REALLOC((p),(n))
     #define CHECK_LEAKS()   GC_gcollect()
</pre>
   <p>Assume the collector has been built with <code>-DFIND_LEAK</code> (for very
new versions of the collector, we could instead add the statement
<code>GC_find_leak = 1</code> as the first statement in <code>main()</code>.

   <p>The program to be tested for leaks can then look like:

<pre class="example">     #include "leak_detector.h"
     
     main (void)
     {
       int * p[10];
       int i;
     
       /* GC_find_leak = 1; for new collector versions not 	*/
       /* compiled with -DFIND_LEAK.                         */
       for (i = 0; i &lt; 10; ++i)
         {
           p[i] = malloc(sizeof(int)+i);
         }
       for (i = 1; i &lt; 10; ++i)
         {
           free(p[i]);
         }
       for (i = 0; i &lt; 9; ++i)
         {
           p[i] = malloc(sizeof(int)+i);
         }
       CHECK_LEAKS();
     }
</pre>
   <p>On an Intel X86 Linux system this produces on the <code>stderr</code> stream:

<pre class="example">     Leaked composite object at 0x806dff0 (leak_test.c:8, sz=4)
</pre>
   <p>On most unmentioned operating systems, the output is similar to this. 
If the collector had been built on Linux/X86 with
<code>-DSAVE_CALL_CHAIN</code>, the output would be closer to the Solaris
example.  For this to work, the program should not be compiled with
<code>-fomit_frame_pointer</code>.

   <p>On Irix it reports:

<pre class="example">     Leaked composite object at 0x10040fe0 (leak_test.c:8, sz=4)
             Caller at allocation:
                     ##PC##= 0x10004910
</pre>
   <p class="noindent">and on Solaris the error report is:

<pre class="example">     Leaked composite object at 0xef621fc8 (leak_test.c:8, sz=4)
             Call chain at allocation:
                     args: 4 (0x4), 200656 (0x30FD0)
                     ##PC##= 0x14ADC
                     args: 1 (0x1), -268436012 (0xEFFFFDD4)
                     ##PC##= 0x14A64
</pre>
   <p>In the latter two cases some additional information is given about how
<code>malloc()</code> was called when the leaked object was allocated.  For
Solaris, the first line specifies the arguments to
<code>GC_debug_malloc()</code> (the actual allocation routine), the second
the program counter inside <code>main()</code>, the third the arguments to
<code>main()</code>, and finally the program counter inside the caller to
<code>main()</code> (i.e. in the C start&ndash;up code).

   <p>In the Irix case, only the address inside the caller to main is given.

   <p>In many cases, a debugger is needed to interpret the additional
information.  On systems supporting the <samp><span class="command">adb</span></samp> debugger, the
<samp><span class="command">callprocs</span></samp> script can be used to replace program counter values
with symbolic names.  As of version 6.1, the collector tries to generate
symbolic names for call stacks if it knows how to do so on the platform. 
This is true on Linux/X86, but not on most other platforms.

<!--  -->
<h4 class="subsection">1.4.2 Simplified leak detection under Linux</h4>

<p class="noindent">Since version 6.1, it should be possible to run the collector in leak
detection mode on a program a.out under Linux/X86 as follows:

     <ol type=1 start=1>
<li>Ensure that <samp><span class="file">a.out</span></samp> is a single threaded executable, or we are
using a very recent (7.0alpha7+) <acronym>GC</acronym> version on Linux.  On most
platforms this does not work at all for multithreaded programs.

     <li>If possible, ensure that the <samp><span class="command">addr2line</span></samp> program is installed in
<samp><span class="file">/usr/bin</span></samp>. (It comes with RedHat Linux.)

     <li>If possible, compile <samp><span class="file">a.out</span></samp> with full debug information.  This
will improve the quality of the leak reports.  With this approach, it is
no longer necessary to call <code>GC_</code> routines explicitly, though that
can also improve the quality of the leak reports.

     <li>Build the collector and install it in directory foo as follows:

     <pre class="example">          $ configure --prefix=foo --enable-full-debug --enable-redirect-malloc --disable-threads
          $ make
          $ make install
</pre>
     <p>With a very recent collector on Linux, it may be safe to omit the
<samp><span class="option">--disable-threads</span></samp>.

     <li>Set environment variables as follows:

          <ul>
<li><code>LD_PRELOAD=foo/lib/libgc.so</code>

          <li><code>GC_FIND_LEAK</code>

          <li>we may also want to set <code>GC_PRINT_STATS</code> (to confirm that the
collector is running) and/or <code>GC_LOOP_ON_ABORT</code> (to facilitate
debugging from another window if something goes wrong);
</ul>

     <li>Simply run <samp><span class="file">a.out</span></samp> as we normally would.  Note that if we run
anything else (e.g. our editor) with those environment variables set, it
will also be leak tested.  This may or may not be useful and/or
embarrassing.  It can generate mountains of leak reports if the
application wasn't designed to avoid leaks, e.g. because it's always
short&ndash;lived.
        </ol>

   <p>This has not yet been thoroughly tested on large applications, but it's
known to do the right thing on at least some small ones.

<!--  -->
<!-- page -->
<div class="node">
<a name="overview-notes"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#overview-leak">overview leak</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#overview">overview</a>

</div>

<h3 class="section">1.5 Notes on the garbage collector</h3>

<p class="noindent">Since the collector does not require pointers to be tagged, it does not
attempt to ensure that all inaccessible storage is reclaimed.  However,
in our experience, it is typically more successful at reclaiming unused
memory than most C programs using explicit deallocation.  Unlike
manually introduced leaks, the amount of unreclaimed memory typically
stays bounded.

   <p>Any objects not intended to be collected must be pointed to either from
other such accessible objects, or from the registers, stack, data, or
statically allocated bss segments.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>

   <p>Pointers from the stack or registers may point to anywhere inside an
object.  The same is true for heap pointers if the collector is compiled
with <code>ALL_INTERIOR_POINTERS</code> defined, or
<code>GC_all_interior_pointers</code> is otherwise set, as is now the default.

   <p>Compiling without <code>ALL_INTERIOR_POINTERS</code> may reduce accidental
retention of garbage objects, by requiring pointers from the heap to to
the beginning of an object.  But this no longer appears to be a
significant issue for most programs occupying a small fraction of the
possible address space.

   <p>There are a number of routines which modify the pointer recognition
algorithm.  <code>GC_register_displacement()</code> allows certain interior
pointers to be recognised even if <code>ALL_INTERIOR_POINTERS</code> is not
defined.  <code>GC_malloc_ignore_off_page()</code> allows some pointers
into the middle of large objects to be disregarded, greatly reducing the
probability of accidental retention of large objects.  For most
purposes it seems best to compile with <code>ALL_INTERIOR_POINTERS</code> and
to use <code>GC_malloc_ignore_off_page()</code> if you get collector
warnings from allocations of very large objects.  See
<samp><span class="file">README.debugging</span></samp> for details.

   <p><strong>Warning</strong> Pointers inside memory allocated by the standard
<code>malloc()</code> are not seen by the garbage collector.  Thus objects
pointed to only from such a region may be prematurely deallocated.  It
is thus suggested that the standard <code>malloc()</code> be used only for
memory regions, such as I/O buffers, that are guaranteed not to contain
pointers to garbage collectable memory.  Pointers in C language
automatic, static, or register variables, are correctly recognised. 
(Note that <code>GC_malloc_uncollectable()</code> has semantics similar to
the standard <code>malloc()</code>, but allocates objects that are traced
by the collector.)

   <p><strong>Warning</strong> The collector does not always know how to find pointers
in data areas that are associated with dynamic libraries.  This is easy
to remedy <strong>if</strong> you know how to find those data areas on your
operating system (see <code>GC_add_roots()</code>).  Code for doing this
under SunOS, IRIX 5.X and 6.X, HP/UX, Alpha OSF/1, Linux, and win32 is
included and used by default.  (See <samp><span class="file">README.win32</span></samp> for win32
details.)  On other systems pointers from dynamic library data areas may
not be considered by the collector.  If you're writing a program that
depends on the collector scanning dynamic library data areas, it may be
a good idea to include at least one call to <code>GC_is_visible()</code> to
ensure that those areas are visible to the collector.

   <p>Note that the garbage collector does not need to be informed of shared
read&ndash;only data.  However if the shared library mechanism can introduce
discontiguous data areas that may contain pointers, then the collector
does need to be informed.

   <p>Signal processing for most signals may be deferred during collection,
and during uninterruptible parts of the allocation process.  Like
standard <acronym>ANSI</acronym> C <code>malloc()</code>, by default it is unsafe to invoke
<code>malloc()</code> (and other <acronym>GC</acronym> routines) from a signal handler while another
<code>malloc()</code> call may be in progress.  Removing <code>-DNO_SIGNALS</code> from
<samp><span class="file">Makefile</span></samp> attempts to remedy that.  But that may not be reliable
with a compiler that substantially reorders memory operations inside
<code>GC_malloc()</code>.

   <p>The allocator/collector can also be configured for thread&ndash;safe
operation.  Full signal safety can also be achieved, but only at the
cost of two system calls per <code>malloc()</code>, which is usually
unacceptable.

   <p><strong>Warning</strong> The collector does not guarantee to scan thread&ndash;local
storage (e.g. of the kind accessed with
<code>pthread_getspecific()</code>).  The collector does scan thread
stacks, though, so generally the best solution is to ensure that any
pointers stored in thread&ndash;local storage are also stored on the thread's
stack for the duration of their lifetime.  (This is arguably a
longstanding bug, but it hasn't been fixed yet.)

   <p>As distributed, the collector operates silently.  In the event of
problems, this can usually be changed by defining the
<code>GC_PRINT_STATS</code> or <code>GC_PRINT_VERBOSE_STATS</code> environment
variables.  This will result in a few lines of descriptive output for
each collection.  (The given statistics exhibit a few peculiarities. 
Things don't appear to add up for a variety of reasons, most notably
fragmentation losses.  These are probably much more significant for the
contrived program "test.c" than for your application.)

   <p>On some machines, it may be desirable to set <code>GC_stacktop()</code> to
a good approximation of the stack base.  (This enhances code portability
on HP PA machines, since there is no good way for the collector to
compute this value.)

<!--  -->
<!-- page -->
<div class="node">
<a name="install"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api">api</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#overview">overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Installation and portability</h2>

<p class="noindent">On most Unix like platforms, the collector can be built either using a
<acronym>GNU</acronym> Autoconf based build infrastructure; type:

<pre class="example">     $ ./configure
     $ make
</pre>
   <p class="noindent">in the simplest case.  With the classic makefile by itself,  type:

<pre class="example">     $ cp Makefile.direct Makefile
     $ make
</pre>
   <p>Here we focus on the latter option.  On other platforms, typically only
the latter option is available, though with a different supplied
<samp><span class="file">Makefile</span></samp>.

   <p>Typing <code>make test</code> instead of <code>make</code> will automatically build
the collector and then run <samp><span class="file">setjmp_test</span></samp> and <samp><span class="file">gctest</span></samp>. 
<samp><span class="file">setjmp_test</span></samp> will give you information about configuring the
collector, which is useful primarily if you have a machine that's not
already supported.  <samp><span class="file">gctest</span></samp> is a somewhat superficial test of
collector functionality.  Failure is indicated by a core dump or a
message to the effect that the collector is broken.  <samp><span class="file">gctest</span></samp> takes
about a second to two to run on reasonable 2007 vintage desktops.  It
may use up to about 30MB of memory.  The multi&ndash;threaded version will
use more.  64-bit versions may use more.  <code>make test</code> will also, as
its last step, attempt to build and test the <code>cord</code> string
library.

   <p>The <samp><span class="file">Makefile</span></samp> will generate a library <samp><span class="file">gc.a</span></samp> which you should
link against.  Typing <code>make cords</code> will add the <code>cord</code> library
to <samp><span class="file">gc.a</span></samp>.  Note that this requires an <acronym>ANSI</acronym> C compiler.

   <p>It is suggested that if you need to replace a piece of the collector
(e.g. <samp><span class="file">GC_mark_rts.c</span></samp>) you simply list your version ahead of
<samp><span class="file">gc.a</span></samp> on the <samp><span class="command">ld</span></samp> command line, rather than replacing the
one in <samp><span class="file">gc.a</span></samp>.  This will generate numerous warnings under some
versions of AIX, but it still works.

   <p>All include files that need to be used by clients will be put in the
<samp><span class="file">include</span></samp> sub&ndash;directory.  Normally this is just <samp><span class="file">gc.h</span></samp>. 
<code>make cords</code> adds <samp><span class="file">cord.h</span></samp> and <samp><span class="file">ec.h</span></samp>.

   <p>The collector currently is designed to run essentially unmodified on
machines that use a flat 32 bits or 64 bits address space.  That
includes the vast majority of Workstations and X86 (X &gt;= 3) PCs.

   <p>In a few cases (Amiga, OS/2, Win32, MacOS) a separate makefile or
equivalent is supplied.  Many of these have separate
<samp><span class="file">README.system</span></samp> files.

   <p>Dynamic libraries are completely supported only under SunOS/Solaris,
(and even that support is not functional on the last Sun 3 release),
Linux, FreeBSD, NetBSD, IRIX 5&amp;6, HP/UX, Win32 (not Win32S) and OSF/1 on
DEC AXP machines plus perhaps a few others listed near the top of
<samp><span class="file">dyn_load.c</span></samp>.  On other machines we recommend that you do one of
the following:

     <ol type=1 start=1>
<li>Add dynamic library support (and send us the code).

     <li>Use static versions of the libraries.

     <li>Arrange for dynamic libraries to use the standard <code>malloc()</code>. 
This is still dangerous if the library stores a pointer to a garbage
collected object.  But nearly all standard interfaces prohibit this,
because they deal correctly with pointers to stack allocated objects. 
(<code>strtok()</code> is an exception.  Don't use it.)
        </ol>

   <p>In all cases we assume that pointer alignment is consistent with that
enforced by the standard C compilers.  If you use a nonstandard compiler
you may have to adjust the alignment parameters defined in
<samp><span class="file">gc_priv.h</span></samp>.  Note that this may also be an issue with packed
records/structures, if those enforce less alignment for pointers.

   <p>A port to a machine that is not byte addressed, or does not use 32 bit
or 64 bit addresses will require a major effort.  A port to plain MSDOS
or win16 is hard.

   <p>For machines not already mentioned, or for nonstandard compilers, some
porting suggestions are provided in the <samp><span class="file">porting.html</span></samp> file.

<!--  -->
<!-- page -->
<div class="node">
<a name="api"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#bugs">bugs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#install">install</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 The C interface to the allocator</h2>

<ul class="menu">
<li><a accesskey="1" href="#api-typedefs">api typedefs</a>:                 Type definitions. 
<li><a accesskey="2" href="#api-variables">api variables</a>:                Public variables. 
<li><a accesskey="3" href="#api-macros">api macros</a>:                   Function wrappers. 
<li><a accesskey="4" href="#api-init">api init</a>:                     Library initialisation. 
<li><a accesskey="5" href="#api-base">api base</a>:                     Basic interface functions. 
<li><a accesskey="6" href="#api-debug">api debug</a>:                    Debugging facilities. 
<li><a accesskey="7" href="#api-inspect">api inspect</a>:                  Inspecting objects. 
<li><a accesskey="8" href="#api-stubborn">api stubborn</a>:                 Stubborn objects. 
<li><a accesskey="9" href="#api-roots">api roots</a>:                    Root memory blocks. 
<li><a href="#api-finalisation">api finalisation</a>:             Finalisation functions. 
<li><a href="#api-operations">api operations</a>:               Miscellaneous operations. 
<li><a href="#api-threads">api threads</a>:                  Handling threads. 
<li><a href="#api-cplusplus">api cplusplus</a>:                The C++ interface to the allocator. 
<li><a href="#api-leak">api leak</a>:                     Use as leak detector. 
<li><a href="#api-collector">api collector</a>:                Incremental/generational collection. 
<li><a href="#api-version">api version</a>:                  Library version informations. 
<li><a href="#api-misc">api misc</a>:                     Miscellaneous stuff. 
</ul>

<p class="noindent">Client code may include <samp><span class="file">gc.h</span></samp>, which defines all of the following
functions.

   <p>All externally visible names in the garbage collector start with
<code>GC_</code>; to avoid name conflicts, client code should avoid this
prefix, except when accessing garbage collector routines or variables.

<div class="defun">
&mdash; Macro: <b>GC_API</b><var><a name="index-GC_005fAPI-2"></a></var><br>
<blockquote><p>Qualifier for all the public functions and variables defined in
<samp><span class="file">gc.h</span></samp>.  Defaults to <code>extern</code>, and we can override this by
just defining the symbol. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-typedefs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-variables">api variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.1 Type definitions</h3>

<div class="defun">
&mdash; Integer Typedef: <b>GC_word</b><var><a name="index-GC_005fword-3"></a></var><br>
&mdash; Integer Typedef: <b>GC_signed_word</b><var><a name="index-GC_005fsigned_005fword-4"></a></var><br>
<blockquote><p>Define word and signed word types to be <code>unsigned</code> and
<code>signed</code> types of the size as <code>char *</code> or <code>void *</code>. 
There seems to be no way to do this even semi&ndash;portably: these type
definitions are probably no better/worse than almost anything else.

        <p>The <acronym>ANSI</acronym> standard suggests that <code>size_t</code> and <code>ptr_diff_t</code>
might be better choices.  But those had incorrect definitions on some
older systems.  Notably <code>typedef int size_t</code> is <strong>wrong</strong>. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-variables"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-macros">api macros</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-typedefs">api typedefs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.2 Public variables</h3>

<h4 class="subsection">3.2.1 Read&ndash;only variables</h4>

<div class="defun">
&mdash; Variable: GC_word <b>GC_gc_no</b><var><a name="index-GC_005fgc_005fno-5"></a></var><br>
<blockquote><p>Counter incremented per collection.  Includes empty GCs at start&ndash;up. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: int <b>GC_parallel</b><var><a name="index-GC_005fparallel-6"></a></var><br>
<blockquote><p>If true garbage collection parallelised for performance on
multiprocessors.  Currently set only implicitly if the collector is
built with <code>-DPARALLEL_MARK</code> and if either: the environment
variable <samp><span class="env">GC_NPROC</span></samp> is set to a number greater than 1, or
<samp><span class="env">GC_NPROC</span></samp> is not set and this is a multiprocessor.

        <p>If <code>GC_parallel</code> is set, incremental collection is only partially
functional, and may not be desirable. 
</p></blockquote></div>

<!--  -->
<h4 class="subsection">3.2.2 Write&ndash;only variables</h4>

<div class="defun">
&mdash; Function Pointer: <b>GC_oom_fn</b><var><a name="index-GC_005foom_005ffn-7"></a></var><br>
<blockquote><p>When there is insufficient memory to satisfy an allocation request, we
return <code>(*GC_oom_fn)()</code>.  The type of the pointer is:

     <pre class="example">          void * (*GC_oom_fn) (size_t <var>bytes_requested</var>)
</pre>
        <p>By default this just returns 0.  If it returns, it must return 0 or a
valid pointer to a previously allocated heap object. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: int <b>GC_find_leak</b><var><a name="index-GC_005ffind_005fleak-8"></a></var><br>
<blockquote><p>Do not actually garbage collect, but simply report inaccessible memory
that was not deallocated with <code>GC_free()</code>.  Initial value is
determined by the <code>FIND_LEAK</code> macro. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: int <b>GC_all_interior_pointers</b><var><a name="index-GC_005fall_005finterior_005fpointers-9"></a></var><br>
<blockquote><p>Arrange for pointers to object interiors to be recognised as valid.  May
not be changed after the garbage collector initialisation.

        <p>The initial value is determined by <code>-DALL_INTERIOR_POINTERS</code>. 
Unless <code>DONT_ADD_BYTE_AT_END</code> is defined, this also affects whether
sizes are increased by at least a byte to allow &ldquo;off the end&rdquo; pointer
recognition.  <strong>Must be 0 or 1</strong>. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: int <b>GC_finalize_on_demand</b><var><a name="index-GC_005ffinalize_005fon_005fdemand-10"></a></var><br>
<blockquote><p>If non&ndash;zero, finalisers will only be run in response to an explicit
<code>GC_invoke_finalizers()</code> call.  The default is determined by
whether the <code>FINALIZE_ON_DEMAND</code> macro is defined when the
collector is built. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: int <b>GC_java_finalization</b><var><a name="index-GC_005fjava_005ffinalization-11"></a></var><br>
<blockquote><p>Mark objects reachable from finalisable objects in a separate post&ndash;pass. 
This makes it a bit safer to use non&ndash;topologically&ndash;ordered
finalisation.  The default value is determined by
<code>JAVA_FINALIZATION</code> macro.

        <p>Enables <code>GC_register_finalizer_unreachable()</code> to work correctly. 
</p></blockquote></div>

<div class="defun">
&mdash; Function Pointer: <b>GC_finalizer_notifier</b><var><a name="index-GC_005ffinalizer_005fnotifier-12"></a></var><br>
<blockquote><p>Invoked by the collector when there are objects to be finalised.  The
type of the pointer is:

     <pre class="example">          void (* GC_finalizer_notifier)(void)
</pre>
        <p>Invoked at most once per garbage collection cycle.  Never invoked unless
<code>GC_finalize_on_demand</code> is set.  Typically this will notify a
finalisation thread, which will call <code>GC_invoke_finalizers()</code> in
response. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: int <b>GC_dont_gc</b><var><a name="index-GC_005fdont_005fgc-13"></a></var><br>
<blockquote><p>If set to non&ndash;zero: do not collect.  In versions 6.2a1+, this overrides
explicit <code>GC_gcollect()</code> calls.  Used as a counter, so that
nested enabling and disabling work correctly.  Should normally be
updated with <code>GC_enable()</code> and <code>GC_disable()</code> calls. 
Direct assignment to <code>GC_dont_gc</code> is deprecated. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: int <b>GC_dont_expand</b><var><a name="index-GC_005fdont_005fexpand-14"></a></var><br>
<blockquote><p>Do not expand heap unless explicitly requested or forced to. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: int <b>GC_use_entire_heap</b><var><a name="index-GC_005fuse_005fentire_005fheap-15"></a></var><br>
<blockquote><p>Cause the non&ndash;incremental collector to use the entire heap before
collecting.  This was the only option for <acronym>GC</acronym> versions &lt; 5.0.  It
sometimes results in more large block fragmentation, since very large
blocks will tend to get broken up during each collection cycle.  It is
likely to result in a larger working set, but lower collection
frequencies, and hence fewer instructions executed in the collector. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: int <b>GC_full_freq</b><var><a name="index-GC_005ffull_005ffreq-16"></a></var><br>
<blockquote><p>Number of partial collections between full collections.  Matters only if
<code>GC_incremental</code> is set.  Full collections are also triggered if
the collector detects a substantial increase in the number of in&ndash;use
heap blocks.

        <p>Values in the tens are now perfectly reasonable, unlike for earlier GC
versions. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: GC_word <b>GC_non_gc_bytes</b><var><a name="index-GC_005fnon_005fgc_005fbytes-17"></a></var><br>
<blockquote><p>Bytes not considered candidates for collection.  Used only to control
scheduling of collections.  Updated by
<code>GC_malloc_uncollectable()</code> and <code>GC_free()</code>.  Wizards
only. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: int <b>GC_no_dls</b><var><a name="index-GC_005fno_005fdls-18"></a></var><br>
<blockquote><p>Don't register dynamic library data segments.  Wizards only.  Should be
used only if the application explicitly registers all roots.

        <p>In Microsoft Windows environments, this will usually also prevent
registration of the main data segment as part of the root set. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: GC_word <b>GC_free_space_divisor</b><var><a name="index-GC_005ffree_005fspace_005fdivisor-19"></a></var><br>
<blockquote><p>Try to make sure that at least <code>N/GC_free_space_divisor</code> bytes are
allocated between collections, where <code>N</code> is twice the number of
traced bytes, plus the number of untraced bytes (bytes in &ldquo;atomic&rdquo;
objects), plus a rough estimate of the root set size.

        <p><code>N</code> approximates collection tracing work for each collection. 
Initially, <code>GC_free_space_divisor = 3</code>.  Increasing its value will
use less space but more collection time.  Decreasing it will appreciably
decrease collection time at the expense of space. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: GC_word <b>GC_max_retries</b><var><a name="index-GC_005fmax_005fretries-20"></a></var><br>
<blockquote><p>The maximum number of garbage collections attempted before reporting out
of memory after heap expansion fails.  Initially <code>0</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: char * <b>GC_stackbottom</b><var><a name="index-GC_005fstackbottom-21"></a></var><br>
<blockquote><p>Cool end of user stack.  May be set in the client prior to calling any
<code>GC_</code> routines.  This avoids some overhead, and potentially some
signals that can confuse debuggers.  Otherwise the collector attempts to
set it automatically.  For multithreaded code, this is the cold end of
the stack for the primordial thread. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: int <b>GC_dont_precollect</b><var><a name="index-GC_005fdont_005fprecollect-22"></a></var><br>
<blockquote><p>Do not collect as part of initialisation.  Should be set only if the
client wants a chance to manually initialise the root set before the
first collection.  Interferes with blacklisting.  Wizards only. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: unsigned long <b>GC_time_limit</b><var><a name="index-GC_005ftime_005flimit-23"></a></var><br>
<blockquote><p>If incremental collection is enabled, We try to terminate collections
after this many milliseconds.  Not a hard time bound.  Setting this to
<code>GC_TIME_UNLIMITED</code> will essentially disable incremental collection
while leaving generational collection enabled. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_TIME_UNLIMITED</b><var><a name="index-GC_005fTIME_005fUNLIMITED-24"></a></var><br>
<blockquote><p>Setting <code>GC_time_limit</code> to this value will disable the &ldquo;pause time
exceeded&rdquo; tests.  Defined to <code>999999</code>. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-macros"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-init">api init</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-variables">api variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.3 Function wrappers</h3>

<p class="noindent">The following C preprocessor macros wrap <acronym>GC</acronym> function calls.  If
<code>GC_DEBUG</code> is defined: they expand to the debugging version of the
functions.

<div class="defun">
&mdash; Macro: <b>GC_MALLOC</b> (<var>sz</var>)<var><a name="index-GC_005fMALLOC-25"></a></var><br>
<blockquote><p>Wrapper for <code>GC_malloc()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_MALLOC_ATOMIC</b> (<var>sz</var>)<var><a name="index-GC_005fMALLOC_005fATOMIC-26"></a></var><br>
<blockquote><p>Wrapper for <code>GC_malloc_atomic()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_STRDUP</b> (<var>s</var>)<var><a name="index-GC_005fSTRDUP-27"></a></var><br>
<blockquote><p>Wrapper for <code>GC_strdup()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_MALLOC_UNCOLLECTABLE</b> (<var>sz</var>)<var><a name="index-GC_005fMALLOC_005fUNCOLLECTABLE-28"></a></var><br>
<blockquote><p>Wrapper for <code>GC_malloc_uncollectable()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_MALLOC_IGNORE_OFF_PAGE</b> (<var>sz</var>)<var><a name="index-GC_005fMALLOC_005fIGNORE_005fOFF_005fPAGE-29"></a></var><br>
<blockquote><p>Wrapper for <code>GC_malloc_ignore_off_page()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_MALLOC_ATOMIC_IGNORE_OFF_PAGE</b> (<var>sz</var>)<var><a name="index-GC_005fMALLOC_005fATOMIC_005fIGNORE_005fOFF_005fPAGE-30"></a></var><br>
<blockquote><p>Wrapper for <code>GC_malloc_atomic_ignore_off_page()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_REALLOC</b> (<var>old, sz</var>)<var><a name="index-GC_005fREALLOC-31"></a></var><br>
<blockquote><p>Wrapper for <code>GC_realloc()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_FREE</b> (<var>p</var>)<var><a name="index-GC_005fFREE-32"></a></var><br>
<blockquote><p>Wrapper for <code>GC_free()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_REGISTER_FINALIZER</b> (<var>p, f, d, of, od</var>)<var><a name="index-GC_005fREGISTER_005fFINALIZER-33"></a></var><br>
<blockquote><p>Wrapper for <code>GC_register_finalizer()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_REGISTER_FINALIZER_IGNORE_SELF</b> (<var>p, f, d, of, od</var>)<var><a name="index-GC_005fREGISTER_005fFINALIZER_005fIGNORE_005fSELF-34"></a></var><br>
<blockquote><p>Wrapper for <code>GC_register_finalizer_ignore_self()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_REGISTER_FINALIZER_NO_ORDER</b> (<var>p, f, d, of, od</var>)<var><a name="index-GC_005fREGISTER_005fFINALIZER_005fNO_005fORDER-35"></a></var><br>
<blockquote><p>Wrapper for <code>GC_register_finalizer_no_order()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_REGISTER_FINALIZER_UNREACHABLE</b> (<var>p, f, d, of, od</var>)<var><a name="index-GC_005fREGISTER_005fFINALIZER_005fUNREACHABLE-36"></a></var><br>
<blockquote><p>Wrapper for <code>GC_register_finalizer_unreachable()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_MALLOC_STUBBORN</b> (<var>sz</var>)<var><a name="index-GC_005fMALLOC_005fSTUBBORN-37"></a></var><br>
<blockquote><p>Wrapper for <code>GC_malloc_stubborn()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_CHANGE_STUBBORN</b> (<var>p</var>)<var><a name="index-GC_005fCHANGE_005fSTUBBORN-38"></a></var><br>
<blockquote><p>Wrapper for <code>GC_change_stubborn()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_END_STUBBORN_CHANGE</b> (<var>p</var>)<var><a name="index-GC_005fEND_005fSTUBBORN_005fCHANGE-39"></a></var><br>
<blockquote><p>Wrapper for <code>GC_end_stubborn_change()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_GENERAL_REGISTER_DISAPPEARING_LINK</b> (<var>link, obj</var>)<var><a name="index-GC_005fGENERAL_005fREGISTER_005fDISAPPEARING_005fLINK-40"></a></var><br>
<blockquote><p>Wrapper for <code>GC_general_register_disappearing_link()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_REGISTER_DISPLACEMENT</b> (<var>n</var>)<var><a name="index-GC_005fREGISTER_005fDISPLACEMENT-41"></a></var><br>
<blockquote><p>Wrapper for <code>GC_register_displacement()</code>. 
</p></blockquote></div>

<!--  -->
<h4 class="subsection">3.3.1 Other macros</h4>

<p class="noindent">The following are included because they are often convenient, and reduce
the chance for a misspecified size argument.  But calls may expand to
something syntactically incorrect if <var>data_type</var> is a complicated
type expression.

<div class="defun">
&mdash; Macro: <b>GC_NEW</b> (<var>data_type</var>)<var><a name="index-GC_005fNEW-42"></a></var><br>
<blockquote><p>Apply <code>GC_MALLOC()</code> to the size of <var>data_type</var>.  Example:

     <pre class="example">          typedef struct {
            size_t        len;
            char *        data;
          } mine_t;
          
          
          mine_t *        p = GC_NEW(mine_t);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_NEW_ATOMIC</b> (<var>data_type</var>)<var><a name="index-GC_005fNEW_005fATOMIC-43"></a></var><br>
<blockquote><p>Apply <code>GC_MALLOC_ATOMIC()</code> to the size of <var>data_type</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_NEW_STUBBORN</b> (<var>data_type</var>)<var><a name="index-GC_005fNEW_005fSTUBBORN-44"></a></var><br>
<blockquote><p>Apply <code>GC_MALLOC_STUBBORN()</code> to the size of <var>data_type</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_NEW_UNCOLLECTABLE</b> (<var>data_type</var>)<var><a name="index-GC_005fNEW_005fUNCOLLECTABLE-45"></a></var><br>
<blockquote><p>Apply <code>GC_MALLOC_uncollectable()</code> to the size of
<var>data_type</var>. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-init"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-base">api base</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-macros">api macros</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.4 Library initialisation</h3>

<div class="defun">
&mdash; Macro: <b>GC_INIT</b> ()<var><a name="index-GC_005fINIT-46"></a></var><br>
<blockquote><p>Fully portable code should call <code>GC_INIT()</code> from the main
program before making any other <code>GC_</code> calls.  On most platforms
this is a no&ndash;op and the collector self&ndash;initialises.  But a number of
platforms make that too hard.

        <p>A <code>GC_INIT()</code> call is required if the collector is built with
<code>THREAD_LOCAL_ALLOC</code> defined and the initial allocation call is not
to <code>GC_malloc()</code> or <code>GC_malloc_atomic()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_init</b> (<var>void</var>)<var><a name="index-GC_005finit-47"></a></var><br>
<blockquote><p>Initialise the collector.  Portable clients should call
<code>GC_INIT()</code> from the main program instead. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-base"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-debug">api debug</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-init">api init</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.5 Basic interface functions</h3>

<p class="noindent">The following routines are intended to be directly called by the user:
they are general purpose allocation routines, with roughly <code>malloc()</code>
calling conventions.  Note that usually only <code>GC_malloc()</code> is
necessary.

   <p>All the following functions have a debugging version in the library.

<div class="defun">
&mdash; Function: void * <b>GC_malloc</b> (<var>size_t size_in_bytes</var>)<var><a name="index-GC_005fmalloc-48"></a></var><br>
<blockquote><p>Allocate an object of <var>size_in_bytes</var>.  Unlike <code>malloc()</code>, the object
is cleared before being returned to the user.  This function will invoke
the garbage collector if it determines that the operation is
appropriate.

        <p>The return value may be <acronym>NULL</acronym> if <acronym>GC</acronym> is unable to acquire sufficient
space from the operating system.  This is the most probable consequence
of running out of space.  Other possible consequences are that a
function call will fail due to lack of stack space, or that the
collector will fail in other ways because it cannot maintain its
internal data structures, or that a crucial system process will fail and
take down the machine.  Most of these possibilities are independent of
the <code>malloc()</code> implementation. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void * <b>GC_malloc_atomic</b> (<var>size_t size_in_bytes</var>)<var><a name="index-GC_005fmalloc_005fatomic-49"></a></var><br>
<blockquote><p>Allocate an object of <var>size_in_bytes</var> that is guaranteed not to
contain pointers to other objects.  The returned object is not
guaranteed to be cleared.

        <p>A call to this function can always be replaced by <code>GC_malloc()</code>,
but results in faster collection times.  The collector will probably run
faster if large character arrays, etc. are allocated with
<code>GC_malloc_atomic()</code> than if they are statically allocated. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void * <b>GC_realloc</b> (<var>void * old_object, size_t new_size_in_bytes</var>)<var><a name="index-GC_005frealloc-50"></a></var><br>
<blockquote><p>Change the size of object to be <var>new_size_in_bytes</var>.  Return a
pointer to the new object, which may, or may not, be the same as the
pointer to the old object.

        <p>The new object is taken to be atomic if and only if the old one was.  If
the new object is composite and larger than the original object, then
the newly added bytes are cleared (we hope).

        <p>If the object is stubborn, the result will have changes enabled.  It is
an error to have changes enabled for the original object.

        <p>This function follows <acronym>ANSI</acronym> conventions if <var>old_object</var> is
<acronym>NULL</acronym>.

        <p>This is very likely to allocate a new object, unless <code>MERGE_SIZES</code>
is defined in <samp><span class="file">gc_priv.h</span></samp>.  Even then, it is likely to recycle the
old object only if the object is grown in small additive increments
(which, generally, can be seen as a bad coding practise). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_free</b> (<var>void * object_addr</var>)<var><a name="index-GC_005ffree-51"></a></var><br>
<blockquote><p>Explicitly deallocate an object returned by <code>GC_malloc()</code> or
<code>GC_malloc_atomic()</code>, dangerous if used incorrectly:

          <ol type=1 start=1>
<li>requires a pointer to the base of an object;

          <li>if the argument is stubborn: it should <strong>not</strong> be changeable when
freed;

          <li>an object should not be enabled for finalisation when it is explicitly
deallocated.
             </ol>

        <p>Calling this function is not necessary and probably a performance loss
for very small objects (&lt;= 8 bytes), but can minimise the number of
collections if performance is critical.

        <p>Calling <code>GC_free(NULL)</code> does nothing, as required by <acronym>ANSI</acronym> C for
<code>free()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void * <b>GC_malloc_uncollectable</b> (<var>size_t size_in_bytes</var>)<var><a name="index-GC_005fmalloc_005funcollectable-52"></a></var><br>
<blockquote><p>Allocate an object that is scanned for pointers to collectable objects,
but is not itself collectable.  The object is scanned even if it does
not appear to be reachable. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void * <b>GC_malloc_atomic_uncollectable</b> (<var>size_t size_in_bytes</var>)<var><a name="index-GC_005fmalloc_005fatomic_005funcollectable-53"></a></var><br>
<blockquote><p>Allocate an object that is both atomic and uncollectable.

        <p>This function is available only if <acronym>GC</acronym> was configured without handing
the <samp><span class="option">--disable-atomic-uncollectable</span></samp> option to
<samp><span class="command">configure</span></samp>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: char * <b>GC_strdup</b> (<var>const char * str</var>)<var><a name="index-GC_005fstrdup-54"></a></var><br>
<blockquote><p>Like the standard <code>strdup()</code>, but store the string copy in a
newly allocated object. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void * <b>GC_malloc_many</b> (<var>size_t object_size</var>)<var><a name="index-GC_005fmalloc_005fmany-55"></a></var><br>
<blockquote><p>This returns a list of objects, each of <var>object_size</var> bytes, linked
through their first word.  When the first object is logically popped
from the list, its first word should be overwritten.

        <p>Using this function can greatly reduce lock contention problems in
multithreading programs, since the allocation lock can be acquired and
released many fewer times. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_NEXT</b> (<var>p</var>)<var><a name="index-GC_005fNEXT-56"></a></var><br>
<blockquote><p>Retrieve the next element in the list returned by
<code>GC_malloc_many()</code>. 
</p></blockquote></div>

   <p>Example:

<pre class="example">     void *  first;
     void *  p;
     
     first = GC_malloc_many(4096);
     
     /* pop the first */
     p     = first;
     first = GC_NEXT(p);
     
     /* here we use "p" for something,
        "first" holds the top of the list */
</pre>
   <!--  -->
<!-- page -->
<div class="node">
<a name="api-debug"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-inspect">api inspect</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-base">api base</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.6 Debugging facilities</h3>

<ul class="menu">
<li><a accesskey="1" href="#api-debug-special">api debug special</a>:            Special debugging functions. 
<li><a accesskey="2" href="#api-debug-validation">api debug validation</a>:         Validation functions. 
<li><a accesskey="3" href="#api-debug-pointer">api debug pointer</a>:            Pointer operation macros. 
</ul>

<div class="defun">
&mdash; Macro: <b>GC_DEBUG</b><var><a name="index-GC_005fDEBUG-57"></a></var><br>
<blockquote><p>C preprocessor symbol that activates the debugging features of <acronym>GC</acronym>;
undefined by default, it must be defined before the inclusion of the
<samp><span class="file">gc.h</span></samp> header file, example:

     <pre class="example">          #define GC_DEBUG        1
          #include &lt;gc.h&gt;
</pre>
        <p class="noindent">or defined on the command line of the compiler, usually with an option
like <code>-DGC_DEBUG</code>. 
</p></blockquote></div>

   <p><a name="index-g_t_0040env_007bGC_005fDUMP_005fREGULARLY_007d-58"></a>

<div class="defun">
&mdash; Function: void <b>GC_dump</b> (<var>void</var>)<var><a name="index-GC_005fdump-59"></a></var><br>
<blockquote><p>Explicitly dump the <acronym>GC</acronym> state.  This is most often called from the
debugger, or by setting the <samp><span class="env">GC_DUMP_REGULARLY</span></samp> environment
variable, but it may be useful to call it from client code during
debugging. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-debug-special"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-debug-validation">api debug validation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-debug">api debug</a>

</div>

<h4 class="subsection">3.6.1 Special debugging functions</h4>

<div class="defun">
&mdash; Function: void * <b>GC_debug_malloc_replacement</b> (<var>size_t size_in_bytes</var>)<var><a name="index-GC_005fdebug_005fmalloc_005freplacement-60"></a></var><br>
&mdash; Function: void * <b>GC_debug_realloc_replacement</b> (<var>void * object_addr, size_t size_in_bytes</var>)<var><a name="index-GC_005fdebug_005frealloc_005freplacement-61"></a></var><br>
<blockquote><p>Routines that allocate objects with debug information, but just fill in
dummy file and line number information.  Thus they can serve as drop&ndash;in
malloc/realloc replacements.

        <p>This can be useful for two reasons:

          <ol type=1 start=1>
<li>it allows the collector to be built with <code>DBG_HDRS_ALL</code> defined
even if some allocation calls come from 3rd party libraries that can't
be recompiled;

          <li>on some platforms, the file and line information is redundant, since it
can be reconstructed from a stack trace; on such platforms it may be
more convenient not to recompile, e.g. for leak detection; this can be
accomplished by instructing the linker to replace
<code>malloc()</code>/<code>realloc()</code> with these.
             </ol>
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-debug-validation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-debug-pointer">api debug pointer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-debug-special">api debug special</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-debug">api debug</a>

</div>

<h4 class="subsection">3.6.2 Validation functions</h4>

<p class="noindent">The following routines are primarily intended for use with the C
preprocessor which inserts calls to check C pointer arithmetic.  They
indicate failure by invoking the corresponding <code>_print_proc</code>.

   <p><a href="#api-debug-pointer">api debug pointer</a> for examples of usage by <acronym>GC</acronym>.

<div class="defun">
&mdash; Function Pointer Variable: <b>GC_same_obj_print_proc</b><var><a name="index-GC_005fsame_005fobj_005fprint_005fproc-62"></a></var><br>
<blockquote><p>Failure function invoked by <code>GC_same_obj()</code>.  Its type is:

     <pre class="example">          void (*GC_same_obj_print_proc) (void * p, void * q);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function Pointer Variable: <b>GC_is_valid_displacement_print_proc</b><var><a name="index-GC_005fis_005fvalid_005fdisplacement_005fprint_005fproc-63"></a></var><br>
<blockquote><p>Failure function invoked by <code>GC_is_valid_displacement()</code>.  Its
type is:

     <pre class="example">          void (*GC_is_valid_displacement_print_proc) (void * p);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function Pointer Variable: <b>GC_is_visible_print_proc</b><var><a name="index-GC_005fis_005fvisible_005fprint_005fproc-64"></a></var><br>
<blockquote><p>Failure function invoked by <code>GC_is_visible()</code>.  Its type is:

     <pre class="example">          GC_API void (*GC_is_visible_print_proc) (void * p);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: void * <b>GC_same_obj</b> (<var>void * p, void * q</var>)<var><a name="index-GC_005fsame_005fobj-65"></a></var><br>
<blockquote><p>Check that <var>p</var> and <var>q</var> point to the same object.  Fail
conspicuously if they don't.  Return the first argument.  Succeed if
neither <var>p</var> nor <var>q</var> point to the heap.  May succeed if both
<var>p</var> and <var>q</var> point to between heap objects. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void * <b>GC_pre_incr</b> (<var>void ** p, size_t how_much</var>)<var><a name="index-GC_005fpre_005fincr-66"></a></var><br>
&mdash; Function: void * <b>GC_post_incr</b> (<var>void ** p, size_t how_much</var>)<var><a name="index-GC_005fpost_005fincr-67"></a></var><br>
<blockquote><p>Checked pointer pre- and post- increment operations.

        <p>Both the functions increment the pointer <code>*</code><var>p</var> (not <var>p</var>)
by <var>how_much</var>, then store the result in <code>*</code><var>p</var>; the return
value of <code>GC_pre_incr()</code> is the value of <code>*</code><var>p</var>
<strong>after</strong> the increment, the return value of
<code>GC_post_incr()</code> is the value of <code>*</code><var>p</var> <strong>before</strong>
the increment.  Note that the second argument is in units of bytes, not
multiples of the size of data referenced by <code>*</code><var>p</var>.

        <p><code>GC_same_obj()</code> is used to verify that <code>*</code><var>p</var> and
<code>(*</code><var>p</var><code>)+</code><var>how_much</var> reference the same object. 
<code>GC_is_valid_displacement()</code> is used to validate the result of
the increment. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void * <b>GC_is_visible</b> (<var>void * p</var>)<var><a name="index-GC_005fis_005fvisible-68"></a></var><br>
<blockquote><p>Check that <var>p</var> is visible to the collector as a possibly pointer
containing location.  If it isn't fail conspicuously.  Returns the
argument in all cases.  May erroneously succeed in hard cases.

        <p>This function is intended for debugging use with untyped allocations. 
The idea is that it should be possible, though slow, to add such a call
to all indirect pointer stores.

        <p>Currently useless for multithreaded worlds. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void * <b>GC_is_valid_displacement</b> (<var>void * p</var>)<var><a name="index-GC_005fis_005fvalid_005fdisplacement-69"></a></var><br>
<blockquote><p>Check that if <var>p</var> is a pointer to a heap page, then it points to a
valid displacement within a heap object.  Fail conspicuously if this
property does not hold.  Uninteresting with
<code>GC_all_interior_pointers</code>.  Always return its argument. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-debug-pointer"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-debug-validation">api debug validation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api-debug">api debug</a>

</div>

<h4 class="subsection">3.6.3 Pointer operation macros</h4>

<p class="noindent">The following macros implement basic pointer operations with calls to
<acronym>GC</acronym> validation functions; they are useful only for heap pointers.

   <p>If <code>GC_DEBUG</code> and <code>__GNUC__</code> are defined the macros make use
of the validation functions, else they revert to the basic C language
operators; this is because the <code>typeof</code> keyword is needed to
implement them correctly.

<div class="defun">
&mdash; Macro: <b>GC_PTR_ADD</b> (<var>x, n</var>)<var><a name="index-GC_005fPTR_005fADD-70"></a></var><br>
<blockquote><p>Add the integer <var>n</var> to the pointer <var>x</var> and return the result; if
<code>GC_DEBUG</code> is <strong>not</strong> defined, the expansion is:

     <pre class="example">          ((<var>x</var>) + (<var>n</var>))
</pre>
        <p class="noindent">else <code>GC_same_obj()</code> is used to verify that <var>x</var> and
<var>x</var><code>+</code><var>n</var> reference the same object.  Example:

     <pre class="example">          mine_t * p = ...;
          mine_t * q = GC_PTR_ADD(p, 256);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_PRE_INCR</b> (<var>x, n</var>)<var><a name="index-GC_005fPRE_005fINCR-71"></a></var><br>
<blockquote><p>Increment the pointer <var>x</var> by <var>n</var> times the size of data
referenced by <var>x</var>, then store the result in <var>x</var> itself; if
<code>GC_DEBUG</code> is <strong>not</strong> defined, the expansion is:

     <pre class="example">          ((<var>x</var>) += (<var>n</var>))
</pre>
        <p class="noindent">else <code>GC_pre_incr()</code> is used to validate the operation. 
Example:

     <pre class="example">          mine_t * p = ...;
          
          GC_PRE_INCR(p, 1);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_POST_INCR</b> (<var>x, n</var>)<var><a name="index-GC_005fPOST_005fINCR-72"></a></var><br>
<blockquote><p>Increment the pointer <var>x</var> by <var>n</var> times the size of data
referenced by <var>x</var>, then return the value of <var>x</var> <strong>after</strong>
the increment; if <code>GC_DEBUG</code> is <strong>not</strong> defined, the expansion
is:

     <pre class="example">          ((<var>x</var>)++)
</pre>
        <p class="noindent">else <code>GC_post_incr()</code> is used to validate the operation. 
Example:

     <pre class="example">          mine_t * p = ...;
          mine_t * q = GC_POST_INCR(p, 1);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_PTR_STORE</b> (<var>p, q</var>)<var><a name="index-GC_005fPTR_005fSTORE-73"></a></var><br>
<blockquote><p>Store the pointer <var>q</var> into the location referenced by <var>p</var>; if
<code>GC_DEBUG</code> is <strong>not</strong> defined, the expansion is:

     <pre class="example">          *(<var>p</var>) = <var>q</var>
</pre>
        <p class="noindent">else <var>q</var> is validated with <code>GC_is_valid_displacement()</code> and
<var>p</var> is validated with <code>GC_is_visible()</code>. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-inspect"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-stubborn">api stubborn</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-debug">api debug</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.7 Inspecting objects</h3>

<div class="defun">
&mdash; Function: void * <b>GC_base</b> (<var>void * displaced_pointer</var>)<var><a name="index-GC_005fbase-74"></a></var><br>
<blockquote><p>Return a pointer to the base (lowest address) of an object given a
pointer to a location within the object; in other words: map an interior
pointer to the corresponding base pointer.

        <p>Note that with debugging allocation, this function returns a pointer to
the actual base of the object, i.e. the debug information, not to the
base of the user object.

        <p>Return <acronym>NULL</acronym> if <var>displaced_pointer</var> doesn't point to within a
valid object.

        <p>Note that a deallocated object in the garbage collected heap may be
considered valid, even if it has been deallocated with
<code>GC_free()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: size_t <b>GC_size</b> (<var>void * object_addr</var>)<var><a name="index-GC_005fsize-75"></a></var><br>
<blockquote><p>Given a pointer to the <strong>base</strong> of an object, return its size in
bytes.  The returned size may be slightly larger than what was
originally requested. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-stubborn"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-roots">api roots</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-inspect">api inspect</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.8 Stubborn objects</h3>

<p class="noindent">Stubborn objects may be changed only if the collector is explicitly
informed.  A &ldquo;change&rdquo; is the action of storing in the object a
non&ndash;<acronym>NULL</acronym> pointer referencing another object.  The collector is
implicitly informed of coming change when such an object is first
allocated.

   <p>There is a performance penalty for allowing more than one stubborn
object to be changed at once, but it is acceptable to do so.  The same
applies to dropping stubborn objects that are still changeable.

<div class="defun">
&mdash; Function: void * <b>GC_malloc_stubborn</b> (<var>size_t size_in_bytes</var>)<var><a name="index-GC_005fmalloc_005fstubborn-76"></a></var><br>
<blockquote><p>Allocate an object and allows us to signal to <acronym>GC</acronym> that no changes to
it will occur after <code>GC_end_stubborn_change()</code> has been applied. 
</p></blockquote></div>

   <p>Remember that reallocating a stubborn object with <code>GC_realloc()</code>
will leave it with changes <strong>enabled</strong> and it is an error to apply
<code>GC_realloc()</code> to an object with changes enables.

<div class="defun">
&mdash; Function: void <b>GC_change_stubborn</b> (<var>void * object</var>)<var><a name="index-GC_005fchange_005fstubborn-77"></a></var><br>
<blockquote><p>Signal to <acronym>GC</acronym> the beginning of a change in the stubborn <var>object</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_end_stubborn_change</b> (<var>void * object</var>)<var><a name="index-GC_005fend_005fstubborn_005fchange-78"></a></var><br>
<blockquote><p>Signal to <acronym>GC</acronym> the end of a change in the stubborn <var>object</var>.

        <p><var>object</var> must be <strong>exactly</strong> the value returned by
<code>GC_malloc_stubborn()</code> or passed to
<code>GC_change_stubborn()</code>.  In the second case it may be an
interior pointer within 512 bytes from the beginning of the object. 
</p></blockquote></div>

   <p>Usage example for stubborn objects:

<pre class="example">     typedef struct {
       size_t        len;
       uint8_t *     data;
     } mine_t;
     
     mine_t *
     mine_alloc (size_t len)
     {
       mine_t *      o;
     
       o = GC_malloc_stubborn(sizeof(mine_t));
       if (NULL == o)
         goto alloc_error;
       {
         o-&gt;len  = len;
         o-&gt;data = GC_malloc_atomic(len);
         if (NULL == o-&gt;data)
           goto alloc_error;
         memset(o-&gt;data, '\0', o-&gt;len);
       }
       GC_end_stubborn_change(o);
       return o;
     
      alloc_error:
       /* handle the error */
     }
     
     void
     mine_realloc (mine_t * o, size_t newlen)
     {
       mine_t *    p;
     
       p = GC_realloc(o-&gt;data, newlen);
       if (NULL == p)
         goto alloc_error;
     
       GC_change_stubborn (o);
       {
         o-&gt;data = p;
       }
       GC_end_stubborn_change(o);
       return;
     
      alloc_error:
       /* handle the error */
     }
</pre>
   <!--  -->
<!-- page -->
<div class="node">
<a name="api-roots"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-finalisation">api finalisation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-stubborn">api stubborn</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.9 Root memory blocks</h3>

<p class="noindent"><code>GC_clear_roots()</code> and <code>GC_add_roots()</code> calls may be
required if the collector has to trace from nonstandard places,
e.g. from dynamic library data areas on a machine on which the collector
doesn't already understand them.

<div class="defun">
&mdash; Function: void <b>GC_clear_roots</b> (<var>void</var>)<var><a name="index-GC_005fclear_005froots-79"></a></var><br>
<blockquote><p>Clear the set of root segments.  Wizards only. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_add_roots</b> (<var>void * low_address, void * high_address_plus_1</var>)<var><a name="index-GC_005fadd_005froots-80"></a></var><br>
<blockquote><p>Add a root segment.  Wizards only. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_remove_roots</b> (<var>void * low_address, void * high_address_plus_1</var>)<var><a name="index-GC_005fremove_005froots-81"></a></var><br>
<blockquote><p>Remove a root segment.  Wizards only. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_exclude_static_roots</b> (<var>void * low_address, void * high_address_plus_1</var>)<var><a name="index-GC_005fexclude_005fstatic_005froots-82"></a></var><br>
<blockquote><p>Inform the collector that a certain section of statically allocated
memory contains no pointers to garbage collected memory, thus it does
not need to be scanned.  This is sometimes important if the application
maps large read/write files into the address space, which could be
mistaken for dynamic library data segments on some systems. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-finalisation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-operations">api operations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-roots">api roots</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.10 Finalisation functions</h3>

<p class="noindent">Some of the following primitives are grossly unsafe.  The idea is to
make them both cheap, and sufficient to build a safer layer, closer to
Modula-3, Java, or PCedar finalisation.<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>

<div class="defun">
&mdash; Function Pointer: <b>GC_finalization_proc</b><var><a name="index-GC_005ffinalization_005fproc-83"></a></var><br>
<blockquote><p>Function pointer with the following definition:

     <pre class="example">          typedef void (*GC_finalization_proc) (void * obj, void * client_data);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_register_finalizer</b> (<var>void * object, GC_finalization_proc final, void * client_data, GC_finalization_proc * old_final, void ** old_client_data</var>)<var>;<a name="index-GC_005fregister_005ffinalizer-84"></a></var><br>
<blockquote><p>When <var>object</var> is no longer accessible, invoke:

     <pre class="example">          (*<var>final</var>)(<var>object</var>, <var>client_data</var>)
</pre>
        <p class="noindent">to allow some finalisation operations on the data in the object.

        <p>If <code>a</code> and <code>b</code> are inaccessible, and <code>a</code> points to
<code>b</code> (after disappearing links have been made to disappear), then
only <code>a</code> will be finalised.  If this does not create any new
pointers to <code>b</code>, then <code>b</code> will be finalised after the next
collection.

        <p>Any finalisable object that is reachable from itself by following one or
more pointers will not be finalised (or collected).  Thus cycles
involving finalisable objects should be avoided, or broken by
disappearing links.  All but the last finaliser registered for an object
is ignored.

        <p>A finalisation function may be removed by passing <acronym>NULL</acronym> as
<var>final</var>.

        <p>Finalisers are implicitly unregistered just before they are invoked.  If
<var>old_final</var> is not <acronym>NULL</acronym>: the old finaliser is stored in
<code>*</code><var>old_final</var>.  If <var>old_client_data</var> is not <acronym>NULL</acronym>: the
old client data is stored in <code>*</code><var>old_client_data</var>.

        <p><var>final</var> is never invoked on an accessible object, provided hidden
pointers are converted to real pointers only if the allocation lock is
held, and such conversions are not performed by finalisation routines.

        <p>If <code>GC_register_finalizer()</code> is aborted as a result of a signal,
the object may be left with no finalisation, even if neither the old nor
new finaliser were <acronym>NULL</acronym>.

        <p><var>object</var> should be the non&ndash;<acronym>NULL</acronym> starting address of an object
allocated by <code>GC_malloc()</code> or friends.

        <p>Note that any garbage collectable object referenced by <var>client_data</var>
will be considered accessible until the finaliser is invoked. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_register_finalizer_ignore_self</b> (<var>void * object, GC_finalization_proc final, void * client_data, GC_finalization_proc * old_final, void ** old_client_data</var>)<var>;<a name="index-GC_005fregister_005ffinalizer_005fignore_005fself-85"></a></var><br>
<blockquote><p>Like <code>GC_register_finalizer()</code>.  It ignores self cycles,
i.e. pointers from a finalisable object to itself.

        <p>There is a stylistic argument that this is wrong, but it's unavoidable
for C++, since the compiler may silently introduce these.  It's also
benign in that specific case.  And it helps if finalisable objects are
split to avoid cycles.  Note that <var>client_data</var> will still be viewed
as accessible, even if it refers to the object itself. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_register_finalizer_no_order</b> (<var>void * object, GC_finalization_proc final, void * client_data, GC_finalization_proc * old_client_final, void ** old_client_data</var>)<var><a name="index-GC_005fregister_005ffinalizer_005fno_005forder-86"></a></var><br>
<blockquote><p>Like <code>GC_register_finalizer()</code>.  It ignores all cycles.  It
should probably only be used by Java implementations.  Note that
<var>client_data</var> will still be viewed as accessible, even if it refers
to the object itself. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_register_finalizer_unreachable</b> (<var>void * object, GC_finalization_proc final, void * client_data, GC_finalization_proc * old_final, void ** old_client_data</var>)<var><a name="index-GC_005fregister_005ffinalizer_005funreachable-87"></a></var><br>
<blockquote><p>This is a special finaliser that is useful when an object's finaliser
must be run when the object is known to be no longer reachable, not even
from other finalisable objects.

        <p>It behaves like &ldquo;normal&rdquo; finalisation, except that the finaliser is
not run while the object is reachable from other objects specifying
unordered finalisation.  Effectively it allows an object referenced,
possibly indirectly, from an unordered finalisable object to override
the unordered finalisation request.

        <p>This can be used in combination with
<code>GC_register_finalizer_no_order()</code> so as to release resources
that must not be released while an object can still be brought back to
life by other finalisers.

        <p>Only works if <code>GC_java_finalization</code> is set.  Probably only of
interest when implementing a language that requires unordered
finalisation (e.g. Java, C#). 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>GC_register_disappearing_link</b> (<var>void ** link</var>)<var><a name="index-GC_005fregister_005fdisappearing_005flink-88"></a></var><br>
<blockquote><p>Break cycles between finalisable objects, thus causing cyclic
finalisable objects to be finalised in the correct order.

        <p>Standard use involves calling <code>GC_register_disappearing_link(&amp;p)</code>,
where <code>p</code> is a pointer that is not followed by finalisation code,
and should not be considered in determining finalisation order.

        <p><var>link</var> should point to a field of a heap allocated object
<var>object</var>.  <code>*</code><var>link</var> will be cleared when <var>object</var> is
found to be inaccessible.  This happens <strong>before</strong> any finalisation
code is invoked, and <code>before</code> any decisions about finalisation
order are made.

        <p>This is useful in telling the finaliser that some pointers are not
essential for proper finalisation.  This may avoid finalisation cycles.

        <p>Note that <var>object</var> may be resurrected by another finaliser, and thus
the clearing of <code>*</code><var>link</var> may be visible to non&ndash;finalisation
code.

        <p>There's an argument that an arbitrary action should be allowed here,
instead of just clearing a pointer.  But this causes problems if that
action alters, or examines connectivity.

        <p>Return <code>1</code> if link was already registered, <code>0</code> if registration
succeeded, <code>2</code> if it failed for lack of memory and <code>GC_oom_fn</code>
did not handle the problem.

        <p>Only exists for backward compatibility, see below. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>GC_general_register_disappearing_link</b> (<var>void ** link, void * object</var>)<var><a name="index-GC_005fgeneral_005fregister_005fdisappearing_005flink-89"></a></var><br>
<blockquote><p>A slight generalisation of <code>GC_register_disappearing_link()</code>. 
<code>*</code><var>link</var> is cleared when <var>object</var> first becomes
inaccessible.

        <p>This can be used to implement weak pointers easily and safely. 
Typically <var>link</var> will point to a location holding a disguised
pointer to <var>object</var>.  A pointer inside an &ldquo;atomic&rdquo; object is
effectively disguised.

        <p>In this way soft pointers are broken before any object reachable from
them is finalised.  Each link may be registered only once, i.e. with one
<var>object</var> value.

        <p><var>object</var> must be a pointer to the first word of an object we
allocated.  It is unsafe to explicitly deallocate the object containing
<var>link</var>.

        <p>Explicitly deallocating <var>object</var> may or may not cause link to
eventually be cleared.  This can be used to implement certain types of
weak pointers.  Note however that this generally requires that the
allocation lock is held (see <code>GC_call_with_alloc_lock()</code> below)
when the disguised pointer is accessed.  Otherwise a strong pointer
could be recreated between the time the collector decides to reclaim the
object and the <var>link</var> is cleared. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>GC_unregister_disappearing_link</b> (<var>void ** link</var>)<var><a name="index-GC_005funregister_005fdisappearing_005flink-90"></a></var><br>
<blockquote><p>Return <code>0</code> if link was not actually registered.  Undo a
registration by either of the above two routines. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>GC_should_invoke_finalizers</b> (<var>void</var>)<var><a name="index-GC_005fshould_005finvoke_005ffinalizers-91"></a></var><br>
<blockquote><p>Return non&ndash;zero if <code>GC_invoke_finalizers()</code> has something to
do. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>GC_invoke_finalizers</b> (<var>void</var>)<var><a name="index-GC_005finvoke_005ffinalizers-92"></a></var><br>
<blockquote><p>Run finalisers for all objects that are ready to be finalised.  Return
the number of finalisers that were run.  Normally this is also called
implicitly during some allocations.

        <p>If <code>GC_finalize_on_demand</code> is non&ndash;zero, it must be called
explicitly. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>GC_reachable_here</b> (<var>void * ptr</var>)<var><a name="index-GC_005freachable_005fhere-93"></a></var><br>
<blockquote><p>Explicitly tell the collector that an object is reachable at a
particular program point.  This prevents the <var>ptr</var> from being
optimised away, even it is otherwise no longer needed.

        <p>This macro should have no visible effect in the absence of finalisers or
disappearing links.  But it may be needed to prevent finalisers from
running while the associated external resource is still in use.  The
function is sometimes called <code>keep_alive</code> in other settings. 
</p></blockquote></div>

<div class="defun">
&mdash; Function Pointer: <b>GC_fn_type</b><var><a name="index-GC_005ffn_005ftype-94"></a></var><br>
<blockquote><p>Pointer to function with the following definition:

     <pre class="example">          typedef void * (*GC_fn_type) (void * client_data);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: void * <b>GC_call_with_alloc_lock</b> (<var>GC_fn_type fn, void * client_data</var>)<var><a name="index-GC_005fcall_005fwith_005falloc_005flock-95"></a></var><br>
<blockquote><p>Acquire the lock, apply <var>fn</var> to <var>client_data</var>, release the lock. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-operations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-threads">api threads</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-finalisation">api finalisation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.11 Miscellaneous operations</h3>

<h4 class="subsection">3.11.1 Enabling/disabling garbage collection</h4>

<div class="defun">
&mdash; Function: void <b>GC_disable</b> (<var>void</var>)<var><a name="index-GC_005fdisable-96"></a></var><br>
<blockquote><p>Disable garbage collection.  Even <code>GC_gcollect()</code> calls will be
ineffective. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_enable</b> (<var>void</var>)<var><a name="index-GC_005fenable-97"></a></var><br>
<blockquote><p>Re&ndash;enable garbage collection.  <code>GC_disable()</code> and
<code>GC_enable()</code> calls nest.  Garbage collection is enabled if the
number of calls to both functions is equal. 
</p></blockquote></div>

<h4 class="subsection">3.11.2 Explicit garbage collection</h4>

<div class="defun">
&mdash; Function: void <b>GC_gcollect</b> (<var>void</var>)<var><a name="index-GC_005fgcollect-98"></a></var><br>
<blockquote><p>Explicitly trigger a full, world&ndash;stop collection. 
</p></blockquote></div>

<div class="defun">
&mdash; Function Pointer: <b>GC_stop_func</b><var><a name="index-GC_005fstop_005ffunc-99"></a></var><br>
<blockquote><p>Function pointer with the following definition:

     <pre class="example">          typedef int (* GC_stop_func)(void);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: int <b>GC_try_to_collect</b> (<var>GC_stop_func stop_func</var>)<var><a name="index-GC_005ftry_005fto_005fcollect-100"></a></var><br>
<blockquote><p>Trigger a full world-stopped collection.  Abort the collection if and
when <var>stop_func</var> returns a non&ndash;zero value.  <var>stop_func</var> will be
called frequently, and should be reasonably fast.  Return <code>0</code> if
the collection was aborted, <code>1</code> if it succeeded.

        <p>This works even if virtual dirty bits, and hence incremental collection,
is not available for this architecture.  Collections can be aborted
faster than normal pause times for incremental collection.  However,
aborted collections do no useful work; the next collection needs to
start from the beginning. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>GC_collect_a_little</b> (<var>void</var>)<var><a name="index-GC_005fcollect_005fa_005flittle-101"></a></var><br>
<blockquote><p>Perform some garbage collection work, if appropriate.  Return <code>0</code>
if there is no more work to be done.  Typically performs an amount of
work corresponding roughly to marking from one page.  May do more work
if further progress requires it, e.g. if incremental collection is
disabled.  It is reasonable to call this in a wait loop until it returns
<code>0</code>. 
</p></blockquote></div>

<!--  -->
<h4 class="subsection">3.11.3 Heap size</h4>

<div class="defun">
&mdash; Function: size_t <b>GC_get_heap_size</b> (<var>void</var>)<var><a name="index-GC_005fget_005fheap_005fsize-102"></a></var><br>
<blockquote><p>Return the number of bytes in the heap.  Exclude collector private data
structures.  Include empty blocks and fragmentation loss.  Include some
pages that were allocated but never written. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>GC_expand_hp</b> (<var>size_t number_of_bytes</var>)<var><a name="index-GC_005fexpand_005fhp-103"></a></var><br>
<blockquote><p>Explicitly increase the heap size, return <code>0</code> on failure and
<code>1</code> on success.

        <p>This is normally done automatically if a garbage collection failed to
<code>GC_reclaim()</code> enough memory.  Explicit calls to
<code>GC_expand_hp()</code> may prevent unnecessarily frequent collections
at program start&ndash;up. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_set_max_heap_size</b> (<var>GC_word number_of_bytes</var>)<var><a name="index-GC_005fset_005fmax_005fheap_005fsize-104"></a></var><br>
<blockquote><p>Limit the heap size to <var>number_of_bytes</var>, it must be called before
initialising the library with <code>GC_INIT()</code>.

        <p>Useful when we are debugging, especially on systems that do not handle
running out of memory well.  Using zero as <var>number_of_bytes</var> will
make the heap unbounded; this is the default. 
</p></blockquote></div>

<!--  -->
<h4 class="subsection">3.11.4 Memory inspection</h4>

<div class="defun">
&mdash; Function: size_t <b>GC_get_free_bytes</b> (<var>void</var>)<var><a name="index-GC_005fget_005ffree_005fbytes-105"></a></var><br>
<blockquote><p>Return a lower bound on the number of free bytes in the heap. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: size_t <b>GC_get_bytes_since_gc</b> (<var>void</var>)<var><a name="index-GC_005fget_005fbytes_005fsince_005fgc-106"></a></var><br>
<blockquote><p>Return the number of bytes allocated since the last collection. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: size_t <b>GC_get_total_bytes</b> (<var>void</var>)<var><a name="index-GC_005fget_005ftotal_005fbytes-107"></a></var><br>
<blockquote><p>Return the total number of bytes allocated in this process.  Never
decreases, except due to wrapping. 
</p></blockquote></div>

<!--  -->
<h4 class="subsection">3.11.5 Interior pointers</h4>

<div class="defun">
&mdash; Function: void <b>GC_register_displacement</b> (<var>size_t n</var>)<var><a name="index-GC_005fregister_005fdisplacement-108"></a></var><br>
<blockquote><p>This is a no&ndash;op if the collector has recognition of arbitrary interior
pointers enabled, which is now the default.

        <p>Add a displacement to the set of those considered valid by the
collector.  <code>GC_register_displacement(</code><var>n</var><code>)</code> means that if
<code>p</code> was returned by <code>GC_malloc()</code>, then <code>(char *)p +
</code><var>n</var> will be considered to be a valid pointer to <code>p</code>.  <var>n</var>
must be small and less than the size of <code>p</code>.

        <p>All pointers to the interior of objects from the stack are considered
valid in any case, this function is useful if applied to heap objects
and static data.

        <p>Preferably, this should be called before any other garbage collection
procedures; calling it later adds to the probability of excess memory
retention. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_debug_register_displacement</b> (<var>size_t n</var>)<var><a name="index-GC_005fdebug_005fregister_005fdisplacement-109"></a></var><br>
<blockquote><p>To be used in place of <code>GC_register_displacement()</code> when
debugging allocation is being done. 
</p></blockquote></div>

<!--  -->
<h4 class="subsection">3.11.6 Incremental garbage collection</h4>

<div class="defun">
&mdash; Function: void <b>GC_enable_incremental</b> (<var>void</var>)<var><a name="index-GC_005fenable_005fincremental-110"></a></var><br>
<blockquote><p>Enable generational and incremental collection.  Useful for large heaps
on machines that provide access to page dirty information.  Some dirty
bit implementations may interfere with debugging (by catching address
faults) and place restrictions on heap arguments to system calls (since
write faults inside a system call may not be handled well).

        <p>Notices:

          <ul>
<li>not advisable unless dirty bits are available or most heap objects are
pointer&ndash;free (atomic) or immutable;

          <li>do not use it in leak finding mode;

          <li>it is ignored if <code>GC_dont_gc</code> is true;

          <li>only the generational piece of this is functional if <code>GC_parallel</code>
is true or if <code>GC_time_limit</code> is <code>GC_TIME_UNLIMITED</code>;

          <li>causes <code>GC_local_gcj_malloc()</code> to revert to locked allocation;

          <li>must be called before any <code>GC_local_gcj_malloc()</code> calls;

          <li>for best performance, should be called as early as possible; on some
platforms, calling it later may have adverse effects;

          <li>it is safe to call before <code>GC_INIT()</code>; it includes a
<code>GC_init()</code> call. 
</ul>
        </p></blockquote></div>

   <p><a name="index-GC_005fPROTECTS_005fNONE-111"></a>

<div class="defun">
&mdash; Function: int <b>GC_incremental_protection_needs</b> (<var>void</var>)<var><a name="index-GC_005fincremental_005fprotection_005fneeds-112"></a></var><br>
<blockquote><p>Does incremental mode write&ndash;protect pages?  Return
<code>GC_PROTECTS_NONE</code> (which is zero) or an OR&ndash;ed combination of the
following flags:

          <dl>
<dt><code>GC_PROTECTS_POINTER_HEAP</code><a name="index-GC_005fPROTECTS_005fPOINTER_005fHEAP-113"></a><dd>may protect non&ndash;atomic objects;

          <br><dt><code>GC_PROTECTS_PTRFREE_HEAP</code><a name="index-GC_005fPROTECTS_005fPTRFREE_005fHEAP-114"></a>
<br><dt><code>GC_PROTECTS_STATIC_DATA</code><a name="index-GC_005fPROTECTS_005fSTATIC_005fDATA-115"></a><dd>currently never;

          <br><dt><code>GC_PROTECTS_STACK</code><a name="index-GC_005fPROTECTS_005fSTACK-116"></a><dd>probably impractical. 
</dl>
        </p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Function: void * <b>GC_malloc_ignore_off_page</b> (<var>size_t number_of_bytes</var>)<var><a name="index-GC_005fmalloc_005fignore_005foff_005fpage-117"></a></var><br>
&mdash; Function: void * <b>GC_malloc_atomic_ignore_off_page</b> (<var>size_t number_of_bytes</var>)<var><a name="index-GC_005fmalloc_005fatomic_005fignore_005foff_005fpage-118"></a></var><br>
<blockquote><p>Like <code>GC_malloc()</code>, allocate an object of <var>number_of_bytes</var>. 
The client guarantees that as long as the object is alive, it will be
referenced by a pointer that points to somewhere within the first 256
bytes of the object.  This pointer should normally be declared
<code>volatile</code> to prevent the compiler from invalidating this
assertion.

        <p>This routine is only useful if a large array is being allocated.  It
reduces the chance of accidentally retaining such an array as a result
of scanning an integer that happens to be an address inside the array. 
(Actually, it reduces the chance of the allocator not finding space for
such an array, since it will try hard to avoid introducing such a false
reference.)

        <p>On a SunOS 4.X or MS Windows system this is recommended for arrays
likely to be larger than 100KB or so.  For other systems, or if the
collector is not configured to recognise all interior pointers, the
threshold is normally much higher. 
</p></blockquote></div>

<!--  -->
<h4 class="subsection">3.11.7 Other functions</h4>

<div class="defun">
&mdash; Function Pointer: <b>GC_warn_proc</b><var><a name="index-GC_005fwarn_005fproc-119"></a></var><br>
<blockquote><p>Function pointer with the following definition:

     <pre class="example">          typedef void (*GC_warn_proc) (char *msg, GC_word arg);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: GC_warn_proc <b>GC_set_warn_proc</b> (<var>GC_warn_proc p</var>)<var><a name="index-GC_005fset_005fwarn_005fproc-120"></a></var><br>
<blockquote><p>Can be used to redirect warnings from the collector.  Such warnings
should be rare, and should not be ignored during code development. 
Return the old warning procedure. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: GC_word <b>GC_set_free_space_divisor</b> (<var>GC_word value</var>)<var><a name="index-GC_005fset_005ffree_005fspace_005fdivisor-121"></a></var><br>
<blockquote><p>Set <code>GC_free_space_divisor</code> and return its old value. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>GC_register_has_static_roots_callback</b> (<var>int </var>(<var>*callback</var>)(<var>const char *, void *, size_t</var>))<var><a name="index-GC_005fregister_005fhas_005fstatic_005froots_005fcallback-122"></a></var><br>
<blockquote><p>Register a callback to control the scanning of dynamic libraries.  When
the <acronym>GC</acronym> scans the static data of a dynamic library, it will first call
a user&ndash;supplied routine with file name of the library and the address
and length of the memory region.  This routine should return non&ndash;zero
if that region should be scanned. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-threads"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-cplusplus">api cplusplus</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-operations">api operations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.12 Handling threads</h3>

<p class="noindent">The following routines are intended to explicitly notify the collector
of new threads.  Often this is unnecessary because thread creation is
implicitly intercepted by the collector, using header&ndash;file defines, or
linker&ndash;based interception.  In the long run the intent is to always
make redundant registration safe.  In the short run, this is being
implemented a platform at a time.  The interface is complicated by the
fact that <acronym>GC</acronym> probably will not ever be able to automatically
determine the stack base for thread stacks on all platforms.

<div class="defun">
&mdash; Structure: <b>GC_stack_base</b><var><a name="index-GC_005fstack_005fbase-123"></a></var><br>
<blockquote><p>Structure representing the base of a thread stack.  On most platforms
this contains just a single address.  Public fields:

          <dl>
<dt><code>void * mem_base</code><dd>base of memory stack;

          <br><dt><code>void * reg_base</code><dd>base of separate register stack, present only if <code>__ia64</code> or
<code>__ia64__</code> are defined. 
</dl>
        </p></blockquote></div>

<div class="defun">
&mdash; Function Pointer: <b>GC_stack_base_func</b><var><a name="index-GC_005fstack_005fbase_005ffunc-124"></a></var><br>
<blockquote><p>Pointer to function with the following definition:

     <pre class="example">          typedef void * (*GC_stack_base_func)(struct GC_stack_base *sb, void *arg);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: void * <b>GC_call_with_stack_base</b> (<var>GC_stack_base_func fn, void * arg</var>)<var><a name="index-GC_005fcall_005fwith_005fstack_005fbase-125"></a></var><br>
<blockquote><p>Call a function with a stack base structure corresponding to somewhere
in the <code>GC_call_with_stack_base()</code> frame.  This often can be
used to provide a sufficiently accurate stack base.  And we implement it
everywhere. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>GC_register_my_thread</b> (<var>struct GC_stack_base * base</var>)<var><a name="index-GC_005fregister_005fmy_005fthread-126"></a></var><br>
<blockquote><p>Register the current thread, with the indicated stack base, as a new
thread whose stack(s) should be traced by <acronym>GC</acronym>.  If a platform does not
implicitly do so, this must be called before a thread can allocate
garbage collected memory, or assign pointers to the garbage collected
heap.  Once registered, a thread will be stopped during garbage
collections.

        <p>Return codes:

          <dl>
<dt><code>GC_SUCCESS</code>
<br><dt><code>GC_DUPLICATE</code><dd>was already registered;

          <br><dt><code>GC_NO_THREADS</code><dd>no thread support in <acronym>GC</acronym>;

          <br><dt><code>GC_UNIMPLEMENTED</code><dd>not yet implemented on this platform. 
</dl>
        </p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>GC_unregister_my_thread</b> (<var>void</var>)<var><a name="index-GC_005funregister_005fmy_005fthread-127"></a></var><br>
<blockquote><p>Unregister the current thread.  The thread may no longer allocate
garbage collected memory or manipulate pointers to the garbage collected
heap after making this call.  Specifically, if it wants to return or
otherwise communicate a pointer to the garbage collected heap to another
thread, it must do this before calling
<code>GC_unregister_my_thread()</code>, most probably by saving it in a
global data structure. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>GC_get_stack_base</b> (<var>struct GC_stack_base * base</var>)<var><a name="index-GC_005fget_005fstack_005fbase-128"></a></var><br>
<blockquote><p>Attempt to fill in the <code>GC_stack_base</code> structure with the stack
base for this thread.  This appears to be required to implement anything
like the JNI <code>AttachCurrentThread()</code> in an environment in which
new threads are not automatically registered with the collector.  It is
also unfortunately hard to implement well on many platforms.  Returns
<code>GC_SUCCESS</code> or <code>GC_UNIMPLEMENTED</code>. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-cplusplus"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-leak">api leak</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-threads">api threads</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.13 The C++ interface to the allocator</h3>

<p class="noindent">The Ellis&ndash;Hull C++ interface to the collector is included in the
collector distribution.  If you intend to use this, type <code>make c++</code>
after the initial build of the collector is complete.  See
<samp><span class="file">gc_cpp.h</span></samp> for the definition of the interface.  This interface
tries to approximate the Ellis&ndash;Detlefs C++ garbage collection proposal
without compiler changes.

   <p>Very often it will also be necessary to use <samp><span class="file">gc_allocator.h</span></samp> and
the allocator declared there to construct <acronym>STL</acronym> data structures. 
Otherwise sub&ndash;objects of <acronym>STL</acronym> data structures will be allocated
using a system allocator, and objects they refer to may be prematurely
collected.

<!--  -->
<!-- page -->
<div class="node">
<a name="api-leak"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-collector">api collector</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-cplusplus">api cplusplus</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.14 Use as leak detector</h3>

<p class="noindent">The collector may be used to track down leaks in C programs that are
intended to run with <code>malloc()</code>/<code>free()</code> (e.g. code with extreme
real&ndash;time or portability constraints).

   <p>To do so define <code>FIND_LEAK</code> in <samp><span class="file">Makefile</span></samp>.  This will cause
the collector to invoke the <code>report_leak()</code> routine defined near
the top of <samp><span class="file">reclaim.c</span></samp> whenever an inaccessible object is found
that has not been explicitly freed.  Such objects will also be
automatically reclaimed.

   <p>If all objects are allocated with <code>GC_DEBUG_MALLOC()</code>, then the
default version of <code>report_leak()</code> will report at least the
source file and line number at which the leaked object was allocated. 
This may sometimes be sufficient.  On a few machines, it will also
report a cryptic stack trace.  If this is not symbolic, it can
sometimes be called into a symbolic stack trace by invoking program
<code>foo</code> with <code>callprocs foo</code>.  <samp><span class="command">callprocs</span></samp> is a short
shell script that invokes <code>adb</code> to expand program counter values to
symbolic addresses.  It was largely supplied by Scott Schwartz.

   <p>Note that the debugging facilities described in the next section can
sometimes be slightly <strong>less</strong> effective in leak finding mode,
since in leak finding mode, <code>GC_debug_free()</code> actually results
in reuse of the object.  (Otherwise the object is simply marked
invalid.)  Also note that the test program is not designed to run
meaningfully in <code>FIND_LEAK</code> mode.  Use <code>make gc.a</code> to build
the collector.

<!--  -->
<h4 class="subsection">3.14.1 Debugging facilities</h4>

<p class="noindent">The routines <code>GC_debug_malloc()</code>,
<code>GC_debug_malloc_atomic()</code>, <code>GC_debug_realloc()</code>, and
<code>GC_debug_free()</code> provide an alternate interface to the
collector, which provides some help with memory overwrite errors, and
the like.  Objects allocated in this way are annotated with additional
information.  Some of this information is checked during garbage
collections, and detected inconsistencies are reported to <code>stderr</code>.

   <p>Simple cases of writing past the end of an allocated object should be
caught if the object is explicitly deallocated, or if the collector is
invoked while the object is live.  The first deallocation of an object
will clear the debugging info associated with an object, so accidentally
repeated calls to <code>GC_debug_free()</code> will report the deallocation
of an object without debugging information.  Out of memory errors will
be reported to <code>stderr</code>, in addition to returning <acronym>NULL</acronym>.

   <p><code>GC_debug_malloc()</code> checking during garbage collection is
enabled with the first call to <code>GC_debug_malloc()</code>.  This will
result in some slowdown during collections.  If frequent heap checks are
desired, this can be achieved by explicitly invoking
<code>GC_gcollect()</code>, e.g. from the debugger.

   <p><code>GC_debug_malloc()</code> allocated objects should not be passed to
<code>GC_realloc()</code> or <code>GC_free()</code>, and conversely.  It is
however acceptable to allocate only some objects with
<code>GC_debug_malloc()</code>, and to use <code>GC_malloc()</code> for other
objects, provided the two pools are kept distinct.  In this case, there
is a very low probability that <code>GC_malloc()</code> allocated objects
may be misidentified as having been overwritten.  This should happen
with probability at most one in 2**32.  This probability is zero if
<code>GC_debug_malloc()</code> is never called.

   <p><code>GC_debug_malloc()</code>, <code>GC_malloc_atomic()</code>, and
<code>GC_debug_realloc()</code> take two additional trailing arguments, a
string and an integer.  These are not interpreted by the allocator. 
They are stored in the object (the string is not copied).  If an error
involving the object is detected, they are printed.

   <p>The macros <code>GC_MALLOC()</code>, <code>GC_MALLOC_ATOMIC()</code>,
<code>GC_REALLOC()</code>, <code>GC_FREE()</code>, and
<code>GC_REGISTER_FINALIZER()</code> are also provided.  These require the
same arguments as the corresponding (non debugging) routines.  If
<samp><span class="file">gc.h</span></samp> is included with <code>GC_DEBUG</code> defined, they call the
debugging versions of these functions, passing the current file name and
line number as the two extra arguments, where appropriate.  If
<samp><span class="file">gc.h</span></samp> is included without <code>GC_DEBUG</code> defined, then all these
macros will instead be defined to their non debugging equivalents.

   <p><code>GC_REGISTER_FINALIZER()</code> is necessary, since pointers to
objects with debugging information are really pointers to a displacement
of 16 bytes form the object beginning, and some translation is necessary
when finalisation routines are invoked.

   <p>For details, about what's stored in the header, see the definition of
the type in <samp><span class="file">debug_malloc.c</span></samp>.

<!--  -->
<!-- page -->
<div class="node">
<a name="api-collector"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-version">api version</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-leak">api leak</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.15 Incremental/generational collection</h3>

<p class="noindent">The collector normally interrupts client code for the duration of a
garbage collection mark phase.  This may be unacceptable if interactive
response is needed for programs with large heaps.  The collector can
also run in a &ldquo;generational&rdquo; mode, in which it usually attempts to
collect only objects allocated since the last garbage collection. 
Furthermore, in this mode, garbage collections run mostly incrementally,
with a small amount of work performed in response to each of a large
number of <code>GC_malloc()</code> requests.

   <p>This mode is enabled by a call to <code>GC_enable_incremental()</code>.

   <p>Incremental and generational collection is effective in reducing pause
times only if the collector has some way to tell which objects or pages
have been recently modified.  The collector uses two sources of
information:

     <ol type=1 start=1>
<li>Information provided by the VM system.  This may be provided in one of
several forms.  Under Solaris 2.X (and potentially under other similar
systems) information on dirty pages can be read from the /proc file
system.  Under other systems (currently SunOS4.X) it is possible to
write&ndash;protect the heap, and catch the resulting faults.  On these
systems we require that system calls writing to the heap (other than
read) be handled specially by client code.  See <samp><span class="file">os_dep.c</span></samp> for
details.

     <li>Information supplied by the programmer.  We define &ldquo;stubborn&rdquo; objects
to be objects that are rarely changed.  Such an object can be allocated
(and enabled for writing) with <code>GC_malloc_stubborn()</code>.  Once it
has been initialised, the collector should be informed with a call to
<code>GC_end_stubborn_change()</code>.  Subsequent writes that store
pointers into the object must be preceded by a call to
<code>GC_change_stubborn()</code>.
        </ol>

   <p>This mechanism performs best for objects that are written only for
initialisation, and such that only one stubborn object is writable at
once.  It is typically not worth using for short&ndash;lived objects. 
Stubborn objects are treated less efficiently than pointer&ndash;free (atomic)
objects.

   <p>A rough rule of thumb is that, in the absence of VM information, garbage
collection pauses are proportional to the amount of pointerful storage
plus the amount of modified &ldquo;stubborn&rdquo; storage that is reachable
during the collection.

   <p>Initial allocation of stubborn objects takes longer than allocation of
other objects, since other data structures need to be maintained.

   <p>We recommend against random use of stubborn objects in client code,
since bugs caused by inappropriate writes to stubborn objects are likely
to be very infrequently observed and hard to trace.  However, their use
may be appropriate in a few carefully written library routines that do
not make the objects themselves available for writing by client code.

<!--  -->
<!-- page -->
<div class="node">
<a name="api-version"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#api-misc">api misc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-collector">api collector</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.16 Library version informations</h3>

<div class="defun">
&mdash; Macro: <b>GC_VERSION_MAJOR</b><var><a name="index-GC_005fVERSION_005fMAJOR-129"></a></var><br>
&mdash; Macro: <b>GC_VERSION_MINOR</b><var><a name="index-GC_005fVERSION_005fMINOR-130"></a></var><br>
<blockquote><p>Integers representing the major and minor version numbers. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="api-misc"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api-version">api version</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#api">api</a>

</div>

<h3 class="section">3.17 Miscellaneous stuff</h3>

<h4 class="subsection">3.17.1 Hiding pointers</h4>

<p class="noindent">The following is intended to be used by a higher level (e.g. Java&ndash;like)
finalization facility.  It is expected that finalization code will
arrange for hidden pointers to disappear.  Otherwise objects can be
accessed after they have been collected.  Note that putting pointers in
atomic objects or in non&ndash;pointer slots of &ldquo;typed&rdquo; objects is
equivalent to disguising them in this way, and may have other
advantages.

<div class="defun">
&mdash; Macro: <b>GC_I_HIDE_POINTERS</b><var><a name="index-GC_005fI_005fHIDE_005fPOINTERS-131"></a></var><br>
<blockquote><p>If defined before the inclusion of <samp><span class="file">gc.h</span></samp>: the macros
<code>HIDE_POINTER()</code> and <code>REVEAL_POINTER()</code> are defined. 
</p></blockquote></div>

<div class="defun">
&mdash; C Macro: GC_word <b>HIDE_POINTER</b> (<var>void * p</var>)<var><a name="index-HIDE_005fPOINTER-132"></a></var><br>
&mdash; C Macro: void * <b>REVEAL_POINTER</b> (<var>GC_word p</var>)<var><a name="index-REVEAL_005fPOINTER-133"></a></var><br>
<blockquote><p>Apply the bitwise not to <var>p</var> and return the result.  The following
assertion is verified:

     <pre class="example">          void *  p = GC_malloc(4096);
          void *  q;
          GC_word w;
          
          w = HIDE_POINTER(p);
          q = REVEAL_POINTER(w);
          
          assert(q == p);
</pre>
        <p class="noindent">so these macros can be used to store a pointer somewhere without causing
a dependency in the objects hierarchy. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="bugs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#tutorial">tutorial</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#api">api</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Bugs</h2>

<p class="noindent">Any memory that does not have a recognisable pointer to it will be
reclaimed.  Exclusive&ndash;OR'ing forward and backward links in a list
doesn't cut it.

   <p>Some C optimisers may lose the last undisguised pointer to a memory
object as a consequence of clever optimisations.  This has almost never
been observed in practise.  Send mail to <a href="mailto:boehm@acm.org">boehm@acm.org</a> for
suggestions on how to fix your compiler.

   <p>This is not a real&ndash;time collector.  In the standard configuration,
percentage of time required for collection should be constant across
heap sizes.  But collection pauses will increase for larger heaps.  They
will decrease with the number of processors if parallel marking is
enabled.

   <p>On 2007 vintage machines, garbage collection times may be on the order
of 5 milliseconds per MB of accessible memory that needs to be scanned and
processor.  Your mileage may vary.  The incremental/generational
collection facility may help in some cases.

   <p>Please address bug reports to <a href="mailto:boehm@acm.org">boehm@acm.org</a>.  If you are
contemplating a major addition, you might also send mail to ask whether
it's already been done (or whether we tried and discarded it).

<!--  -->
<!-- page -->
<div class="node">
<a name="tutorial"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#cord">cord</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#bugs">bugs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix A Using the garbage collector: a simple example</h2>

<p class="noindent">The following consists of step&ndash;by&ndash;step instructions for building and
using the collector.  We'll assume a Linux/<acronym>GCC</acronym> platform and a
single&ndash;threaded application.  Some note about other platforms or
scenarios is included. It can be skipped, especially on first reading.

<!--  -->
<h3 class="appendixsec">A.1 Building the collector</h3>

<p class="noindent">If not already done, we unpack the collector and enter the newly created
directory with:

<pre class="example">     $ tar xvfz gc.tar.gz
     $ cd gc-7.1
</pre>
   <p>We can configure, build, and install the collector in a private
directory, say <samp><span class="file">/home/xyz/gc</span></samp>, with the following commands:

<pre class="example">     $ ./configure --prefix=/home/xyz/gc --disable-threads
     $ make
     $ make check
     $ make install
</pre>
   <p class="noindent">here the <code>make check</code> command is optional, but highly recommended:
it runs a basic correctness test which usually takes well under a
minute.

<!--  -->
<h4 class="appendixsubsec">A.1.1 Other platforms</h4>

<p class="noindent">On non&ndash;Unix, non&ndash;Linux platforms, the collector is usually built by
copying the appropriate makefile (see the platform&ndash;specific
<samp><span class="file">README</span></samp> in <samp><span class="file">doc/README.xxx</span></samp> in the distribution) to the file
<samp><span class="file">Makefile</span></samp> (overwriting the copy of <samp><span class="file">Makefile.direct</span></samp> that was
originally there), and then typing <samp><span class="command">make</span></samp> (or <samp><span class="command">nmake</span></samp> or
whatever we have).  This builds the library in the source tree.  We may
want to move it and the files in the include directory to a more
convenient place.

   <p>If we use a makefile that does not require running a <samp><span class="command">configure</span></samp>
script, we should first look at the makefile, and adjust any options
that are documented there.

   <p>If our platform provides a <samp><span class="command">make</span></samp> utility, that is generally
preferred to platform- and compiler- dependent &ldquo;project&rdquo; files. (At
least that is the strong preference of the would&ndash;be maintainer of those
project files.)

<!--  -->
<h4 class="appendixsubsec">A.1.2 Threads</h4>

<p class="noindent">If we need thread support, we configure the collector with:

<pre class="example">     --enable-threads=posix --enable-thread-local-alloc --enable-parallel-mark
</pre>
   <p class="noindent">instead of <samp><span class="option">--disable-threads</span></samp>.  If our target is a real
old&ndash;fashioned uniprocessor (no &ldquo;hyper&ndash;threading&rdquo;, etc.) we will want
to omit <samp><span class="option">--enable-parallel-mark</span></samp>.

<!--  -->
<h4 class="appendixsubsec">A.1.3 C++</h4>

<p class="noindent">We will need to include the C++ support, which unfortunately tends to be
among the least portable parts of the collector, since it seems to rely
on some corner cases of the language.  On Linux, it suffices to add
<samp><span class="option">--enable-cplusplus</span></samp> to the <samp><span class="command">configure</span></samp> options.

<!--  -->
<h3 class="appendixsec">A.2 Writing the program</h3>

<p class="noindent">We must include the header file:

<pre class="example">     #include "gc.h"
</pre>
   <p class="noindent">at the beginning of <strong>every</strong> file that allocates memory through
the garbage collector.  We call <code>GC_MALLOC()</code> wherever we would
have called <code>malloc()</code>.  This initialises memory to zero like
<code>calloc()</code>; there is no need to explicitly clear the result.

   <p>If we know that an allocated object will not contain pointers to the
garbage&ndash;collected heap, and we don't need it to be initialised, we can
use <code>GC_MALLOC_ATOMIC()</code> instead.

   <p>A free function, <code>GC_FREE()</code>, is provided but needs not be
called.  For very small objects, our program will probably perform
better if we do not call it, and let the collector do its job.

   <p>A <code>GC_REALLOC()</code> function behaves like the C library
<code>realloc()</code>.  It allocates uninitialised pointer&ndash;free memory if
the original object was allocated that way.

   <p>The following program <samp><span class="file">loop.c</span></samp> is a trivial example:

<pre class="example">     #include "gc.h"
     #include &lt;assert.h&gt;
     #include &lt;stdio.h&gt;
     
     int main ()
     {
       int i;
     
       GC_INIT();	/* Optional on Linux/X86; see below.  */
       for (i = 0; i &lt; 10000000; ++i)
        {
          int **p = (int **) GC_MALLOC(sizeof(int *));
          int *q = (int *) GC_MALLOC_ATOMIC(sizeof(int));
          assert(*p == 0);
          *p = (int *) GC_REALLOC(q, 2 * sizeof(int));
          if (i % 100000 == 0)
            printf("Heap size = %d\n", GC_get_heap_size());
        }
       return 0;
     }
</pre>
   <!--  -->
<h4 class="appendixsubsec">A.2.1 Interaction with the system <code>malloc()</code></h4>

<p class="noindent">It is usually best not to mix garbage&ndash;collected allocation with the
standard C allocation routines.  If we do, we need to be careful not to
store pointers to the garbage&ndash;collected heap in memory allocated with
the system <code>malloc()</code>.

<!--  -->
<h4 class="appendixsubsec">A.2.2 Other Platforms</h4>

<p class="noindent">On some other platforms it is necessary to call <code>GC_INIT()</code> from
the main program, which is presumed to be part of the main executable,
not a dynamic library.  This can never hurt, and is thus generally good
practise.

<!--  -->
<h4 class="appendixsubsec">A.2.3 Threads</h4>

<p class="noindent">For a multithreaded program some more rules apply:

     <ol type=1 start=1>
<li>files that either allocate through <acronym>GC</acronym> or make thread&ndash;related calls
should first define the macro <code>GC_THREADS</code>, and then include
<samp><span class="file">gc.h</span></samp>; on some platforms this will redefine some threads
primitives, e.g. to let the collector keep track of thread creation;

     <li>to take advantage of fast thread&ndash;local allocation in <acronym>GC</acronym> versions
before 7.0, use the following instead of including <samp><span class="file">gc.h</span></samp>:

     <pre class="example">          #define GC_REDIRECT_TO_LOCAL
          #include "gc_local_alloc.h"
</pre>
     <p class="noindent">this will cause <code>GC_MALLOC</code> and <code>GC_MALLOC_ATOMIC</code> to keep
per&ndash;thread allocation caches, and greatly reduce the number of lock
acquisitions during allocation.  For versions after 7.0, this happens
implicitly if the collector is built with thread&ndash;local allocation
enabled.
        </ol>

<!--  -->
<h3 class="appendixsec">A.3 C++</h3>

<p class="noindent">In the case of C++, we need to be especially careful not to store
pointers to the garbage&ndash;collected heap in areas that are not traced by
the collector.  The collector includes some alternate interfaces to make
that easier.

<!--  -->
<h3 class="appendixsec">A.4 Debugging</h3>

<p class="noindent">Additional debug checks can be performed by defining <code>GC_DEBUG</code>
before including <samp><span class="file">gc.h</span></samp>.  Additional options are available if the
collector is also built with <samp><span class="option">--enable-gc-debug</span></samp> and all
allocations are performed with <code>GC_DEBUG</code> defined.

<!--  -->
<h3 class="appendixsec">A.5 What if we can't rewrite/recompile my program?</h3>

<p class="noindent">We may be able to build the collector with
<samp><span class="option">--enable-redirect-malloc</span></samp> and set the <samp><span class="env">LD_PRELOAD</span></samp>
environment variable to point to the resulting library, thus replacing
the standard <code>malloc()</code> with its garbage&ndash;collected counterpart. 
This is rather platform dependent.  See the leak detection documentation
for some more details.

<!--  -->
<h3 class="appendixsec">A.6 Compiling and linking</h3>

<p class="noindent">The above application <samp><span class="file">loop.c</span></samp> test program can be compiled and
linked with:

<pre class="example">     cc -I/home/xyz/gc/include loop.c /home/xyz/gc/lib/libgc.a -o loop
</pre>
   <p>The <code>-I</code> option directs the compiler to the right include
directory.  In this case, we list the static library directly on the
compile line; the dynamic library could have been used instead, provided
we arranged for the dynamic loader to find it, e.g. by setting the
<samp><span class="env">LD_LIBRARY_PATH</span></samp> environment variable.

<!--  -->
<h3 class="appendixsec">A.7 Threads</h3>

<p class="noindent">On Pthreads platforms, we will of course also have to link with
<code>-lpthread</code>, and compile with any thread&ndash;safety options required
by the compiler.  On some platforms, we may also need to link with
<code>-ldl</code> or <code>-lrt</code>.  Looking at <samp><span class="file">threadlibs.c</span></samp> in the <acronym>GC</acronym>
build directory should give us the appropriate list if a plain
<code>-lpthread</code> doesn't work.

<!--  -->
<h3 class="appendixsec">A.8 Running the executable</h3>

<p class="noindent">The executable can of course be run normally, e.g. by typing:

<pre class="example">     $ ./loop
</pre>
   <p>The operation of the collector is affected by a number of environment
variables.  For example, setting <samp><span class="env">GC_PRINT_STATS</span></samp> produces some
garbage collection statistics on <code>stdout</code>.  See
<samp><span class="file">README.environment</span></samp> in the distribution for details.

<!--  -->
<!-- page -->
<div class="node">
<a name="cord"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Package-License">Package License</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#tutorial">tutorial</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix B The cord string interface</h2>

<p><a name="index-Cords-134"></a>

<ul class="menu">
<li><a accesskey="1" href="#cord-intro">cord intro</a>:                   Introduction. 
<li><a accesskey="2" href="#cord-typedefs">cord typedefs</a>:                Type definitions. 
<li><a accesskey="3" href="#cord-inspect">cord inspect</a>:                 Inspection. 
<li><a accesskey="4" href="#cord-funcs">cord funcs</a>:                   Cord functions. 
<li><a accesskey="5" href="#cord-compar">cord compar</a>:                  Comparison. 
<li><a accesskey="6" href="#cord-ops">cord ops</a>:                     Operations. 
<li><a accesskey="7" href="#cord-traverse">cord traverse</a>:                Traversing. 
<li><a accesskey="8" href="#cord-file">cord file</a>:                    File operations. 
<li><a accesskey="9" href="#cord-format">cord format</a>:                  Format functions. 
<li><a href="#cord-extensible">cord extensible</a>:              Extensible cords. 
</ul>

<p class="noindent">To use the cord <acronym>API</acronym> we have to include the <samp><span class="file">cord.h</span></samp> header file;
to use the extensible cord <acronym>API</acronym> we have to include the <samp><span class="file">ec.h</span></samp>
header file. <a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a>

   <p>The cord interface is installed in its own library, whose identifier for
linking is <code>cord</code>.

<!--  -->
<!-- page -->
<div class="node">
<a name="cord-intro"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#cord-typedefs">cord typedefs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#cord">cord</a>

</div>

<h3 class="appendixsec">B.1 Introduction</h3>

<p class="noindent">Cords are immutable character strings.  A number of operations on long
cords are much more efficient than their <samp><span class="file">strings.h</span></samp> counterpart. 
In particular, concatenation takes constant time independent of the
length of the arguments.  Cords are represented as trees, with internal
nodes representing concatenation and leaves consisting of either C
strings or a functional description of the string.

   <p>The following are reasonable applications of cords; they would perform
unacceptably if C strings were used:

     <ul>
<li>a compiler that produces assembly language output by repeatedly
concatenating instructions onto a cord representing the output file;

     <li>a text editor that converts the input file to a cord, and then performs
editing operations by producing a new cord representing the file after
each character change (and keeping the old ones in an edit history). 
</ul>

   <p>For optimal performance, cords should be built by concatenating short
sections.

   <p>This interface is designed for maximum compatibility with C strings. 
<acronym>ASCII</acronym> null characters may be embedded in cords using
<code>CORD_from_fn()</code>.  This is handled correctly, but
<code>CORD_to_char_star()</code> will produce a string with embedded nulls
when given such a cord.

   <p>This interface is fairly big, largely for performance reasons.

<!--  -->
<!-- page -->
<div class="node">
<a name="cord-typedefs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#cord-inspect">cord inspect</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#cord-intro">cord intro</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#cord">cord</a>

</div>

<h3 class="appendixsec">B.2 Type definitions</h3>

<p><a name="index-Cord-type-definitions-135"></a>

<div class="defun">
&mdash; Pointer Alias: <b>CORD</b><var><a name="index-CORD-136"></a></var><br>
<blockquote><p>Cords have type <code>const char *</code>.  This is cheating quite a bit, and
not 100% portable.  But it means that non empty character string
constants may be used as cords directly, provided the string is never
modified in place.

        <p>The empty cord is represented by, and can be written as, <code>0</code>.  In
the following documentation: when we refer to a cord as a &ldquo;C string&rdquo;,
we mean that the value of <code>CORD</code> type is non <acronym>NULL</acronym>; this does not
mean that the string is empty because its first char can be zero.

        <p>Never, ever, access directly a cord as a pointer to <code>char</code>; this is
because the cord <acronym>API</acronym> supports strings generated by functions, in
which case the format of the memory block is not known.  <a href="#cord-funcs">cord funcs</a> for details. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CORD_EMPTY</b><var><a name="index-CORD_005fEMPTY-137"></a></var><br>
<blockquote><p>An empty cord is always represented as <acronym>NULL</acronym>.  This preprocessor
symbol is an alias for <acronym>NULL</acronym>. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="cord-inspect"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#cord-funcs">cord funcs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#cord-typedefs">cord typedefs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#cord">cord</a>

</div>

<h3 class="appendixsec">B.3 Inspection</h3>

<p><a name="index-Cord-inspection-138"></a>

<div class="defun">
&mdash; Macro: <b>CORD_IS_STRING</b> (<var>s</var>)<var><a name="index-CORD_005fIS_005fSTRING-139"></a></var><br>
<blockquote><p>Evaluate to true if the cord <var>s</var> has non zero as first character. 
<var>s</var> must be different from <acronym>NULL</acronym>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: size_t <b>CORD_len</b> (<var>CORD x</var>)<var><a name="index-CORD_005flen-140"></a></var><br>
<blockquote><p>Compute the length of a cord. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="cord-funcs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#cord-compar">cord compar</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#cord-inspect">cord inspect</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#cord">cord</a>

</div>

<h3 class="appendixsec">B.4 Cord functions</h3>

<p><a name="index-Cord-functions-141"></a>

<p class="noindent">Cords can be represented by a pair function/client data, to be invoked
to generate the characters one by one.

<div class="defun">
&mdash; Function Pointer Typedef: char <b>CORD_fn</b> (<var>size_t i, void * client_data</var>)<var><a name="index-CORD_005ffn-142"></a></var><br>
<blockquote><p>Prototype of functions used to generate the characters.  Whenever a
generation function function is invoked: it must return the <var>i</var>-th
character in the string.  <var>client_data</var> is the same value used as
parameter for <code>CORD_from_fn()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: CORD <b>CORD_from_fn</b> (<var>CORD_fn fn, void * client_data, size_t len</var>)<var><a name="index-CORD_005ffrom_005ffn-143"></a></var><br>
<blockquote><p>Turn a functional description into a cord.

        <p>If the length of the cord, <var>len</var>, is &ldquo;short&rdquo;: the characters are
immediately generated by <code>CORD_from_fn()</code> itself; else both
<var>fn</var> and <var>client_data</var> are stored in the returned cord.  The
length of a &ldquo;short cord&rdquo; is <strong>not</strong> part of the public <acronym>API</acronym>.

        <p>This implies that <var>client_data</var> must be statically allocated or
allocated using the garbage collection functions: there is no way to
explicitly free the referenced memory block once its pointer is stored
in a cord. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="cord-compar"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#cord-ops">cord ops</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#cord-funcs">cord funcs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#cord">cord</a>

</div>

<h3 class="appendixsec">B.5 Comparison</h3>

<div class="defun">
&mdash; Function: int <b>CORD_cmp</b> (<var>CORD x, CORD y</var>)<var><a name="index-CORD_005fcmp-144"></a></var><br>
<blockquote><p>Return &lt; 0, 0, or &gt; 0, depending on whether <var>x</var> &lt; <var>y</var>, <var>x</var> =
<var>y</var>, <var>x</var> &gt; <var>y</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>CORD_ncmp</b> (<var>CORD x, size_t x_start, CORD y, size_t y_start, size_t len</var>)<var><a name="index-CORD_005fncmp-145"></a></var><br>
<blockquote><p>A generalization that takes both starting positions for the comparison,
and a limit on the number of characters to be compared. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="cord-ops"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#cord-traverse">cord traverse</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#cord-compar">cord compar</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#cord">cord</a>

</div>

<h3 class="appendixsec">B.6 Operations</h3>

<p><a name="index-Cord-operations-146"></a>

<div class="defun">
&mdash; Function: CORD <b>CORD_cat</b> (<var>CORD x, CORD y</var>)<var><a name="index-CORD_005fcat-147"></a></var><br>
<blockquote><p>Concatenate two cords.  If the arguments are C strings, they may not be
subsequently altered. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: CORD <b>CORD_cat_char_star</b> (<var>CORD x, const char * y, size_t leny</var>)<var><a name="index-CORD_005fcat_005fchar_005fstar-148"></a></var><br>
<blockquote><p>Concatenate a cord and a C string with known length and return the
result.  Except for the empty string case, this is a special case of
<code>CORD_cat()</code>.  Since the length is known, it can be faster.  The
string <var>y</var> is shared with the resulting <code>CORD</code>.  Hence it
should not be altered by the caller. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: CORD <b>CORD_substr</b> (<var>CORD x, size_t i, size_t n</var>)<var><a name="index-CORD_005fsubstr-149"></a></var><br>
<blockquote><p>Return the substring (subcord really) of <var>x</var> with length at most
<var>n</var>, starting at position <var>i</var>.  The initial character has
position <code>0</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: CORD <b>CORD_balance</b> (<var>CORD x</var>)<var><a name="index-CORD_005fbalance-150"></a></var><br>
<blockquote><p>Return the argument cord itself, but rebalanced to allow more efficient
character retrieval, substring operations, and comparisons.  This
function may reallocate significant parts of the cord.  The argument is
not modified; only the result is balanced.  This is useful only for
cords that were built using repeated concatenation.

        <p>Rebalancing guarantees log time access to the result, unless <var>x</var> was
obtained through a large number of repeated substring operations or the
embedded functional descriptions take longer to evaluate. 
</p></blockquote></div>

<div class="defun">
&mdash; Variable: Function Pointer <b>CORD_oom_fn</b><var><a name="index-CORD_005foom_005ffn-151"></a></var><br>
<blockquote><p>An out of memory handler to call, it can be supplied by client and it
must not return.  The default handler calls <code>abort()</code>.  The
variable definition is:

     <pre class="example">          void (* CORD_oom_fn)(void);
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: void <b>CORD_dump</b> (<var>CORD x</var>)<var><a name="index-CORD_005fdump-152"></a></var><br>
<blockquote><p>Dump the representation of <var>x</var> to stdout in an implementation
defined manner.  Intended for debugging only. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: CORD <b>CORD_cat_char</b> (<var>CORD x, char c</var>)<var><a name="index-CORD_005fcat_005fchar-153"></a></var><br>
<blockquote><p>Concatenate a character to the end of a cord. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: CORD <b>CORD_catn</b> (<var>int n, ...</var>)<var><a name="index-CORD_005fcatn-154"></a></var><br>
<blockquote><p>Concatenate <var>n</var> cords.  The variable arguments must be cords. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: char <b>CORD_fetch</b> (<var>CORD x, size_t i</var>)<var><a name="index-CORD_005ffetch-155"></a></var><br>
<blockquote><p>Return the character in <code>CORD_substr(</code><var>x</var><code>, </code><var>i</var><code>, 1)</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CORD_NOT_FOUND</b><var><a name="index-CORD_005fNOT_005fFOUND-156"></a></var><br>
<blockquote><p>Defined as <code>((size_t)(-1))</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: size_t <b>CORD_str</b> (<var>CORD x, size_t start, CORD s</var>)<var><a name="index-CORD_005fstr-157"></a></var><br>
<blockquote><p>Find the first occurrence of <var>s</var> in <var>x</var> beginning at position
<var>start</var>; return the position of the first character of <var>s</var> in
<var>x</var>, or <code>CORD_NOT_FOUND</code> if there is none. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: CORD <b>CORD_chars</b> (<var>char c, size_t i</var>)<var><a name="index-CORD_005fchars-158"></a></var><br>
<blockquote><p>Return a cord consisting of <var>i</var> copies of (possibly zero) <var>c</var>. 
Dangerous in conjunction with <code>CORD_to_char_star()</code>.  The
resulting representation takes constant space, independent of <var>i</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CORD_nul</b> (<var>i</var>)<var><a name="index-CORD_005fnul-159"></a></var><br>
<blockquote><p>A wrapper for <code>CORD_chars()</code> that creates a cord of null
characters. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: char * <b>CORD_to_char_star</b> (<var>CORD x</var>)<var><a name="index-CORD_005fto_005fchar_005fstar-160"></a></var><br>
<blockquote><p>Turn a cord into a C string. The result shares no structure with
<var>x</var>, and is thus modifiable. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: const char * <b>CORD_to_const_char_star</b> (<var>CORD x</var>)<var><a name="index-CORD_005fto_005fconst_005fchar_005fstar-161"></a></var><br>
<blockquote><p>Like <code>CORD_to_char_star()</code>, but the result may share structure
with the argument and is thus not modifiable. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: CORD <b>CORD_from_char_star</b> (<var>const char * s</var>)<var><a name="index-CORD_005ffrom_005fchar_005fstar-162"></a></var><br>
<blockquote><p>Turn a C string into a cord.  The C string is copied, and so may
subsequently be modified. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: size_t <b>CORD_chr</b> (<var>CORD x, size_t i, int c</var>)<var><a name="index-CORD_005fchr-163"></a></var><br>
<blockquote><p>A vague analog of <code>strchr()</code>.  Return the position (an integer,
not a pointer) of the first occurrence of (<code>char</code>) <var>c</var> inside
<var>x</var> at position <var>i</var> or subsequent.  The value <var>i</var> must be
strictly less than the length of the cord.  If <var>c</var> is not found:
return <code>CORD_NOT_FOUND</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: size_t <b>CORD_rchr</b> (<var>CORD x, size_t i, int c</var>)<var><a name="index-CORD_005frchr-164"></a></var><br>
<blockquote><p>A vague analog of <code>strrchr()</code>.  Return the index of the last
occurrence of (<code>char</code>) <var>c</var> inside <var>x</var> at position <var>i</var>
or previous.  The value <var>i</var> must be strictly less than the length of
the cord.  If <var>c</var> is not found: return <code>CORD_NOT_FOUND</code>. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="cord-traverse"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#cord-file">cord file</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#cord-ops">cord ops</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#cord">cord</a>

</div>

<h3 class="appendixsec">B.7 Traversing</h3>

<p><a name="index-Cord-traversing-165"></a>

<p class="noindent">The following traverse a cord by applying a function to each character. 
This is occasionally appropriate, especially where speed is crucial. 
But, since standard C does not have nested functions, clients of this
sort of traversal are clumsy to write.  Consider the functions that
operate on cord positions instead.

<div class="defun">
&mdash; Function Pointer Typedef: int <b>CORD_iter_fn</b> (<var>char c, void * client_data</var>)<var><a name="index-CORD_005fiter_005ffn-166"></a></var><br>
<blockquote><p>Function to iteratively apply to individual characters in cord. 
</p></blockquote></div>

<div class="defun">
&mdash; Function Pointer Typedef: int <b>CORD_batched_iter_fn</b> (<var>const char * s, void * client_data</var>)<var><a name="index-CORD_005fbatched_005fiter_005ffn-167"></a></var><br>
<blockquote><p>Function to apply to substrings of a cord.  Each substring is a C
character string, not a general cord. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CORD_NO_FN</b><var><a name="index-CORD_005fNO_005fFN-168"></a></var><br>
<blockquote><p>A <acronym>NULL</acronym> pointer of type <code>CORD_batched_iter_fn</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>CORD_iter5</b> (<var>CORD x, size_t i, CORD_iter_fn f1, CORD_batched_iter_fn f2, void * client_data</var>)<var><a name="index-CORD_005fiter5-169"></a></var><br>
<blockquote><p>Apply <var>f1</var> to each character in the cord <var>x</var>, in ascending
order, starting at position <var>i</var>.  If <var>f2</var> is not
<code>CORD_NO_FN</code>, then multiple calls to <var>f1</var> may be replaced by a
single call to <var>f2</var>.  The parameter <var>f2</var> is provided only to
allow some optimization by the client.

        <p>The iteration terminates when the right end of this string is reached,
or when <var>f1</var> or <var>f2</var> return non&ndash;zero.  In the latter case
<code>CORD_iter5()</code> returns non&ndash;zero; otherwise it returns zero.

        <p>The specified value of <var>i</var> must be less than the length of the cord. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>CORD_iter</b> (<var>CORD x, CORD_iter_fn f1, void * client_data</var>)<var><a name="index-CORD_005fiter-170"></a></var><br>
<blockquote><p>A simpler version that starts at zero, and without <var>f2</var>.  In truth,
this is a preprocessor macro that expands to:

     <pre class="example">          CORD_iter5(<var>x</var>, 0, <var>f1</var>, CORD_NO_FN, <var>client_data</var>)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: int <b>CORD_riter4</b> (<var>CORD x, size_t i, CORD_iter_fn f1, void * client_data</var>)<var><a name="index-CORD_005friter4-171"></a></var><br>
<blockquote><p>Similar to <code>CORD_iter5()</code>, but end&ndash;to&ndash;beginning. No provisions
for <code>CORD_batched_iter_fn</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>CORD_riter</b> (<var>CORD x, CORD_iter_fn f1, void * client_data</var>)<var><a name="index-CORD_005friter-172"></a></var><br>
<blockquote><p>A simpler version of <code>CORD_riter4()</code> that starts at the end. 
</p></blockquote></div>

<!--  -->
   <p>The following functions operate on cord positions.  The easy way to
traverse cords.  A cord position is logically a pair consisting of a
cord and an index into that cord.  But it is much faster to retrieve a
character based on a position than on an index.  Unfortunately,
positions are big (order of a few 100 bytes), so allocate them with
caution.

   <p>Note that <code>CORD_pos_fetch()</code>, <code>CORD_next()</code> and
<code>CORD_prev()</code> have both macro and function definitions; the
former may evaluate their argument more than once.

<div class="defun">
&mdash; Single&ndash;Element Array Typedef: <b>CORD_pos</b><var><a name="index-CORD_005fpos-173"></a></var><br>
<blockquote><p>The type of the position structure.  Being an array of one element it
can be allocated on the stack like this:

     <pre class="example">          CORD_pos        pos;
</pre>
        <p class="noindent">and then <code>pos</code> can be used as a pointer to the structure. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: CORD <b>CORD_pos_to_cord</b> (<var>CORD_pos p</var>)<var><a name="index-CORD_005fpos_005fto_005fcord-174"></a></var><br>
<blockquote><p>Extract the cord from a position. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: size_t <b>CORD_pos_to_index</b> (<var>CORD_pos p</var>)<var><a name="index-CORD_005fpos_005fto_005findex-175"></a></var><br>
<blockquote><p>Extract the current index from a position. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: char <b>CORD_pos_fetch</b> (<var>CORD_pos p</var>)<var><a name="index-CORD_005fpos_005ffetch-176"></a></var><br>
<blockquote><p>Fetch the character located at the given position. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>CORD_set_pos</b> (<var>CORD_pos p, CORD x, size_t i</var>)<var><a name="index-CORD_005fset_005fpos-177"></a></var><br>
<blockquote><p>Initialize the position to refer to the given cord and index.  Note that
this is the most expensive function on positions. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>CORD_next</b> (<var>CORD_pos p</var>)<var><a name="index-CORD_005fnext-178"></a></var><br>
<blockquote><p>Advance the position to the next character; <var>p</var> must be initialized
and valid.  This function invalidates <var>p</var> if it goes past the end of
the cord, so it must be used in conjuction with <code>CORD_pos_valid()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>CORD_prev</b> (<var>CORD_pos p</var>)<var><a name="index-CORD_005fprev-179"></a></var><br>
<blockquote><p>Move the position to the preceding character; <var>p</var> must be
initialized and valid.  This function invalidates <var>p</var> if it goes
before the beginning of the cord, so it must be used in conjuction with
<code>CORD_pos_valid()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>CORD_pos_valid</b> (<var>CORD_pos p</var>)<var><a name="index-CORD_005fpos_005fvalid-180"></a></var><br>
<blockquote><p>Return true if the position is valid, i.e. inside the cord. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CORD_FOR</b> (<var>pos, cord</var>)<var><a name="index-CORD_005fFOR-181"></a></var><br>
<blockquote><p>Expand to a <code>for</code> loop:

     <pre class="example">          for (CORD_set_pos(<var>pos</var>, <var>cord</var>, 0);
               CORD_pos_valid(<var>pos</var>);
               CORD_next(<var>pos</var>))
</pre>
        </blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="cord-file"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#cord-format">cord format</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#cord-traverse">cord traverse</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#cord">cord</a>

</div>

<h3 class="appendixsec">B.8 File operations</h3>

<p><a name="index-Cord_002c-file-operations-182"></a>

<div class="defun">
&mdash; Function: CORD <b>CORD_from_file</b> (<var>FILE * f</var>)<var><a name="index-CORD_005ffrom_005ffile-183"></a></var><br>
<blockquote><p>Turn a file into cord.  The file must be seekable.  Its contents must
remain constant.  The file may be accessed as an immediate result of
this call and/or as a result of subsequent accesses to the cord.  Short
files are likely to be immediately read, but long files are likely to be
read on demand, possibly relying on <code>stdio</code> for buffering.

        <p>We must have exclusive access to the descriptor <var>f</var>, i.e. we may
read it at any time, and expect the file pointer to be where we left it. 
Normally this should be invoked as <code>CORD_from_file(fopen(...))</code>.

        <p><code>CORD_from_file()</code> arranges to close the file descriptor when it
is no longer needed (e.g. when the result becomes inaccessible).

        <p>The file <var>f</var> must be such that <code>ftell()</code> reflects the actual
character position in the file, i.e. the number of characters that can
be or were read with <code>fread()</code>.  On Unix systems this is always
true; on MS Windows systems, <var>f</var> must be opened in binary mode. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: CORD <b>CORD_from_file_eager</b> (<var>FILE * f</var>)<var><a name="index-CORD_005ffrom_005ffile_005feager-184"></a></var><br>
<blockquote><p>Equivalent to <code>CORD_from_file()</code>, except that the entire file
will be read and the file pointer will be closed immediately.  The
binary mode restriction from above does not apply. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: CORD <b>CORD_from_file_lazy</b> (<var>FILE * f</var>)<var><a name="index-CORD_005ffrom_005ffile_005flazy-185"></a></var><br>
<blockquote><p>Equivalent to the above, except that the file will be read on demand. 
The binary mode restriction applies. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>CORD_put</b> (<var>CORD x, FILE * f</var>)<var><a name="index-CORD_005fput-186"></a></var><br>
<blockquote><p>Write a cord to a file, starting at the current position.  No trailing
NULs and newlines are added.  Returns <code>EOF</code> if a write error
occurs, <code>1</code> otherwise. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="cord-format"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#cord-extensible">cord extensible</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#cord-file">cord file</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#cord">cord</a>

</div>

<h3 class="appendixsec">B.9 Format functions</h3>

<p><a name="index-Cords_002c-format-functions-187"></a>

<div class="defun">
&mdash; Function: int <b>CORD_sprintf</b> (<var>CORD * out, CORD format, ...</var>)<var><a name="index-CORD_005fsprintf-188"></a></var><br>
&mdash; Function: int <b>CORD_vsprintf</b> (<var>CORD * out, CORD format, va_list args</var>)<var><a name="index-CORD_005fvsprintf-189"></a></var><br>
&mdash; Function: int <b>CORD_fprintf</b> (<var>FILE * f, CORD format, ...</var>)<var><a name="index-CORD_005ffprintf-190"></a></var><br>
&mdash; Function: int <b>CORD_vfprintf</b> (<var>FILE * f, CORD format, va_list args</var>)<var><a name="index-CORD_005fvfprintf-191"></a></var><br>
&mdash; Function: int <b>CORD_printf</b> (<var>CORD format, ...</var>)<var><a name="index-CORD_005fprintf-192"></a></var><br>
&mdash; Function: int <b>CORD_vprintf</b> (<var>CORD format, va_list args</var>)<var><a name="index-CORD_005fvprintf-193"></a></var><br>
<blockquote><p>These functions provide functionality similar to the <acronym>ANSI</acronym> C functions
with corresponding names, but with the following additions and changes:

          <ol type=1 start=1>
<li>a <code>%r</code> conversion specification specifies a <code>CORD</code> argument;
field width, precision, etc. have the same semantics as for <code>%s</code>
(note that <code>%c</code>, <code>%C</code>, and <code>%S</code> were already taken);

          <li>the format string is represented as a <code>CORD</code>;

          <li><code>CORD_sprintf()</code> and <code>CORD_vsprintf()</code> assign the result
through the 1st argument; unlike their <acronym>ANSI</acronym> C versions, there is no
need to guess the correct buffer size;

          <li>most of the conversions are implement through the native
<code>vsprintf()</code>; hence they are usually no faster, and
idiosyncracies of the native <code>printf()</code> are preserved; however,
<code>CORD</code> arguments to <code>CORD_sprintf()</code> and
<code>CORD_vsprintf()</code> are <strong>not</strong> copied; the result shares the
original structure; this may make them very efficient in some unusual
applications; the format string is copied.
             </ol>

        <p>All the functions return the number of characters generated or <code>-1</code>
on error; this complies with the <acronym>ANSI</acronym> standard, but is inconsistent
with some older implementations of <code>sprintf()</code>.

        <p>The implementation of these is probably less portable than the rest of
this package.  These section of the <acronym>API</acronym> can be excluded by defining
the <code>CORD_NO_IO</code> symbol. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="cord-extensible"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#cord-format">cord format</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#cord">cord</a>

</div>

<h3 class="appendixsec">B.10 Extensible cords</h3>

<p><a name="index-Cord_002c-extensible-194"></a>

<p class="noindent">Extensible cords are strings that may be destructively appended to; they
allow fast construction of cords from characters that are being read
from a stream.

   <p>A client might look like:

<pre class="example">     {
       CORD_ec       x;
       CORD          result;
       char          c;
       FILE *        f;
     
       CORD_ec_init(x);
       while(...)
         {
           c = getc(f);
           ...
           CORD_ec_append(x, c);
         }
       result = CORD_balance(CORD_ec_to_cord(x));
     }
</pre>
   <p class="noindent">if a C string is desired as the final result, the call to
<code>CORD_balance()</code> may be replaced by a call to
<code>CORD_to_char_star()</code>.

<div class="defun">
&mdash; Struct Typedef: <b>CORD_ec_struct</b><var><a name="index-CORD_005fec_005fstruct-195"></a></var><br>
&mdash; Single&ndash;Element Array Typedef: <b>CORD_ec</b><var><a name="index-CORD_005fec-196"></a></var><br>
<blockquote><p>The type of extensible cords.  It is composed by a buffer and a
<code>CORD</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CORD_ec_init</b> (<var>CORD_ec x</var>)<var><a name="index-CORD_005fec_005finit-197"></a></var><br>
<blockquote><p>Initialize an extensible cord. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CORD_ec_append</b> (<var>CORD_ec x, char c</var>)<var><a name="index-CORD_005fec_005fappend-198"></a></var><br>
<blockquote><p>Append a character to an extensible cord. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>CORD_ec_append_cord</b> (<var>CORD_ec x, CORD s</var>)<var><a name="index-CORD_005fec_005fappend_005fcord-199"></a></var><br>
<blockquote><p>Append a cord to an extensible cord.  <var>s</var> remains shared with
<var>x</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Macro: <b>CORD_ec_to_cord</b> (<var>CORD_ec x</var>)<var><a name="index-CORD_005fec_005fto_005fcord-200"></a></var><br>
<blockquote><p>Convert an extensible cord to a cord, then return a pointer to the
<code>CORD</code> embedded into <var>x</var>.  This macro is a wrapper for
<code>CORD_ec_flush_buf()</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>CORD_ec_flush_buf</b> (<var>CORD_ec x</var>)<var><a name="index-CORD_005fec_005fflush_005fbuf-201"></a></var><br>
<blockquote><p>Flush the buffer part of the extended cord into the internal
<code>CORD</code>. 
</p></blockquote></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="Package-License"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Documentation-License">Documentation License</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#cord">cord</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix C Package license</h2>

<p class="noindent">Copyright &copy; 1988, 1989 Hans-J. Boehm, Alan J. Demers<br>
Copyright &copy; 1991&ndash;1996 by Xerox Corporation.  All rights reserved.<br>
Copyright &copy; 1996&ndash;1999 by Silicon Graphics.  All rights reserved.<br>
Copyright &copy; 1999&ndash;2005 Hewlett-Packard Development Company, L.P.

   <p>The file <samp><span class="file">linux_threads.c</span></samp> is also Copyright &copy; 1998 by
Fergus Henderson.  All rights reserved.

   <p>The files <samp><span class="file">Makefile.am</span></samp>, and <samp><span class="file">configure.in</span></samp> are Copyright
&copy; 2001 by Red Hat Inc. All rights reserved.

   <p>Several files supporting <acronym>GNU</acronym> style builds are copyrighted by the Free
Software Foundation, and carry a different license from that given
below.  The files included in the <code>libatomic_ops</code> distribution
(included here) use either the license below, or a similar <acronym>MIT</acronym>
style license, or, for some files not actually used by the garbage
collector library, the <acronym>GPL</acronym>.

   <p>THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.

   <p>Permission is hereby granted to use or copy this program for any
purpose, provided the above notices are retained on all copies. 
Permission to modify the code and to distribute modified code is
granted, provided the above notices are retained, and a notice that the
code was modified is included with the above copyright notice.

   <p>A few of the files needed to use the <acronym>GNU</acronym> style build procedure come
with slightly different licenses, though they are all similar in spirit. 
A few are <acronym>GPL</acronym>'ed, but with an exception that should cover all uses in
the collector.  (If you are concerned about such things, I recommend you
look at the notice in <samp><span class="file">config.guess</span></samp> or <samp><span class="file">ltmain.sh</span></samp>.)

<!--  -->
<!-- page -->
<div class="node">
<a name="Documentation-License"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#References">References</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Package-License">Package License</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix D Documentation License</h2>

<p>This document describes version 7.1 of <acronym>GC</acronym>, the
Boehm&ndash;Demers&ndash;Weiser Garbage Collection Library; it is a Texinfo
reformatting of the documentation available from the <acronym>GC</acronym> website:

<div align="center"><a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">http://www.hpl.hp.com/personal/Hans_Boehm/gc/</a></div>

<p class="noindent">or included with the distribution; some adjustment has been done.  This
document is <strong>unofficial</strong> documentation of the library.

<p class="noindent">Copyright &copy; 1988, 1989, 2008 Hans&ndash;J. Boehm, Alan J. Demers<br>
Copyright &copy; 1991&ndash;1996 by Xerox Corporation.  All rights reserved.<br>
Copyright &copy; 1996&ndash;1999 by Silicon Graphics.  All rights reserved.<br>
Copyright &copy; 1999&ndash;2005 Hewlett&ndash;Packard Development Company, L.P.

   <p>Texinfo reformatting and minor changes by Marco Maggi
<a href="mailto:marcomaggi@gna.org">marcomaggi@gna.org</a>.

   <blockquote>
THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.

   <p>Permission is hereby granted to use or copy this document for any
purpose, provided the above notices are retained on all copies. 
Permission to modify this document and to distribute modified copies of
this document is granted, provided the above notices are retained, and a
notice that the document was modified is included with the above
copyright notice. 
</blockquote>

<!--  -->
<!-- page -->
<div class="node">
<a name="References"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Concept-Index">Concept Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Documentation-License">Documentation License</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix E Bibliography and references</h2>

<p class="noindent">The algorithms used are described in:

<p class="noindent">Boehm, H., and M. Weiser, <em>Garbage Collection in an Uncooperative
Environment</em>, Software Practice &amp; Experience, September 1988,
pp. 807&ndash;820.

<p class="noindent">Boehm, H., A. Demers, and S. Shenker, <em>Mostly Parallel Garbage
Collection</em>, Proceedings of the ACM SIGPLAN '91 Conference on
Programming Language Design and Implementation, SIGPLAN Notices 26, 6
(June 1991), pp. 157&ndash;164.

<p class="noindent">Boehm, H., <em>Space Efficient Conservative Garbage Collection</em>,
Proceedings of the ACM SIGPLAN '91 Conference on Programming Language
Design and Implementation, SIGPLAN Notices 28, 6 (June 1993),
pp. 197&ndash;206.

<p class="noindent">Boehm H., <em>Reducing Garbage Collector Cache Misses</em>, Proceedings of
the 2000 International Symposium on Memory Management.

   <p>Possible interactions between the collector and optimizing compilers are
discussed in

<p class="noindent">Boehm, H., and D. Chase, <em>A Proposal for GC&ndash;safe C Compilation</em>,
The Journal of C Language Translation 4, 2 (December 1992).

<p class="noindent">and:

<p class="noindent">Boehm H., <em>Simple GC&ndash;safe Compilation</em>, Proceedings of the ACM
SIGPLAN '96 Conference on Programming Language Design and
Implementation.

   <p>Some of these are also available from:

<div align="center"><a href="http://www.hpl.hp.com/personal/Hans_Boehm/papers/">http://www.hpl.hp.com/personal/Hans_Boehm/papers/</a></div>

<p class="noindent">among other places.

   <p>Unlike the collector described in the second reference, this collector
operates either with the mutator stopped during the entire collection
(default) or incrementally during allocations.  (The latter is supported
on fewer machines.)  On the most common platforms, it can be built with
or without thread support.  On a few platforms, it can take advantage of
a multiprocessor to speed up garbage collection.

   <p>Many of the ideas underlying the collector have previously been explored
by others.  Notably, some of the run&ndash;time systems developed at Xerox
PARC in the early 1980s conservatively scanned thread stacks to locate
possible pointers (cf. Paul Rovner, <em>On Adding Garbage Collection
and Runtime Types to a Strongly&ndash;Typed Statically Checked, Concurrent
Language</em> Xerox PARC CSL 84-7).  Doug McIlroy wrote a simpler fully
conservative collector that was part of version 8 <acronym>UNIX</acronym> (tm),
but appears to not have received widespread use.

   <p>Rudimentary tools for use of the collector as a leak detector are
included, see:

<div align="center"><a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/leak.html">http://www.hpl.hp.com/personal/Hans_Boehm/gc/leak.html</a>)</div>

<p class="noindent">as is a fairly sophisticated string package <code>cord</code> that makes use
of the collector.  See <samp><span class="file">doc/README.cords</span></samp> and H.-J. Boehm,
R. Atkinson, and M. Plass, <em>Ropes: An Alternative to Strings</em>,
Software Practice and Experience 25, 12 (December 1995), pp. 1315&ndash;1330. 
This is very similar to the <code>rope</code> package in Xerox Cedar, or the
<code>rope</code> package in the SGI STL or the g++ distribution.

   <p>Further collector documentation can be found at:

<div align="center"><a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc">http://www.hpl.hp.com/personal/Hans_Boehm/gc</a></div>

<!--  -->
<!-- page -->
<div class="node">
<a name="Concept-Index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Function-Index">Function Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#References">References</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix F An entry for each concept</h2>

<ul class="index-cp" compact>
<li><a href="#index-Cord-functions-141">Cord functions</a>: <a href="#cord-funcs">cord funcs</a></li>
<li><a href="#index-Cord-inspection-138">Cord inspection</a>: <a href="#cord-inspect">cord inspect</a></li>
<li><a href="#index-Cord-operations-146">Cord operations</a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-Cord-traversing-165">Cord traversing</a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-Cord-type-definitions-135">Cord type definitions</a>: <a href="#cord-typedefs">cord typedefs</a></li>
<li><a href="#index-Cord_002c-extensible-194">Cord, extensible</a>: <a href="#cord-extensible">cord extensible</a></li>
<li><a href="#index-Cord_002c-file-operations-182">Cord, file operations</a>: <a href="#cord-file">cord file</a></li>
<li><a href="#index-Cords-134">Cords</a>: <a href="#cord">cord</a></li>
<li><a href="#index-Cords_002c-format-functions-187">Cords, format functions</a>: <a href="#cord-format">cord format</a></li>
<li><a href="#index-g_t_0040env_007bGC_005fDUMP_005fREGULARLY_007d-58"><samp><span class="env">GC_DUMP_REGULARLY</span></samp></a>: <a href="#api-debug">api debug</a></li>
<li><a href="#index-Object_002c-a-block-of-garbage-collectable-memory-1">Object, a block of garbage collectable memory</a>: <a href="#overview">overview</a></li>
   </ul><div class="node">
<a name="Function-Index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Variable-Index">Variable Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Concept-Index">Concept Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix G An entry for each function.</h2>



<ul class="index-fn" compact>
<li><a href="#index-CORD_005fbalance-150"><code>CORD_balance</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fbatched_005fiter_005ffn-167"><code>CORD_batched_iter_fn</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fcat-147"><code>CORD_cat</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fcat_005fchar-153"><code>CORD_cat_char</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fcat_005fchar_005fstar-148"><code>CORD_cat_char_star</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fcatn-154"><code>CORD_catn</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fchars-158"><code>CORD_chars</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fchr-163"><code>CORD_chr</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fcmp-144"><code>CORD_cmp</code></a>: <a href="#cord-compar">cord compar</a></li>
<li><a href="#index-CORD_005fdump-152"><code>CORD_dump</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fec_005fappend-198"><code>CORD_ec_append</code></a>: <a href="#cord-extensible">cord extensible</a></li>
<li><a href="#index-CORD_005fec_005fappend_005fcord-199"><code>CORD_ec_append_cord</code></a>: <a href="#cord-extensible">cord extensible</a></li>
<li><a href="#index-CORD_005fec_005fflush_005fbuf-201"><code>CORD_ec_flush_buf</code></a>: <a href="#cord-extensible">cord extensible</a></li>
<li><a href="#index-CORD_005fec_005finit-197"><code>CORD_ec_init</code></a>: <a href="#cord-extensible">cord extensible</a></li>
<li><a href="#index-CORD_005fec_005fto_005fcord-200"><code>CORD_ec_to_cord</code></a>: <a href="#cord-extensible">cord extensible</a></li>
<li><a href="#index-CORD_005fEMPTY-137"><code>CORD_EMPTY</code></a>: <a href="#cord-typedefs">cord typedefs</a></li>
<li><a href="#index-CORD_005ffetch-155"><code>CORD_fetch</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005ffn-142"><code>CORD_fn</code></a>: <a href="#cord-funcs">cord funcs</a></li>
<li><a href="#index-CORD_005fFOR-181"><code>CORD_FOR</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005ffprintf-190"><code>CORD_fprintf</code></a>: <a href="#cord-format">cord format</a></li>
<li><a href="#index-CORD_005ffrom_005fchar_005fstar-162"><code>CORD_from_char_star</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005ffrom_005ffile-183"><code>CORD_from_file</code></a>: <a href="#cord-file">cord file</a></li>
<li><a href="#index-CORD_005ffrom_005ffile_005feager-184"><code>CORD_from_file_eager</code></a>: <a href="#cord-file">cord file</a></li>
<li><a href="#index-CORD_005ffrom_005ffile_005flazy-185"><code>CORD_from_file_lazy</code></a>: <a href="#cord-file">cord file</a></li>
<li><a href="#index-CORD_005ffrom_005ffn-143"><code>CORD_from_fn</code></a>: <a href="#cord-funcs">cord funcs</a></li>
<li><a href="#index-CORD_005fIS_005fSTRING-139"><code>CORD_IS_STRING</code></a>: <a href="#cord-inspect">cord inspect</a></li>
<li><a href="#index-CORD_005fiter-170"><code>CORD_iter</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fiter5-169"><code>CORD_iter5</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fiter_005ffn-166"><code>CORD_iter_fn</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005flen-140"><code>CORD_len</code></a>: <a href="#cord-inspect">cord inspect</a></li>
<li><a href="#index-CORD_005fncmp-145"><code>CORD_ncmp</code></a>: <a href="#cord-compar">cord compar</a></li>
<li><a href="#index-CORD_005fnext-178"><code>CORD_next</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fNO_005fFN-168"><code>CORD_NO_FN</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fNOT_005fFOUND-156"><code>CORD_NOT_FOUND</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fnul-159"><code>CORD_nul</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fpos_005ffetch-176"><code>CORD_pos_fetch</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fpos_005fto_005fcord-174"><code>CORD_pos_to_cord</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fpos_005fto_005findex-175"><code>CORD_pos_to_index</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fpos_005fvalid-180"><code>CORD_pos_valid</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fprev-179"><code>CORD_prev</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fprintf-192"><code>CORD_printf</code></a>: <a href="#cord-format">cord format</a></li>
<li><a href="#index-CORD_005fput-186"><code>CORD_put</code></a>: <a href="#cord-file">cord file</a></li>
<li><a href="#index-CORD_005frchr-164"><code>CORD_rchr</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005friter-172"><code>CORD_riter</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005friter4-171"><code>CORD_riter4</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fset_005fpos-177"><code>CORD_set_pos</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-CORD_005fsprintf-188"><code>CORD_sprintf</code></a>: <a href="#cord-format">cord format</a></li>
<li><a href="#index-CORD_005fstr-157"><code>CORD_str</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fsubstr-149"><code>CORD_substr</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fto_005fchar_005fstar-160"><code>CORD_to_char_star</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fto_005fconst_005fchar_005fstar-161"><code>CORD_to_const_char_star</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-CORD_005fvfprintf-191"><code>CORD_vfprintf</code></a>: <a href="#cord-format">cord format</a></li>
<li><a href="#index-CORD_005fvprintf-193"><code>CORD_vprintf</code></a>: <a href="#cord-format">cord format</a></li>
<li><a href="#index-CORD_005fvsprintf-189"><code>CORD_vsprintf</code></a>: <a href="#cord-format">cord format</a></li>
<li><a href="#index-GC_005fadd_005froots-80"><code>GC_add_roots</code></a>: <a href="#api-roots">api roots</a></li>
<li><a href="#index-GC_005fAPI-2"><code>GC_API</code></a>: <a href="#api">api</a></li>
<li><a href="#index-GC_005fbase-74"><code>GC_base</code></a>: <a href="#api-inspect">api inspect</a></li>
<li><a href="#index-GC_005fcall_005fwith_005falloc_005flock-95"><code>GC_call_with_alloc_lock</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005fcall_005fwith_005fstack_005fbase-125"><code>GC_call_with_stack_base</code></a>: <a href="#api-threads">api threads</a></li>
<li><a href="#index-GC_005fchange_005fstubborn-77"><code>GC_change_stubborn</code></a>: <a href="#api-stubborn">api stubborn</a></li>
<li><a href="#index-GC_005fCHANGE_005fSTUBBORN-38"><code>GC_CHANGE_STUBBORN</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fclear_005froots-79"><code>GC_clear_roots</code></a>: <a href="#api-roots">api roots</a></li>
<li><a href="#index-GC_005fcollect_005fa_005flittle-101"><code>GC_collect_a_little</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fDEBUG-57"><code>GC_DEBUG</code></a>: <a href="#api-debug">api debug</a></li>
<li><a href="#index-GC_005fdebug_005fmalloc_005freplacement-60"><code>GC_debug_malloc_replacement</code></a>: <a href="#api-debug-special">api debug special</a></li>
<li><a href="#index-GC_005fdebug_005frealloc_005freplacement-61"><code>GC_debug_realloc_replacement</code></a>: <a href="#api-debug-special">api debug special</a></li>
<li><a href="#index-GC_005fdebug_005fregister_005fdisplacement-109"><code>GC_debug_register_displacement</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fdisable-96"><code>GC_disable</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fdump-59"><code>GC_dump</code></a>: <a href="#api-debug">api debug</a></li>
<li><a href="#index-GC_005fenable-97"><code>GC_enable</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fenable_005fincremental-110"><code>GC_enable_incremental</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fend_005fstubborn_005fchange-78"><code>GC_end_stubborn_change</code></a>: <a href="#api-stubborn">api stubborn</a></li>
<li><a href="#index-GC_005fEND_005fSTUBBORN_005fCHANGE-39"><code>GC_END_STUBBORN_CHANGE</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fexclude_005fstatic_005froots-82"><code>GC_exclude_static_roots</code></a>: <a href="#api-roots">api roots</a></li>
<li><a href="#index-GC_005fexpand_005fhp-103"><code>GC_expand_hp</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005ffree-51"><code>GC_free</code></a>: <a href="#api-base">api base</a></li>
<li><a href="#index-GC_005fFREE-32"><code>GC_FREE</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fgcollect-98"><code>GC_gcollect</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fgeneral_005fregister_005fdisappearing_005flink-89"><code>GC_general_register_disappearing_link</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005fGENERAL_005fREGISTER_005fDISAPPEARING_005fLINK-40"><code>GC_GENERAL_REGISTER_DISAPPEARING_LINK</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fget_005fbytes_005fsince_005fgc-106"><code>GC_get_bytes_since_gc</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fget_005ffree_005fbytes-105"><code>GC_get_free_bytes</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fget_005fheap_005fsize-102"><code>GC_get_heap_size</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fget_005fstack_005fbase-128"><code>GC_get_stack_base</code></a>: <a href="#api-threads">api threads</a></li>
<li><a href="#index-GC_005fget_005ftotal_005fbytes-107"><code>GC_get_total_bytes</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fI_005fHIDE_005fPOINTERS-131"><code>GC_I_HIDE_POINTERS</code></a>: <a href="#api-misc">api misc</a></li>
<li><a href="#index-GC_005fincremental_005fprotection_005fneeds-112"><code>GC_incremental_protection_needs</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005finit-47"><code>GC_init</code></a>: <a href="#api-init">api init</a></li>
<li><a href="#index-GC_005fINIT-46"><code>GC_INIT</code></a>: <a href="#api-init">api init</a></li>
<li><a href="#index-GC_005finvoke_005ffinalizers-92"><code>GC_invoke_finalizers</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005fis_005fvalid_005fdisplacement-69"><code>GC_is_valid_displacement</code></a>: <a href="#api-debug-validation">api debug validation</a></li>
<li><a href="#index-GC_005fis_005fvisible-68"><code>GC_is_visible</code></a>: <a href="#api-debug-validation">api debug validation</a></li>
<li><a href="#index-GC_005fmalloc-48"><code>GC_malloc</code></a>: <a href="#api-base">api base</a></li>
<li><a href="#index-GC_005fMALLOC-25"><code>GC_MALLOC</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fmalloc_005fatomic-49"><code>GC_malloc_atomic</code></a>: <a href="#api-base">api base</a></li>
<li><a href="#index-GC_005fMALLOC_005fATOMIC-26"><code>GC_MALLOC_ATOMIC</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fmalloc_005fatomic_005fignore_005foff_005fpage-118"><code>GC_malloc_atomic_ignore_off_page</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fMALLOC_005fATOMIC_005fIGNORE_005fOFF_005fPAGE-30"><code>GC_MALLOC_ATOMIC_IGNORE_OFF_PAGE</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fmalloc_005fatomic_005funcollectable-53"><code>GC_malloc_atomic_uncollectable</code></a>: <a href="#api-base">api base</a></li>
<li><a href="#index-GC_005fmalloc_005fignore_005foff_005fpage-117"><code>GC_malloc_ignore_off_page</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fMALLOC_005fIGNORE_005fOFF_005fPAGE-29"><code>GC_MALLOC_IGNORE_OFF_PAGE</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fmalloc_005fmany-55"><code>GC_malloc_many</code></a>: <a href="#api-base">api base</a></li>
<li><a href="#index-GC_005fmalloc_005fstubborn-76"><code>GC_malloc_stubborn</code></a>: <a href="#api-stubborn">api stubborn</a></li>
<li><a href="#index-GC_005fMALLOC_005fSTUBBORN-37"><code>GC_MALLOC_STUBBORN</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fmalloc_005funcollectable-52"><code>GC_malloc_uncollectable</code></a>: <a href="#api-base">api base</a></li>
<li><a href="#index-GC_005fMALLOC_005fUNCOLLECTABLE-28"><code>GC_MALLOC_UNCOLLECTABLE</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fNEW-42"><code>GC_NEW</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fNEW_005fATOMIC-43"><code>GC_NEW_ATOMIC</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fNEW_005fSTUBBORN-44"><code>GC_NEW_STUBBORN</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fNEW_005fUNCOLLECTABLE-45"><code>GC_NEW_UNCOLLECTABLE</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fNEXT-56"><code>GC_NEXT</code></a>: <a href="#api-base">api base</a></li>
<li><a href="#index-GC_005fPOST_005fINCR-72"><code>GC_POST_INCR</code></a>: <a href="#api-debug-pointer">api debug pointer</a></li>
<li><a href="#index-GC_005fpost_005fincr-67"><code>GC_post_incr</code></a>: <a href="#api-debug-validation">api debug validation</a></li>
<li><a href="#index-GC_005fPRE_005fINCR-71"><code>GC_PRE_INCR</code></a>: <a href="#api-debug-pointer">api debug pointer</a></li>
<li><a href="#index-GC_005fpre_005fincr-66"><code>GC_pre_incr</code></a>: <a href="#api-debug-validation">api debug validation</a></li>
<li><a href="#index-GC_005fPROTECTS_005fNONE-111"><code>GC_PROTECTS_NONE</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fPROTECTS_005fPOINTER_005fHEAP-113"><code>GC_PROTECTS_POINTER_HEAP</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fPROTECTS_005fPTRFREE_005fHEAP-114"><code>GC_PROTECTS_PTRFREE_HEAP</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fPROTECTS_005fSTACK-116"><code>GC_PROTECTS_STACK</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fPROTECTS_005fSTATIC_005fDATA-115"><code>GC_PROTECTS_STATIC_DATA</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fPTR_005fADD-70"><code>GC_PTR_ADD</code></a>: <a href="#api-debug-pointer">api debug pointer</a></li>
<li><a href="#index-GC_005fPTR_005fSTORE-73"><code>GC_PTR_STORE</code></a>: <a href="#api-debug-pointer">api debug pointer</a></li>
<li><a href="#index-GC_005freachable_005fhere-93"><code>GC_reachable_here</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005frealloc-50"><code>GC_realloc</code></a>: <a href="#api-base">api base</a></li>
<li><a href="#index-GC_005fREALLOC-31"><code>GC_REALLOC</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fregister_005fdisappearing_005flink-88"><code>GC_register_disappearing_link</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005fregister_005fdisplacement-108"><code>GC_register_displacement</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fREGISTER_005fDISPLACEMENT-41"><code>GC_REGISTER_DISPLACEMENT</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fregister_005ffinalizer-84"><code>GC_register_finalizer</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005fREGISTER_005fFINALIZER-33"><code>GC_REGISTER_FINALIZER</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fregister_005ffinalizer_005fignore_005fself-85"><code>GC_register_finalizer_ignore_self</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005fREGISTER_005fFINALIZER_005fIGNORE_005fSELF-34"><code>GC_REGISTER_FINALIZER_IGNORE_SELF</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fregister_005ffinalizer_005fno_005forder-86"><code>GC_register_finalizer_no_order</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005fREGISTER_005fFINALIZER_005fNO_005fORDER-35"><code>GC_REGISTER_FINALIZER_NO_ORDER</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fregister_005ffinalizer_005funreachable-87"><code>GC_register_finalizer_unreachable</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005fREGISTER_005fFINALIZER_005fUNREACHABLE-36"><code>GC_REGISTER_FINALIZER_UNREACHABLE</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fregister_005fhas_005fstatic_005froots_005fcallback-122"><code>GC_register_has_static_roots_callback</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fregister_005fmy_005fthread-126"><code>GC_register_my_thread</code></a>: <a href="#api-threads">api threads</a></li>
<li><a href="#index-GC_005fremove_005froots-81"><code>GC_remove_roots</code></a>: <a href="#api-roots">api roots</a></li>
<li><a href="#index-GC_005fsame_005fobj-65"><code>GC_same_obj</code></a>: <a href="#api-debug-validation">api debug validation</a></li>
<li><a href="#index-GC_005fset_005ffree_005fspace_005fdivisor-121"><code>GC_set_free_space_divisor</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fset_005fmax_005fheap_005fsize-104"><code>GC_set_max_heap_size</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fset_005fwarn_005fproc-120"><code>GC_set_warn_proc</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fshould_005finvoke_005ffinalizers-91"><code>GC_should_invoke_finalizers</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005fsize-75"><code>GC_size</code></a>: <a href="#api-inspect">api inspect</a></li>
<li><a href="#index-GC_005fstrdup-54"><code>GC_strdup</code></a>: <a href="#api-base">api base</a></li>
<li><a href="#index-GC_005fSTRDUP-27"><code>GC_STRDUP</code></a>: <a href="#api-macros">api macros</a></li>
<li><a href="#index-GC_005fTIME_005fUNLIMITED-24"><code>GC_TIME_UNLIMITED</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005ftry_005fto_005fcollect-100"><code>GC_try_to_collect</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005funregister_005fdisappearing_005flink-90"><code>GC_unregister_disappearing_link</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005funregister_005fmy_005fthread-127"><code>GC_unregister_my_thread</code></a>: <a href="#api-threads">api threads</a></li>
<li><a href="#index-GC_005fVERSION_005fMAJOR-129"><code>GC_VERSION_MAJOR</code></a>: <a href="#api-version">api version</a></li>
<li><a href="#index-GC_005fVERSION_005fMINOR-130"><code>GC_VERSION_MINOR</code></a>: <a href="#api-version">api version</a></li>
<li><a href="#index-HIDE_005fPOINTER-132"><code>HIDE_POINTER</code></a>: <a href="#api-misc">api misc</a></li>
<li><a href="#index-REVEAL_005fPOINTER-133"><code>REVEAL_POINTER</code></a>: <a href="#api-misc">api misc</a></li>
   </ul><div class="node">
<a name="Variable-Index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Type-Index">Type Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Function-Index">Function Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix H An entry for each variable.</h2>



<ul class="index-vr" compact>
<li><a href="#index-CORD_005foom_005ffn-151"><code>CORD_oom_fn</code></a>: <a href="#cord-ops">cord ops</a></li>
<li><a href="#index-GC_005fall_005finterior_005fpointers-9"><code>GC_all_interior_pointers</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005fdont_005fexpand-14"><code>GC_dont_expand</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005fdont_005fgc-13"><code>GC_dont_gc</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005fdont_005fprecollect-22"><code>GC_dont_precollect</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005ffinalize_005fon_005fdemand-10"><code>GC_finalize_on_demand</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005ffinalizer_005fnotifier-12"><code>GC_finalizer_notifier</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005ffind_005fleak-8"><code>GC_find_leak</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005ffree_005fspace_005fdivisor-19"><code>GC_free_space_divisor</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005ffull_005ffreq-16"><code>GC_full_freq</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005fgc_005fno-5"><code>GC_gc_no</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005fis_005fvalid_005fdisplacement_005fprint_005fproc-63"><code>GC_is_valid_displacement_print_proc</code></a>: <a href="#api-debug-validation">api debug validation</a></li>
<li><a href="#index-GC_005fis_005fvisible_005fprint_005fproc-64"><code>GC_is_visible_print_proc</code></a>: <a href="#api-debug-validation">api debug validation</a></li>
<li><a href="#index-GC_005fjava_005ffinalization-11"><code>GC_java_finalization</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005fmax_005fretries-20"><code>GC_max_retries</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005fno_005fdls-18"><code>GC_no_dls</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005fnon_005fgc_005fbytes-17"><code>GC_non_gc_bytes</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005foom_005ffn-7"><code>GC_oom_fn</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005fparallel-6"><code>GC_parallel</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005fsame_005fobj_005fprint_005fproc-62"><code>GC_same_obj_print_proc</code></a>: <a href="#api-debug-validation">api debug validation</a></li>
<li><a href="#index-GC_005fstackbottom-21"><code>GC_stackbottom</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005ftime_005flimit-23"><code>GC_time_limit</code></a>: <a href="#api-variables">api variables</a></li>
<li><a href="#index-GC_005fuse_005fentire_005fheap-15"><code>GC_use_entire_heap</code></a>: <a href="#api-variables">api variables</a></li>
   </ul><div class="node">
<a name="Type-Index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variable-Index">Variable Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix I An entry for each type.</h2>



<ul class="index-tp" compact>
<li><a href="#index-CORD-136"><code>CORD</code></a>: <a href="#cord-typedefs">cord typedefs</a></li>
<li><a href="#index-CORD_005fec-196"><code>CORD_ec</code></a>: <a href="#cord-extensible">cord extensible</a></li>
<li><a href="#index-CORD_005fec_005fstruct-195"><code>CORD_ec_struct</code></a>: <a href="#cord-extensible">cord extensible</a></li>
<li><a href="#index-CORD_005fpos-173"><code>CORD_pos</code></a>: <a href="#cord-traverse">cord traverse</a></li>
<li><a href="#index-GC_005ffinalization_005fproc-83"><code>GC_finalization_proc</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005ffn_005ftype-94"><code>GC_fn_type</code></a>: <a href="#api-finalisation">api finalisation</a></li>
<li><a href="#index-GC_005fsigned_005fword-4"><code>GC_signed_word</code></a>: <a href="#api-typedefs">api typedefs</a></li>
<li><a href="#index-GC_005fstack_005fbase-123"><code>GC_stack_base</code></a>: <a href="#api-threads">api threads</a></li>
<li><a href="#index-GC_005fstack_005fbase_005ffunc-124"><code>GC_stack_base_func</code></a>: <a href="#api-threads">api threads</a></li>
<li><a href="#index-GC_005fstop_005ffunc-99"><code>GC_stop_func</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fwarn_005fproc-119"><code>GC_warn_proc</code></a>: <a href="#api-operations">api operations</a></li>
<li><a href="#index-GC_005fword-3"><code>GC_word</code></a>: <a href="#api-typedefs">api typedefs</a></li>
   </ul>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Boehm Demers Garbage Collection Library</a>
<li><a name="toc_overview" href="#overview">1 Overview of this document</a>
<ul>
<li><a href="#overview-algorithm">1.1 Conservative garbage collection: algorithmic overview</a>
<ul>
<li><a href="#overview-algorithm">1.1.1 Introduction</a>
<li><a href="#overview-algorithm">1.1.2 Allocation</a>
<li><a href="#overview-algorithm">1.1.3 Mark phase</a>
<li><a href="#overview-algorithm">1.1.4 Sweep phase</a>
<li><a href="#overview-algorithm">1.1.5 Finalisation</a>
<li><a href="#overview-algorithm">1.1.6 Generational Collection and Dirty Bits</a>
<li><a href="#overview-algorithm">1.1.7 Black&ndash;listing</a>
<li><a href="#overview-algorithm">1.1.8 Thread support</a>
<li><a href="#overview-algorithm">1.1.9 Thread&ndash;local allocation</a>
</li></ul>
<li><a href="#overview-finalisation">1.2 Objects finalisation</a>
<ul>
<li><a href="#overview-finalisation">1.2.1 Topologically ordered finalisation</a>
<li><a href="#overview-finalisation">1.2.2 Why topological ordering?</a>
<li><a href="#overview-finalisation">1.2.3 Programming with topological finalisation</a>
<li><a href="#overview-finalisation">1.2.4 Getting around topological finalisation ordering</a>
</li></ul>
<li><a href="#overview-scalability">1.3 Garbage collector scalability</a>
<ul>
<li><a href="#overview-scalability">1.3.1 Options for enhanced scalability</a>
<li><a href="#overview-scalability">1.3.2 The parallel marking algorithm</a>
<li><a href="#overview-scalability">1.3.3 Performance</a>
</li></ul>
<li><a href="#overview-leak">1.4 Using the garbage collector as leak detector</a>
<ul>
<li><a href="#overview-leak">1.4.1 An example</a>
<li><a href="#overview-leak">1.4.2 Simplified leak detection under Linux</a>
</li></ul>
<li><a href="#overview-notes">1.5 Notes on the garbage collector</a>
</li></ul>
<li><a name="toc_install" href="#install">2 Installation and portability</a>
<li><a name="toc_api" href="#api">3 The C interface to the allocator</a>
<ul>
<li><a href="#api-typedefs">3.1 Type definitions</a>
<li><a href="#api-variables">3.2 Public variables</a>
<ul>
<li><a href="#api-variables">3.2.1 Read&ndash;only variables</a>
<li><a href="#api-variables">3.2.2 Write&ndash;only variables</a>
</li></ul>
<li><a href="#api-macros">3.3 Function wrappers</a>
<ul>
<li><a href="#api-macros">3.3.1 Other macros</a>
</li></ul>
<li><a href="#api-init">3.4 Library initialisation</a>
<li><a href="#api-base">3.5 Basic interface functions</a>
<li><a href="#api-debug">3.6 Debugging facilities</a>
<ul>
<li><a href="#api-debug-special">3.6.1 Special debugging functions</a>
<li><a href="#api-debug-validation">3.6.2 Validation functions</a>
<li><a href="#api-debug-pointer">3.6.3 Pointer operation macros</a>
</li></ul>
<li><a href="#api-inspect">3.7 Inspecting objects</a>
<li><a href="#api-stubborn">3.8 Stubborn objects</a>
<li><a href="#api-roots">3.9 Root memory blocks</a>
<li><a href="#api-finalisation">3.10 Finalisation functions</a>
<li><a href="#api-operations">3.11 Miscellaneous operations</a>
<ul>
<li><a href="#api-operations">3.11.1 Enabling/disabling garbage collection</a>
<li><a href="#api-operations">3.11.2 Explicit garbage collection</a>
<li><a href="#api-operations">3.11.3 Heap size</a>
<li><a href="#api-operations">3.11.4 Memory inspection</a>
<li><a href="#api-operations">3.11.5 Interior pointers</a>
<li><a href="#api-operations">3.11.6 Incremental garbage collection</a>
<li><a href="#api-operations">3.11.7 Other functions</a>
</li></ul>
<li><a href="#api-threads">3.12 Handling threads</a>
<li><a href="#api-cplusplus">3.13 The C++ interface to the allocator</a>
<li><a href="#api-leak">3.14 Use as leak detector</a>
<ul>
<li><a href="#api-leak">3.14.1 Debugging facilities</a>
</li></ul>
<li><a href="#api-collector">3.15 Incremental/generational collection</a>
<li><a href="#api-version">3.16 Library version informations</a>
<li><a href="#api-misc">3.17 Miscellaneous stuff</a>
<ul>
<li><a href="#api-misc">3.17.1 Hiding pointers</a>
</li></ul>
</li></ul>
<li><a name="toc_bugs" href="#bugs">4 Bugs</a>
<li><a name="toc_tutorial" href="#tutorial">Appendix A Using the garbage collector: a simple example</a>
<ul>
<li><a href="#tutorial">A.1 Building the collector</a>
<ul>
<li><a href="#tutorial">A.1.1 Other platforms</a>
<li><a href="#tutorial">A.1.2 Threads</a>
<li><a href="#tutorial">A.1.3 C++</a>
</li></ul>
<li><a href="#tutorial">A.2 Writing the program</a>
<ul>
<li><a href="#tutorial">A.2.1 Interaction with the system <code>malloc()</code></a>
<li><a href="#tutorial">A.2.2 Other Platforms</a>
<li><a href="#tutorial">A.2.3 Threads</a>
</li></ul>
<li><a href="#tutorial">A.3 C++</a>
<li><a href="#tutorial">A.4 Debugging</a>
<li><a href="#tutorial">A.5 What if we can't rewrite/recompile my program?</a>
<li><a href="#tutorial">A.6 Compiling and linking</a>
<li><a href="#tutorial">A.7 Threads</a>
<li><a href="#tutorial">A.8 Running the executable</a>
</li></ul>
<li><a name="toc_cord" href="#cord">Appendix B The cord string interface</a>
<ul>
<li><a href="#cord-intro">B.1 Introduction</a>
<li><a href="#cord-typedefs">B.2 Type definitions</a>
<li><a href="#cord-inspect">B.3 Inspection</a>
<li><a href="#cord-funcs">B.4 Cord functions</a>
<li><a href="#cord-compar">B.5 Comparison</a>
<li><a href="#cord-ops">B.6 Operations</a>
<li><a href="#cord-traverse">B.7 Traversing</a>
<li><a href="#cord-file">B.8 File operations</a>
<li><a href="#cord-format">B.9 Format functions</a>
<li><a href="#cord-extensible">B.10 Extensible cords</a>
</li></ul>
<li><a name="toc_Package-License" href="#Package-License">Appendix C Package license</a>
<li><a name="toc_Documentation-License" href="#Documentation-License">Appendix D Documentation License</a>
<li><a name="toc_References" href="#References">Appendix E Bibliography and references</a>
<li><a name="toc_Concept-Index" href="#Concept-Index">Appendix F An entry for each concept</a>
<li><a name="toc_Function-Index" href="#Function-Index">Appendix G An entry for each function.</a>
<li><a name="toc_Variable-Index" href="#Variable-Index">Appendix H An entry for each variable.</a>
<li><a name="toc_Type-Index" href="#Type-Index">Appendix I An entry for each type.</a>
</li></ul>
</div>

<div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> In computer programming,
<code>.bss</code> or <code>bss</code> (Block Started by Symbol) is used by many
compilers and linkers as the name of the data segment containing static
variables that are filled solely with zero&ndash;valued data initially
(i. e., when execution begins).  It is often referred to as the &ldquo;bss
section&rdquo; or &ldquo;bss segment&rdquo;.  The program loader initialises the memory
allocated for the bss section when it loads the program.

   <p>In an object module compiled from C, the bss section contains the local
variables (but not functions) that were declared with the <code>static</code>
keyword, except for those with non&ndash;zero initial values (in C,
<code>static</code> variables are uninitialised to zero by default).  It also
contains the non&ndash;local (both <code>extern</code> and <code>static</code>) variables
that are also uninitialised to zero (either explicitly or by default).

<p class="noindent">Wikipedia contributors, &ldquo;.bss&rdquo;.  Wikipedia, The Free Encyclopedia,
<a href="http://en.wikipedia.org/w/index.php?title=.bss&amp;oldid=232900133">http://en.wikipedia.org/w/index.php?title=.bss&amp;oldid=232900133</a>
accessed August 24, 2008.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> The interface
represents my conclusions from a long discussion with Alan Demers, Dan
Greene, Carl Hauser, Barry Hayes, Christian Jacobi, and Russ Atkinson. 
It's not perfect, and probably nobody else agrees with it.

   <p>Hans-J. Boehm 3/13/92</p>

   <p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> Notice that in version 7.1 of <acronym>GC</acronym> these header
files are not installed.  We have to install them by ourselves, along
with the header file <samp><span class="file">cord_pos.h</span></samp>, in the directory
<samp><span class="file">$prefix/include/gc</span></samp>; for this operation to succeed we must edit
the file <samp><span class="file">include/cord.h</span></samp> (in the <acronym>GC</acronym> source tree) to change the
line:

<pre class="example">     #include "private/cord_pos.h"
</pre>
   <p class="noindent">to:

<pre class="example">     #include "cord_pos.h"
</pre>
   <p class="noindent">if we do this before compiling we have to copy that header file to the
<samp><span class="file">include</span></samp> directory of the source tree.</p>

   <hr></div>

</body></html>

