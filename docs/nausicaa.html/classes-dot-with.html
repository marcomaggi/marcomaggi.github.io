<html lang="en">
<head>
<title>classes dot with - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="classes-dot.html#classes-dot" title="classes dot">
<link rel="next" href="classes-dot-let.html#classes-dot-let" title="classes dot let">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d8 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008-2011 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="classes-dot-with"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="classes-dot-let.html#classes-dot-let">classes dot let</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="classes-dot.html#classes-dot">classes dot</a>
<hr>
</div>

<h4 class="subsection">25.7.1 Basic dot notation usage</h4>

<p>The <code>with-class</code> syntax is the basic tool providing dot notation in
fields and methods usage; the <code>with-fields</code> syntax is very similar,
but its use is a bit dangerous and it should be avoided with the
exception of some special case.

<div class="defun">
&mdash; Syntax: <b>with-class</b> (<var>clause ...</var>)<var> body<a name="index-with_002dclass-1493"></a></var><br>
<blockquote><p>Expand into nested <code>let-syntax</code> forms which define: identifier
syntaxes to access and mutate fields and virtual fields of objects and
records; macros to invoke methods of objects and records; macros to use
the getter and setter associated to a class.

        <p>Each <var>clause</var> must have the form:

     <pre class="example">          (<var>identifier</var> <var>class</var> ...)
</pre>
        <p class="noindent">where <var>class</var> must be an identifier representing a class name;
<var>identifier</var> must be an identifier bound to the object or record to
be used as &ldquo;subject&rdquo;.  When multiple class names are present in a
single clause:

     <pre class="example">          (<var>identifier</var> <var>class0</var> <var>class</var> ...)
</pre>
        <p class="noindent">the clause is equivalent to the sequence of clauses:

     <pre class="example">          (<var>identifier</var> <var>class0</var>)
          (<var>identifier</var> <var>class</var>)
          ...
</pre>
        <p class="noindent">when multiple clauses are present, the <code>with-class</code> form is
equivalent to nested <code>with-class</code> forms as follows:

     <pre class="example">          (with-class ((<var>var1</var> <var>class1</var>) (<var>var2</var> <var>class2</var>)) . <var>body</var>)
          == (with-class ((<var>var1</var> <var>class1</var>))
               (with-class ((<var>var2</var> <var>class2</var>))
                 . <var>body</var>))
</pre>
        <p>The identifier syntax for a field named &lsquo;<samp><span class="samp">alpha</span></samp>&rsquo; is built as:

     <pre class="example">          <var>identifier</var>.alpha
</pre>
        <p class="noindent">that is: variable name, dot, field name; the same goes for method's
macros.

        <p>When a <var>identifier</var> has no type: we can use <code>&lt;top&gt;</code> as its
conventional class type name; this can be useful when expanding macros
making use of <code>with-class</code>.

        <p>One identifier syntax for each field and virtual field of <var>class</var> is
defined; one macro for each method of <var>class</var> is defined.  Mutable
fields generate a full identifier syntax with accessor and mutator;
immutable fields generate only the accessor identifier syntax.

        <p>The fields and methods of the ancestors of <var>class</var> are handled as in
the following example:

     <pre class="example">          (define-class &lt;alpha&gt;
            ---)
          
          (define-class &lt;beta&gt;
            (inherit &lt;alpha&gt;)
            ---)
          
          (define-class &lt;gamma&gt;
            (inherit &lt;beta&gt;)
            ---)
          
          (define o (make &lt;gamma&gt; ---))
          
          (with-class ((o &lt;gamma&gt;))
            ---)
          == (with-class ((o &lt;alpha&gt;))
               (with-class ((o &lt;beta&gt;))
                 (with-class ((o &lt;gamma&gt;))
                   ---)))
</pre>
        <p class="noindent">so that the syntaxes of a superclass are shadowed by the syntaxes of its
subclass. 
</p></blockquote></div>

   <p>Usage example:

<pre class="example">     (define-class &lt;alpha&gt;
       (fields (mutable a)))
     
     (define r (make &lt;alpha&gt; 123))
     (define s (make &lt;alpha&gt; #\a))
     (define t (make &lt;alpha&gt; 1.0))
     
     (with-class ((r &lt;alpha&gt;)
                  (s &lt;alpha&gt;)
                  (t &lt;alpha&gt;))
     
       (list r.a s.a t.a) &rArr; (123 #\a 1.0)
     
       (set! r.a 456)
       (set! s.a #\b)
       (set! t.a 2.0)
     
       (list r.a s.a t.a)) &rArr; (456 #\b 2.0)
</pre>
   <p class="noindent">an example with virtual fields:

<pre class="example">     (define-class &lt;fraction&gt;
       (fields (mutable number))
       (virtual-fields (immutable numerator)
                       (immutable denominator)))
     
     (define (&lt;fraction&gt;-numerator o)
       (numerator (&lt;fraction&gt;-number o)))
     
     (define (&lt;fraction&gt;-denominator o)
       (denominator (&lt;fraction&gt;-number o)))
     
     (define o (make &lt;fraction&gt; 2/3))
     
     (with-class ((o &lt;fraction&gt;))
       (list o.numerator o.denominator))
     &rArr; (2 3)
</pre>
   <p class="noindent">an example with multiple class names in which the superclass' members
shadow the subclass' members:

<pre class="example">     (define-class &lt;alpha&gt;
       (fields (immutable a)))
     
     (define-class &lt;beta&gt;
       (inherit &lt;alpha&gt;)
       (fields (immutable b)))
     
     (define o (make &lt;beta&gt; 1 2))
     
     (with-class ((o &lt;beta&gt; &lt;alpha&gt;))
       (list o.a o.b))
     &rArr; (1 2)
</pre>
   <p class="noindent">an example with methods, external definitions:

<pre class="example">     (define-class &lt;fraction&gt;
       (fields (mutable number))
       (virtual-fields (mutable numerator))
       (methods (denominator)
                product
                (the-list the-list-function)))
     
     ;; virtual field accessor and mutator
     
     (define (&lt;fraction&gt;-numerator o)
       (numerator (&lt;fraction&gt;-number o)))
     
     (define (&lt;fraction&gt;-numerator-set! o v)
       (let ((n (&lt;fraction&gt;-number o)))
         (&lt;fraction&gt;-number-set! o (/ v (denominator n)))))
     
     ;; method functions
     
     (define (&lt;fraction&gt;-denominator o)
       (denominator (&lt;fraction&gt;-number o)))
     
     (define/with-class (&lt;fraction&gt;-product (o &lt;fraction&gt;) lambda)
       (set! o.numerator (* o.numerator lambda)))
     
     (define/with-class (the-list-function (o &lt;fraction&gt;) . ell)
       (cons o.numerator ell))
     
     ;; tests
     
     (let ((o (make &lt;fraction&gt; 2/3)))
       (with-class ((o &lt;fraction&gt;))
         (o.denominator)))
     &rArr; 3
     
     (let ((o (make &lt;fraction&gt; 2/3)))
       (with-class ((o &lt;fraction&gt;))
         (o.product 10)
         o.numerator))
     &rArr; 20
     
     (let ((o (make &lt;fraction&gt; 2/3)))
       (with-class ((o &lt;fraction&gt;))
         (o.the-list 10 11 12 13)))
     &rArr; (2 10 11 12 13)
</pre>
   <p class="noindent">another example with methods, internal definitions:

<pre class="example">     (define-class &lt;fraction&gt;
       (fields (mutable number))
       (virtual-fields (mutable numerator))
     
       (method (denominator o)
         (denominator (&lt;fraction&gt;-number o)))
     
       (method (product (o &lt;fraction&gt;) lambda)
         (set! o.numerator (* o.numerator lambda)))
     
       (method (the-list (o &lt;fraction&gt;) . ell)
         (cons o.numerator ell)))
     
     ;; virtual field accessor and mutator
     
     (define (&lt;fraction&gt;-numerator o)
       (numerator (&lt;fraction&gt;-number o)))
     
     (define (&lt;fraction&gt;-numerator-set! o v)
       (let ((n (&lt;fraction&gt;-number o)))
         (&lt;fraction&gt;-number-set! o (/ v (denominator n)))))
     
     ;; tests
     
     (let ((o (make &lt;fraction&gt; 2/3)))
       (with-class ((o &lt;fraction&gt;))
         o.numerator))
     &rArr; 2
     
     (let ((o (make &lt;fraction&gt; 2/3)))
       (with-class ((o &lt;fraction&gt;))
         (o.denominator)))
     &rArr; 3
     
     (let ((o (make &lt;fraction&gt; 2/3)))
       (with-class ((o &lt;fraction&gt;))
         (o.product 10)
         o.numerator))
     &rArr; 20
     
     (let ((o (make &lt;fraction&gt; 2/3)))
       (with-class ((o &lt;fraction&gt;))
         (o.the-list 10 11 12 13)))
     &rArr; (2 10 11 12 13)
</pre>
   <p>Notice that we can use virtual fields to access the concrete fields of
parent classes:

<pre class="example">     (define-class &lt;alpha&gt;
       (fields a))
     
     (define-class &lt;beta&gt;
       (inherit &lt;alpha&gt;
         (dry))
       (fields b)
       (virtual-fields (immutable a &lt;alpha&gt;-a)))
     
     (let ((o (make &lt;beta&gt; 1 2)))
       (with-class ((o &lt;beta&gt;))
         (list o.a o.b)))
     &rArr; (1 2)
</pre>
   <!--  -->
<div class="defun">
&mdash; Syntax: <b>with-fields</b> (<var>clause ...</var>)<var> body<a name="index-with_002dfields-1494"></a></var><br>
<blockquote><p>Works exactly like <code>with-class</code>, but it does not use dot notation
for the fields and methods of the referenced instance; rather it creates
identifier syntaxes with names being the names of fields and methods. 
Examples:

     <pre class="example">          (define-class &lt;alpha&gt;
            (fields (mutable a)
                    (mutable b))
            (methods red blue green))
          
          (define-class &lt;beta&gt;
            (fields (mutable c)
                    (mutable d)))
          
          (define (&lt;alpha&gt;-red o)
            (with-fields ((o &lt;alpha&gt;))
              (list a b)))
          
          (define (&lt;alpha&gt;-blue o p)
            (with-fields ((o &lt;alpha&gt;)
                          (p &lt;beta&gt;))
              (list a b c d)))
          
          (define (&lt;alpha&gt;-green o p)
            (with-fields ((o &lt;alpha&gt;)
                          (p &lt;beta&gt;))
              (cons #\a (blue p))))
          
          (let/with-class (((p &lt;alpha&gt;) (make* &lt;alpha&gt; 1 2)))
            (p.red))
          &rArr; (1 2)
          
          (let/with-class (((p &lt;alpha&gt;) (make* &lt;alpha&gt; 1 2))
                           ((q &lt;beta&gt;)  (make* &lt;beta&gt;  3 4)))
            (p.blue q))
          &rArr; (1 2 3 4)
          
          (let/with-class (((p &lt;alpha&gt;) (make* &lt;alpha&gt; 1 2))
                           ((q &lt;beta&gt;)  (make* &lt;beta&gt;  3 4)))
            (p.green q))
          &rArr; (#\a 1 2 3 4)
</pre>
        <p class="noindent">notice how it works with nested dot notation for tagged fields:

     <pre class="example">          (define-class &lt;alpha&gt;
            (fields (mutable a)
                    (mutable b))
            (methods red blue green the-this))
          
          (define-class &lt;beta&gt;
            (fields (mutable (c &lt;alpha&gt;))
                    (mutable d)))
          
          (let ((o (make* &lt;beta&gt;
                     (make* &lt;alpha&gt;
                       1 2)
                     3)))
            (with-fields ((o &lt;beta&gt;))
              (is-a? c &lt;alpha&gt;)   &rArr; #t
              c.a                 &rArr; 1
              c.b                 &rArr; 2
              d))                 &rArr; 3
</pre>
        <p>Care must be taken when using this syntax, because it makes no effort to
check conflicts between member names of different classes; usually it
makes sense to use <code>with-fields</code> with only one instance, for
example with the first argument to a method function. 
</p></blockquote></div>

<!--  -->
<h5 class="subsubheading">Duplicated field names</h5>

<p>We have to be careful when selecting names for methods and virtual
fields; in any case, it is forbidden to use the same symbol twice for
fields, virtual fields or methods of the same class definition. 
Duplication of names in concrete fields, of record types in the same
hierarchy, is allowed by <acronym>R6RS</acronym>:

<pre class="example">     (define-record-type &lt;alpha&gt;
       (fields a))
     
     (define-record-type &lt;beta&gt;
       (parent &lt;alpha&gt;)
       (fields a))
     
     (let ((o (make &lt;beta&gt; 1 2)))
       (&lt;alpha&gt;-a o)  &rArr; 1
       (&lt;beta&gt;-a  o)) &rArr; 2
</pre>
   <p class="noindent">in the same way duplication of names of virtual fields is allowed:

<pre class="example">     (define-class &lt;alpha&gt;
       (virtual-fields a))
     
     (define-class &lt;beta&gt;
       (inherit &lt;alpha&gt;)
       (virtual-fields a))
     
     (define (&lt;alpha&gt;-a o)
       1)
     
     (define (&lt;beta&gt;-a o)
       2)
     
     (let ((o (make &lt;beta&gt;)))
     
       (with-class ((o &lt;alpha&gt;))
         o.a) &rArr; 1
     
       (with-class ((o &lt;beta&gt;))
         o.a) &rArr; 2
     
       (with-class ((o &lt;alpha&gt;)
                    (o &lt;beta&gt;))  ;the last takes precedence
         o.a) &rArr; 2
     
       (with-class ((o &lt;beta&gt;)
                    (o &lt;alpha&gt;)) ;the last takes precedence
         o.a) &rArr; 1
     
       (with-class ((o &lt;alpha&gt; &lt;beta&gt;)) ;the last takes precedence
         o.a) &rArr; 2
     
       (with-class ((o &lt;beta&gt; &lt;alpha&gt;)) ;the last takes precedence
         o.a)) &rArr; 1
</pre>
   <p class="noindent">and duplication of names of methods is allowed, too:

<pre class="example">     (define-class &lt;alpha&gt;
       (methods a))
     
     (define-class &lt;beta&gt;
       (inherit &lt;alpha&gt;)
       (methods a))
     
     (define (&lt;alpha&gt;-a o)
       1)
     
     (define (&lt;beta&gt;-a o)
       2)
     
     (let ((o (make &lt;beta&gt;)))
     
       (with-class ((o &lt;alpha&gt;))
         (o.a)) &rArr; 1
     
       (with-class ((o &lt;beta&gt;))
         (o.a)) &rArr; 2
     
       (with-class ((o &lt;alpha&gt;)
                    (o &lt;beta&gt;))  ;the last takes precedence
         (o.a)) &rArr; 2
     
       (with-class ((o &lt;beta&gt;)
                    (o &lt;alpha&gt;)) ;the last takes precedence
         (o.a)) &rArr; 1
     
       (with-class ((o &lt;alpha&gt; &lt;beta&gt;)) ;the last takes precedence
         (o.a)) &rArr; 2
     
       (with-class ((o &lt;beta&gt; &lt;alpha&gt;)) ;the last takes precedence
         (o.a))) &rArr; 1
</pre>
   <!-- page -->
   </body></html>

