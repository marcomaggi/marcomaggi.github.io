<html lang="en">
<head>
<title>irregex chunk - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="irregex.html#irregex" title="irregex">
<link rel="prev" href="irregex-replace.html#irregex-replace" title="irregex replace">
<link rel="next" href="irregex-misc.html#irregex-misc" title="irregex misc">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d4 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="irregex-chunk"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="irregex-misc.html#irregex-misc">irregex misc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="irregex-replace.html#irregex-replace">irregex replace</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="irregex.html#irregex">irregex</a>
<hr>
</div>

<h3 class="section">53.6 Chunked string matching</h3>

<p>It's often desirable to perform regular expression matching over
sequences of characters not represented as a single string.  The most
obvious example is a text&ndash;buffer data structure, but we may also want
to match over lists or trees of strings (i.e. ropes), over only certain
ranges within a string, over an input port, etc.

   <p>With existing regular expression libraries, the only way to accomplish
this is by converting the abstract sequence into a freshly allocated
string.  This can be expensive, or even impossible if the object is a
text&ndash;buffer opened onto a 500MB file.

   <p><code>(nausicaa irregex)</code> provides a chunked string <acronym>API</acronym> specifically
for this purpose.

<div class="defun">
&mdash; Function: <b>make-irregex-chunker</b><var> get-next get-string<a name="index-make_002dirregex_002dchunker-4252"></a></var><br>
&mdash; Function: <b>make-irregex-chunker</b><var> get-next get-string get-start<a name="index-make_002dirregex_002dchunker-4253"></a></var><br>
&mdash; Function: <b>make-irregex-chunker</b><var> get-next get-string get-start get-end<a name="index-make_002dirregex_002dchunker-4254"></a></var><br>
&mdash; Function: <b>make-irregex-chunker</b><var> get-next get-string get-start get-end<a name="index-make_002dirregex_002dchunker-4255"></a></var><br>
&mdash; Function: <b>make-irregex-chunker</b><var> get-next get-string get-start get-end get-substring<a name="index-make_002dirregex_002dchunker-4256"></a></var><br>
&mdash; Function: <b>make-irregex-chunker</b><var> get-next get-string get-start get-end get-substring get-subchunk<a name="index-make_002dirregex_002dchunker-4257"></a></var><br>
<blockquote><p>Define a chunking <acronym>API</acronym>.

          <dl>
<dt><code>(</code><var>get-next</var><code> chunk)</code><dd>Return the next chunk, or <code>#f</code> if there are no more chunks.

          <br><dt><code>(</code><var>get-string</var><code> chunk)</code><dd>A string source for the chunk.

          <br><dt><code>(</code><var>get-start</var><code> chunk)</code><dd>The start index of the result of <var>get-string</var> (defaults to always 0).

          <br><dt><code>(</code><var>get-end</var><code> chunk)</code><dd>The end (exclusive) of the string (defaults to <code>string-length</code> of
the source string).

          <br><dt><code>(</code><var>get-substring</var> <var>cnk1</var> <var>i</var> <var>cnk2</var> <var>j</var><code>)</code><dd>A substring for the range between the chunk <var>cnk1</var> starting at index
<var>i</var> and ending at <var>cnk2</var> at index <var>j</var>.

          <br><dt><code>(</code><var>get-subchunk</var> <var>cnk1</var> <var>i</var> <var>cnk2</var> <var>j</var><code>)</code><dd>As above but returns a new chunked data type instead of a string
(optional). 
</dl>

        <p>There are two important constraints on the <var>get-next</var> procedure.  It
must return an <code>eq?</code> identical object when called multiple times on
the same chunk, and it must not return a chunk with an empty string
(start == past).  This second constraint is for performance reasons, we
push the work of possibly filtering empty chunks to the chunker since
there are many chunk types for which empty strings aren't possible, and
this work is thus not needed.  Note that the initial chunk passed to
match on is allowed to be empty.

        <p><var>get-substring</var> is provided for possible performance improvements,
without it a default is used.

        <p><var>get-subchunk</var> is optional, but without it we cannot use
<code>irregex-match-subchunk</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>irregex-match-subchunk</b><var> match-obj<a name="index-irregex_002dmatch_002dsubchunk-4258"></a></var><br>
&mdash; Function: <b>irregex-match-subchunk</b><var> match-obj index-or-name<a name="index-irregex_002dmatch_002dsubchunk-4259"></a></var><br>
<blockquote><p>Generate a chunked data&ndash;type for the given match item, of the same type
as the underlying chunk type.  This is only available if the chunk type
specifies the <code>get-subchunk</code> <acronym>API</acronym>, otherwise an error is raised. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>irregex-search/chunked</b><var> irx chunker chunk<a name="index-irregex_002dsearch_002fchunked-4260"></a></var><br>
&mdash; Function: <b>irregex-search/chunked</b><var> irx chunker chunk start<a name="index-irregex_002dsearch_002fchunked-4261"></a></var><br>
&mdash; Function: <b>irregex-match/chunked</b><var> irx chunker chunk<a name="index-irregex_002dmatch_002fchunked-4262"></a></var><br>
&mdash; Function: <b>irregex-match/chunked</b><var> irx chunker chunk start<a name="index-irregex_002dmatch_002fchunked-4263"></a></var><br>
<blockquote><p>These return normal match&ndash;data objects.

        <p>Example: To match against a simple, flat list of strings use:

     <pre class="example">          (define (rope-&gt;string rope1 start rope2 end)
            (if (eq? rope1 rope2)
                (substring (car rope1) start end)
                (let loop ((rope (cdr rope1))
                           (res (list (substring (car rope1) start))))
                   (if (eq? rope rope2)
                       (string-concatenate-reverse      ; from SRFI-13
                        (cons (substring (car rope) 0 end) res))
                       (loop (cdr rope) (cons (car rope) res))))))
          
          (define rope-chunker
            (make-irregex-chunker (lambda (x)
                                    (and (pair? (cdr x)) (cdr x)))
                                  car
                                  (lambda (x)
                                    0)
                                  (lambda (x)
                                    (string-length (car x)))
                                  rope-&gt;string))
          
          (irregex-search/chunked &lt;pat&gt; rope-chunker &lt;list-of-strings&gt;)
</pre>
        <p>Here we are just using the default start, end and substring behaviors,
so the above chunker could simply be defined as:

     <pre class="example">          (define rope-chunker
            (make-irregex-chunker (lambda (x)
                                    (and (pair? (cdr x)) (cdr x)))
                                  car))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: <b>irregex-fold/chunked</b><var> irx kons knil chunker chunk<a name="index-irregex_002dfold_002fchunked-4264"></a></var><br>
&mdash; Function: <b>irregex-fold/chunked</b><var> irx kons knil chunker chunk finish<a name="index-irregex_002dfold_002fchunked-4265"></a></var><br>
&mdash; Function: <b>irregex-fold/chunked</b><var> irx kons knil chunker chunk finish start-index<a name="index-irregex_002dfold_002fchunked-4266"></a></var><br>
<blockquote><p>Chunked version of <code>irregex-fold</code>. 
</p></blockquote></div>

<!-- page -->
   </body></html>

