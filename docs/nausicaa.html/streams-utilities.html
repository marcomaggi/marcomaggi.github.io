<html lang="en">
<head>
<title>streams utilities - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="streams.html#streams" title="streams">
<link rel="prev" href="streams-match.html#streams-match" title="streams match">
<link rel="next" href="streams-examples.html#streams-examples" title="streams examples">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d7 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="streams-utilities"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="streams-examples.html#streams-examples">streams examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="streams-match.html#streams-match">streams match</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="streams.html#streams">streams</a>
<hr>
</div>

<h3 class="section">41.13 Utilities</h3>

<p><a name="index-g_t_0040srfi_007b_007d-streams-utilities-3677"></a>

   <p>Streams, being the signature structured data type of functional
programming languages, find useful expression in conjunction with
higher&ndash;order functions.  Some of these higher&ndash;order functions, and
their relationship to streams, are described below.

   <p>The identity and constant procedures are frequently useful as the
recursive base for maps and folds; <code>(identity obj)</code> always returns
<var>obj</var>, and <code>(const obj)</code> creates a procedure that takes any
number of arguments and always returns the same <var>obj</var>, no matter its
arguments:

<pre class="example">     (define (identity obj)
       obj)
     
     (define (const obj)
       (lambda x obj))
</pre>
   <p>Many of the stream procedures take a unary predicate that accepts an
element of a stream and returns a boolean.  Procedure <code>(negate
pred)</code> takes a unary predicate and returns a new unary predicate that,
when called, returns the opposite boolean value as the original
predicate.

<pre class="example">     (define (negate pred)
       (lambda (x) (not (pred x))))
</pre>
   <p><code>negate</code> is useful for procedures like <code>stream-take-while</code>
that take a predicate, allowing them to be used in the opposite
direction from which they were written; for instance, with the predicate
reversed, <code>stream-take-while</code> becomes <code>stream-take-until</code>. 
<code>stream-remove</code> is the opposite of <code>stream-filter</code>:

<pre class="example">     (define-stream (stream-remove pred strm)
       (stream-filter (negate pred) strm))
</pre>
   <p>A section is a procedure which has been partially applied to some of its
arguments; for instance, <code>(double x)</code>, which returns twice its
argument, is a partial application of the multiply operator to the
number 2.  Sections come in two kinds:

     <ul>
<li>Left sections partially apply arguments starting from the left.

     <li>Right sections partially apply arguments starting from the right. 
</ul>

   <p>The procedure <code>lsec</code> takes a procedure and some prefix of its
arguments and returns a new procedure in which those arguments are
partially applied; the procedure <code>rsec</code> takes a procedure and some
reversed suffix of its arguments and returns a new procedure in which
those arguments are partially applied:

<pre class="example">     (define (lsec proc . args)
       (lambda x
         (apply proc (append args x))))
     
     (define (rsec proc . args)
       (lambda x
         (apply proc (reverse (append (reverse args)
                                      (reverse x))))))
</pre>
   <p>Since most of the stream procedures take a stream as their last
(rightmost) argument, left sections are particularly useful in
conjunction with streams.

<pre class="example">     (define stream-sum (lsec stream-fold + 0))
</pre>
   <p>Function composition creates a new function by partially applying
multiple functions, one after the other.  In the simplest case there are
only two functions, <var>f</var> and <var>g</var>, composed as <code>(compose f
g)</code>; the composition can be bound to create a new function, as in:

<pre class="example">     (define fg (compose f g))
</pre>
   <p class="noindent">the procedure <code>compose</code> takes one or more procedures and returns a
new procedure that performs the same action as the individual procedures
would if called in succession:

<pre class="example">     (define (compose . fns)
       (let comp ((fns fns))
         (cond
           ((null? fns) 'error)
           ((null? (cdr fns)) (car fns))
           (else
             (lambda args
               (call-with-values
                 (lambda ()
                   (apply
                     (comp (cdr fns))
                     args))
                 (car fns)))))))
</pre>
   <p><code>compose</code> works with sections to create succinct but highly
expressive procedure definitions.  The expression to compute the squares
of the integers from 1 to 10 given above at <code>stream-unfold</code> could
be written by composing <code>stream-map</code>, <code>stream-take-while</code>, and
<code>stream-iterate</code>:

<pre class="example">     ((compose
       (lsec stream-map (rsec expt 2))
       (lsec stream-take-while (negate (rsec &gt; 10)))
       (lsec stream-iterate (rsec + 1)))
      1)
</pre>
   <!-- page -->
   </body></html>

