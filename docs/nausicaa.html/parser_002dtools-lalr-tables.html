<html lang="en">
<head>
<title>parser-tools lalr tables - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="parser_002dtools-lalr.html#parser_002dtools-lalr" title="parser-tools lalr">
<link rel="prev" href="parser_002dtools-lalr-intro.html#parser_002dtools-lalr-intro" title="parser-tools lalr intro">
<link rel="next" href="parser_002dtools-lalr-lexer.html#parser_002dtools-lalr-lexer" title="parser-tools lalr lexer">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d7 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="parser-tools-lalr-tables"></a>
<a name="parser_002dtools-lalr-tables"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="parser_002dtools-lalr-lexer.html#parser_002dtools-lalr-lexer">parser-tools lalr lexer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="parser_002dtools-lalr-intro.html#parser_002dtools-lalr-intro">parser-tools lalr intro</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="parser_002dtools-lalr.html#parser_002dtools-lalr">parser-tools lalr</a>
<hr>
</div>

<h4 class="subsection">12.3.2 Creating parser tables</h4>

<p>The following bindings are exported by the <code>(nausicaa
parser-tools lalr)</code> library.

<div class="defun">
&mdash; Syntax: <b>lalr-parser</b><var> ?clause ...<a name="index-lalr_002dparser-1896"></a></var><br>
&mdash; Syntax: <b>make-lalr-parser</b><var> ?clause ...<a name="index-make_002dlalr_002dparser-1897"></a></var><br>
<blockquote><p>Generate a parser table to be used by the LR or GLR driver.  The
behaviour of this function is configured with the <var>?clause</var>
arguments; see below for the list of supported options.  For example,
this is a simple expression grammar:

     <pre class="example">          (lalr-parser
          
            (terminals: '(ID
                          (left: + -)
                          (left: * /)
                          (nonassoc: uminus)))
          
            (rules: '((e (e + e)              : (+ $1 $3)
                         (e - e)              : (- $1 $3)
                         (e * e)              : (* $1 $3)
                         (e / e)              : (/ $1 $3)
                         (- e (prec: uminus)) : (- $2)
                         (ID)                 : $1)))
          
            ---) ;other options
</pre>
        <p><a href="parser_002dtools-lalr-grammar.html#parser_002dtools-lalr-grammar">Defining the parser</a>, for the definition
of the grammar and the meaning of the <code>terminals:</code> and
<code>rules:</code> options.

        <p>The core of the output is a set of parser &ldquo;tables&rdquo;: Scheme vectors
representing the automaton.  There are three of them: action, goto,
reduction.  The tables are used as arguments for a call to
<code>lr-driver</code> or <code>glr-driver</code>: their return value is a closure
implementing an instance of the parser. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>terminals:</b><var> sexpr<a name="index-terminals_003a-1898"></a></var><br>
<blockquote><p>Specifies a list representing the terminal symbols, their precedence and
their associativity. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>rules:</b><var> sexpr<a name="index-rules_003a-1899"></a></var><br>
<blockquote><p>Specifies a list representing the grammar production rules. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>expect:</b><var> number-of-conflicts<a name="index-expect_003a-1900"></a></var><br>
<blockquote><p>Specifies the number of rule conflicts we expect in the parser
definition.  The default is zero.

        <p>When more than <var>number-of-conflicts</var> are detected, warning messages
are printed to the current error port.  If <var>number-of-conflicts</var> is
<code>#f</code>, rather than an exact non-negative integer, no message is ever
displayed on the error port. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>parser-type:</b><var> driver<a name="index-parser_002dtype_003a-1901"></a></var><br>
<blockquote><p>Select the type of tables to generate.  Available drivers are selected
with a symbol among: &lsquo;<samp><span class="samp">lr</span></samp>&rsquo;, &lsquo;<samp><span class="samp">glr</span></samp>&rsquo;.  The default is &lsquo;<samp><span class="samp">lr</span></samp>&rsquo;. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>output-value:</b><var> #t|#f<a name="index-output_002dvalue_003a-1902"></a></var><br>
<blockquote><p>If the value is true, instruct <code>lalr-parser</code> to evaluate the output
with <code>eval</code> and return a proper Scheme function implementing a
parser maker.  This clause is mutually exclusive with
<code>output-port:</code> and <code>output-file:</code>.

        <p>With this option, in the case of the &lsquo;<samp><span class="samp">lr</span></samp>&rsquo; driver, the generated
code has the form:

     <pre class="example">          (lambda ()
            (lr-driver <var>action-table</var> <var>goto-table</var> <var>reduction-table</var>))
</pre>
        <p class="noindent">so the value returned by <code>lalr-parser</code> is a closure which, when
evaluated with no arguments, returns a new parser closure.  See
&lsquo;<samp><span class="samp">library-imports:</span></samp>&rsquo; to add libraries to the evaluation environment. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>output-port:</b><var> port<a name="index-output_002dport_003a-1903"></a></var><br>
<blockquote><p>Instruct <code>lalr-parser</code> to print the generated code to the specified
port.  This clause is mutually exclusive with <code>output-value:</code> and
<code>output-file:</code>.

        <p>When neither &lsquo;<samp><span class="samp">library-spec:</span></samp>&rsquo; nor &lsquo;<samp><span class="samp">parser-name:</span></samp>&rsquo; are used, the
output is the same as the one generated by &lsquo;<samp><span class="samp">output-value:</span></samp>&rsquo;: A
lambda function returning new parser closures.  See &lsquo;<samp><span class="samp">library-spec:</span></samp>&rsquo;
and &lsquo;<samp><span class="samp">parser-name:</span></samp>&rsquo; for details on the other output types. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>output-file:</b><var> pathname<a name="index-output_002dfile_003a-1904"></a></var><br>
<blockquote><p>Instruct <code>lalr-parser</code> to save the generated code to the specified
file; the file will be overwritten if it already exists.  <var>pathname</var>
must be a string representing the pathname.  This clause is mutually
exclusive with <code>output-value:</code> and <code>output-port:</code>.

        <p>When neither &lsquo;<samp><span class="samp">library-spec:</span></samp>&rsquo; nor &lsquo;<samp><span class="samp">parser-name:</span></samp>&rsquo; are used, the
output is the same as the one generated by &lsquo;<samp><span class="samp">output-value:</span></samp>&rsquo;: a
lambda function returning new parser closures.  See &lsquo;<samp><span class="samp">library-spec:</span></samp>&rsquo;
and &lsquo;<samp><span class="samp">parser-name:</span></samp>&rsquo; for details on the other output types. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>dump-table:</b><var> pathname<a name="index-dump_002dtable_003a-1905"></a></var><br>
<blockquote><p>Instruct <code>lalr-parser</code> to save a human readable dump of the
generated parser in the specified file.  <var>pathname</var> must be a string
representing the pathname.  The file will be overwritten if it already
exists.  This is useful for debugging purposes (if we know how the
parser works). 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>parser-name:</b><var> name<a name="index-parser_002dname_003a-1906"></a></var><br>
<blockquote><p>Instruct <code>lalr-parser</code> to use the symbol <var>name</var> as identifier
to which bind the parser maker function.  It is mandatory to use this
option when generating a library.

        <p>If this option is used, but &lsquo;<samp><span class="samp">library-spec:</span></samp>&rsquo; is not: The output is a
<code>define</code> form which, when evaluated, binds the parser maker to
<var>name</var>.  Example output for the &lsquo;<samp><span class="samp">lr</span></samp>&rsquo; driver:

     <pre class="example">          (define (<var>name</var>)
            (lr-driver <var>action-table</var> <var>goto-table</var> <var>reduction-table</var>))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>library-spec:</b><var> spec<a name="index-library_002dspec_003a-1907"></a></var><br>
<blockquote><p>Instruct <code>lalr-parser</code> to generate a proper Scheme library, holding
the parser definition and exporting a binding to the parser maker
function.  <var>spec</var> must be a proper <var>?library-name</var> as defined by
<acronym>R6RS</acronym>.

        <p>This option is especially useful in conjunction with
<code>output-file:</code>.  It is mandatory to use the clause
<code>parser-name:</code> along with <code>library-spec:</code>.

        <p>Example output for the &lsquo;<samp><span class="samp">lr</span></samp>&rsquo; driver assuming <var>name</var> is the value
used for the <code>parser-name:</code> option:

     <pre class="example">          (library <var>spec</var>
            (export <var>name</var>)
            (import (nausicaa)
              (nausicaa parser-tools lalr lr-driver)
              (prefix (nausicaa parser-tools lexical-tokens) lt.)
              (prefix (nausicaa parser-tools source-locations) sl.))
            (define (<var>name</var>)
              (lr-driver <var>action-table</var>
                         <var>goto-table</var>
                         <var>reduction-table</var>)))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>library-language:</b><var> lang<a name="index-library_002dlanguage_003a-1908"></a></var><br>
<blockquote><p>Instruct <code>lalr-parser</code> to use <var>lang</var> as language for the
library; the language is the first import specification after
<code>import</code> in the <code>library</code> form.  By default the language is
<code>(nausicaa)</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>default-library-imports:</b><var> bool<a name="index-default_002dlibrary_002dimports_003a-1909"></a></var><br>
<blockquote><p>Instruct <code>lalr-parser</code> to include the default libraries to the list
of Scheme libraries required by the parser definition.  The default
value for <var>bool</var> is <code>#t</code>.

        <p>The default list of import specifications is:

     <pre class="example">          (nausicaa parser-tools lalr <var>?driver-name</var>)
          (prefix (nausicaa parser-tools lexical-tokens) lt.)
          (prefix (nausicaa parser-tools source-locations) sl.)
</pre>
        <p class="noindent">where <var>?driver-name</var> is &lsquo;<samp><span class="samp">lr-driver</span></samp>&rsquo; or &lsquo;<samp><span class="samp">glr-driver</span></samp>&rsquo;.  If
this clause is used with <var>bool</var> set to <code>#f</code>: these libraries are
not included; in this case we should select appropriate replacements
using the <code>library-imports:</code> clause. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>library-imports:</b><var> imports<a name="index-library_002dimports_003a-1910"></a></var><br>
<blockquote><p>Instruct <code>lalr-parser</code> to add <var>imports</var> to the list of Scheme
libraries required by the parser definition.  <var>imports</var> must be a
list of library specifications; for example, if the parser definition
(meaning the semantic actions) requires the <code>(alpha)</code> and
<code>(beta)</code> libraries, we must use:

     <pre class="example">          (library-imports: '((alpha) (beta)))
</pre>
        <p>The selected imports will be added to the import list of the generated
library (if <code>library-spec:</code> is used), or to the <code>eval</code>
environment argument (if <code>output-value:</code> is used).  The imports
are ignored when the output is a <code>define</code> form. 
</p></blockquote></div>

<!-- page -->
   </body></html>

