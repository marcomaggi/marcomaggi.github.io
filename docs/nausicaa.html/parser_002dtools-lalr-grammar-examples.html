<html lang="en">
<head>
<title>parser-tools lalr grammar examples - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="parser_002dtools-lalr-grammar.html#parser_002dtools-lalr-grammar" title="parser-tools lalr grammar">
<link rel="prev" href="parser_002dtools-lalr-grammar-clauses.html#parser_002dtools-lalr-grammar-clauses" title="parser-tools lalr grammar clauses">
<link rel="next" href="parser_002dtools-lalr-grammar-error.html#parser_002dtools-lalr-grammar-error" title="parser-tools lalr grammar error">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d6 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="parser-tools-lalr-grammar-examples"></a>
<a name="parser_002dtools-lalr-grammar-examples"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="parser_002dtools-lalr-grammar-error.html#parser_002dtools-lalr-grammar-error">parser-tools lalr grammar error</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="parser_002dtools-lalr-grammar-clauses.html#parser_002dtools-lalr-grammar-clauses">parser-tools lalr grammar clauses</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="parser_002dtools-lalr-grammar.html#parser_002dtools-lalr-grammar">parser-tools lalr grammar</a>
<hr>
</div>

<h5 class="subsubsection">11.3.5.4 Dummy examples of grammar definitions</h5>

<p>In this section we examine some dummy parser definitions to understand
some basic mechanism.  <a href="parser_002dtools-lalr-grammar-preamble.html#parser_002dtools-lalr-grammar-preamble">Code preamble for all the examples</a>.

<!--  -->
<h5 class="subsubheading">Single token parser</h5>

<p>The following example defines a parser accepting only a single token of
category &lsquo;<samp><span class="samp">A</span></samp>&rsquo;, which must be followed by the end&ndash;of&ndash;input
&lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo;.  Every other input sequence causes an error; this includes
an &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; token alone.

<pre class="example">     (define make-parser
       (lalr.lalr-parser
         (lalr.output-value: #t)
         (lalr.terminals:    '(A))
         (lalr.rules:
          '((e (A) : $1)))))
     
     ;;Parse the sequence: A *eoi*
     (doit (make-token 'A 1))
     &rArr; 1
     
     ;;Parse the sequence: *eoi*
     (doit)
     &rArr; ("unexpected end of input" . (eof-object))
</pre>
   <p class="noindent">the following test raises an error:

<pre class="example">     (doit (make-token 'A 1)
           (make-token 'A 2)
           (make-token 'A 3))
     &rArr; ("unexpected end of input" . (eof-object))
</pre>
   <p class="noindent">we will come back to this test when describing the error recovery
mechanism; <a href="parser_002dtools-lalr-grammar-error.html#parser_002dtools-lalr-grammar-error">Error recovery</a>.

<!--  -->
<h5 class="subsubheading">Accepting &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; alone</h5>

<p>The following parser defines a grammar which accepts the sequence
&lsquo;<samp><span class="samp">A *eoi*</span></samp>&rsquo;, but also accepts &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; alone.

<pre class="example">     (define make-parser
       (lalr.lalr-parser
         (lalr.output-value: #t)
         (lalr.terminals:    '(A))
         (lalr.rules:
          '((e (A) : $1)
               ()  : 0))))
     
     ;;Parse the sequence: A *eoi*
     (doit (make-token 'A 1))
     &rArr; 1
     
     ;;Parse the sequence: *eoi*
     (doit)
     &rArr; 0
</pre>
   <p>When the input is a single &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; token: the parser returns the
value of the semantic action in &lsquo;<samp><span class="samp">() : 0</span></samp>&rsquo;.  When the input is the
sequence &lsquo;<samp><span class="samp">A *eoi*</span></samp>&rsquo;: the parser returns the value of the semantic
action in &lsquo;<samp><span class="samp">(A) : $1</span></samp>&rsquo;.  Let's understand why using the reasoning
explained in the introduction (see <a href="parser_002dtools-lalr-intro.html#parser_002dtools-lalr-intro">Introduction to the LR parser</a>).

     <ul>
<li>We can imagine the tokens of the sequence &lsquo;<samp><span class="samp">A *eoi*</span></samp>&rsquo; on the
following stacks:

     <pre class="example">          #(#f  1  #&lt;eof&gt;)
          #(S   A   *eoi*)
            |
            p
</pre>
     <p class="noindent">the first lookahead returns &lsquo;<samp><span class="samp">A</span></samp>&rsquo; and the action is shift, we
&ldquo;enter&rdquo; the right&ndash;hand side rule &lsquo;<samp><span class="samp">(A)</span></samp>&rsquo;:

     <pre class="example">          #(#f  1  #&lt;eof&gt;)
          #(S   A   *eoi*)
                |
                p
</pre>
     <p class="noindent">the second lookahead returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the action is reduce, we
&ldquo;leave&rdquo; the right&ndash;hand side rule &lsquo;<samp><span class="samp">(A)</span></samp>&rsquo;; one couple is popped
from the stack and one couple is pushed:

     <pre class="example">          #(#f  1  #&lt;eof&gt;)
          #(S   e   *eoi*)
                |
                p
</pre>
     <p class="noindent">the value has not changed because the semantic clause is just &lsquo;<samp><span class="samp">$1</span></samp>&rsquo;
which is &lsquo;<samp><span class="samp">1</span></samp>&rsquo; itself; the third lookahead returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and
the action is accept (the value &lsquo;<samp><span class="samp">1</span></samp>&rsquo;).

     <li>We can imagine the tokens of the sequence &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; on the following
stacks:

     <pre class="example">          #(#f  #&lt;eof&gt;)
          #(S   *eoi*)
            |
            p
</pre>
     <p class="noindent">the first lookahead returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the action is reduce, we
enter and leave the right&ndash;hand side rule &lsquo;<samp><span class="samp">()</span></samp>&rsquo; in a single step; no
couples are popped from the stacks, but a couple is pushed:

     <pre class="example">          #(#f  0  #&lt;eof&gt;)
          #(S   e   *eoi*)
                |
                p
</pre>
     <p class="noindent">we see the result of the semantic clause; the second lookahead returns
&lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the action is accept (the value &lsquo;<samp><span class="samp">0</span></samp>&rsquo;). 
</ul>

<!--  -->
<h5 class="subsubheading">Accepting fixed sequences</h5>

<p>The following parser defines a grammar which accepts the following fixed
sequences:

<pre class="example">     *eoi*
     A *eoi*
     A A *eoi*
     A A A *eoi*
</pre>
   <p class="noindent">the return value of the parser is the list of values from the tokens.

<pre class="example">     (define make-parser
       (lalr.lalr-parser
         (lalr.output-value: #t)
         (lalr.terminals:    '(A))
         (lalr.rules:
          '((e (A)     : (list $1)
               (A A)   : (list $1 $2)
               (A A A) : (list $1 $2 $3)
               ()      : 0)))))
     
     ;;Parse the sequence: A *eoi*
     (doit (make-token 'A 1))
     &rArr; (1)
     
     ;;Parse the sequence: A A *eoi*
     (doit (make-token 'A 1)
           (make-token 'A 2))
     &rArr; (1 2)
     
     ;;Parse the sequence: A A A *eoi*
     (doit (make-token 'A 1)
           (make-token 'A 2)
           (make-token 'A 3))
     &rArr; (1 2 3)
     
     ;;Parse the sequence: *eoi*
     (doit)
     &rArr; 0
</pre>
   <!--  -->
<h5 class="subsubheading">Accepting a sequence of arbitrary length</h5>

<p>The following parser defines a grammar which accepts a sequence of
&lsquo;<samp><span class="samp">A</span></samp>&rsquo; tokens of any length; it also accepts &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; alone.

<pre class="example">     (define make-parser
       (lalr.lalr-parser
         (lalr.output-value: #t)
         (lalr.terminals:    '(A))
         (lalr.rules:
          '((e (e A) : $2
               (A)   : $1
               ()    : 0)))))
     
     ;;Parse the sequence: *eoi*
     (doit)
     &rArr; 0
     
     ;;Parse the sequence: A *eoi*
     (doit (make-token 'A 1))
     &rArr; 1
     
     ;;Parse the sequence: A A A *eoi*
     (doit (make-token 'A 1)
           (make-token 'A 2)
           (make-token 'A 3))
     &rArr; 3
</pre>
   <p class="noindent">in the last test example, notice that the parser's return value is the
value of the last parsed token (&lsquo;<samp><span class="samp">3</span></samp>&rsquo;), while the other values are
discarded.  This is because the whole sequence matches the right&ndash;hand
side rule &lsquo;<samp><span class="samp">(e A)</span></samp>&rsquo; and its semantic clause is &lsquo;<samp><span class="samp">$2</span></samp>&rsquo;, which is
the value of the token matching the last terminal &lsquo;<samp><span class="samp">A</span></samp>&rsquo;.

<!--  -->
<h5 class="subsubheading">Returning all the values from an arbitrary sequence</h5>

<p>If we want all the values in the sequence we can use the following
parser:

<pre class="example">     (define make-parser
       (lalr.lalr-parser
         (lalr.output-value: #t)
         (lalr.terminals:    '(A))
         (lalr.rules:
          '((e (e A) : (cons $2 $1)
               (A)   : (list $1)
               ()    : 0)))))
     
     ;;Parse the sequence: *eoi*
     (doit)
     &rArr; 0
     
     ;;Parse the sequence: A *eoi*
     (doit (make-token 'A 1))
     &rArr; (1)
     
     ;;Parse the sequence: A A *eoi*
     (doit (make-token 'A 1)
           (make-token 'A 2))
     &rArr; (2 1)
     
     ;;Parse the sequence: A A A *eoi*
     (doit (make-token 'A 1)
           (make-token 'A 2)
           (make-token 'A 3))
     &rArr; (3 2 1)
</pre>
   <p class="noindent">we notice that the values are returned in reverse order; this is
because, making the semantic clauses explicit, the following are
equivalent:

<pre class="example">     (cons 2 (list 1))
     
     (doit (make-token 'A 1)
           (make-token 'A 2))
</pre>
   <p class="noindent">and also the following:

<pre class="example">     (cons 3 (cons 2 (list 1)))
     
     (doit (make-token 'A 1)
           (make-token 'A 2)
           (make-token 'A 3))
</pre>
   <p class="noindent">in more detail, when parsing the sequence &lsquo;<samp><span class="samp">A A *eoi*</span></samp>&rsquo; we can
imagine the following stacks:

<pre class="example">     #(#f  1  2  #&lt;eof&gt;)
     #(S   A  A   *eoi*)
       |
       p
</pre>
   <p class="noindent">the first lookahead returns &lsquo;<samp><span class="samp">A</span></samp>&rsquo; and the action is shift:

<pre class="example">     #(#f  1  2  #&lt;eof&gt;)
     #(S   A  A   *eoi*)
           |
           p
</pre>
   <p class="noindent">the second lookahead returns &lsquo;<samp><span class="samp">A</span></samp>&rsquo; and the action is reduce:

<pre class="example">     #(#f  (1)  2  #&lt;eof&gt;)
     #(S    e   A   *eoi*)
            |
            p
</pre>
   <p class="noindent">the third lookahead returns &lsquo;<samp><span class="samp">A</span></samp>&rsquo; and the action is shift:

<pre class="example">     #(#f  (1)  2  #&lt;eof&gt;)
     #(S    e   A   *eoi*)
                |
                p
</pre>
   <p class="noindent">the fourth lookahead returns &lsquo;<samp><span class="samp">A</span></samp>&rsquo; and the action is reduce:

<pre class="example">     #(#f  (2 . (1))  #&lt;eof&gt;  #f)
     #(S    e          *eoi*  #f)
            |
            p
</pre>
   <p class="noindent">and we know that &lsquo;<samp><span class="samp">(2 . (1))</span></samp>&rsquo; is &lsquo;<samp><span class="samp">(2 1)</span></samp>&rsquo;; the fifth lookahead
returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the action is accept.

<!-- page -->
   </body></html>

