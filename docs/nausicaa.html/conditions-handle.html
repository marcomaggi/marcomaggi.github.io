<html lang="en">
<head>
<title>conditions handle - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="conditions.html#conditions" title="conditions">
<link rel="prev" href="conditions-define.html#conditions-define" title="conditions define">
<link rel="next" href="conditions-types.html#conditions-types" title="conditions types">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d7 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="conditions-handle"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="conditions-types.html#conditions-types">conditions types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="conditions-define.html#conditions-define">conditions define</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="conditions.html#conditions">conditions</a>
<hr>
</div>

<h3 class="section">6.2 Handling exceptions</h3>

<p>The following bindings are exported by the library <code>(nausicaa
language conditions)</code>.

<div class="defun">
&mdash; Syntax: <b>try</b><var> ?body </var>(<var>catch ?var ?catch-clause0 ?catch-clause <small class="dots">...</small></var>)<var><a name="index-try-805"></a></var><br>
&mdash; Syntax: <b>try</b><var> ?body </var>(<var>catch ?var ?catch-clause0 ?catch-clause <small class="dots">...</small></var>) (<var>finally ?finally-body0 ?finally-body <small class="dots">...</small></var>)<var><a name="index-try-806"></a></var><br>
&mdash; Auxiliary Syntax: <b>catch</b><var><a name="index-catch-807"></a></var><br>
&mdash; Auxiliary Syntax: <b>finally</b><var><a name="index-finally-808"></a></var><br>
&mdash; Auxiliary Syntax: <b>else</b><var><a name="index-else-809"></a></var><br>
<blockquote><p>This syntax is a wrapper for <code>guard</code> from <code>(rnrs exceptions (6))</code>. 
Every <var>?catch-clause</var> has one of the forms:

     <pre class="example">          (<var>?tag</var> <var>?tag-body0</var> <var>?tag-body</var> ...)
          (else <var>?else-body0</var> <var>?else-body</var> ...)
</pre>
        <p class="noindent">where the optional <code>else</code> clause must appear only once as last
one.

        <p>When no <code>finally</code> clause is present, and without the <code>else</code>
clause, it will expand to:

     <pre class="example">          (guard (<var>?var</var>
                  ((is-a? <var>?var</var> <var>?tag</var>)
                   (with-tags ((<var>?var</var> <var>?tag</var>))
                     <var>?tag-body0</var>
                     <var>?tag-body</var>
                     ...))
                  ...)
            <var>?body</var>)
</pre>
        <p class="noindent">and with the <code>else</code> clause:

     <pre class="example">          (guard (<var>?var</var>
                  ((is-a? <var>?var</var> <var>?tag</var>)
                   (with-tags ((<var>?var</var> <var>?tag</var>))
                     <var>?tag-body0</var>
                     <var>?tag-body</var>
                     ...))
                  ...
                 (else
                  <var>?else-body0</var>
                  <var>?else-body</var>
                  ...))
            <var>?body</var>)
</pre>
        <p class="noindent">remember that when no <code>else</code> clause is present: the exception
will be re&ndash;raised with <code>raise-continuable</code>.

        <p>When the <code>finally</code> clause is present: the same <code>guard</code> form
is wrapped into a compensation stack:

     <pre class="example">          (with-compensations
            (push-compensation <var>?finally-body0</var> <var>?finally-body</var> ...)
            (guard ---))
</pre>
        </blockquote></div>

   <p>Whenever we define a tuple of simple condition objects to describe an
exception: we assume that, somewhere in the source code, such tuple is
&ldquo;known&rdquo; and code will be able to recognise it and act upon it.  The
syntax <code>try</code> proposes a way to handle such situation by defining an
<acronym>OOPP</acronym> label associated to the tuple.

   <p>Very often compound condition objects are created with components
<code>&amp;who</code>, <code>&amp;message</code> and <code>&amp;irritants</code>; the
predefined label <code>&lt;common-conditions&gt;</code> (see <a href="conditions-common.html#conditions-common">Label type for common condition types</a>) exists with the purpose of
making it easy to access such compound conditions:

<pre class="example">     (import (nausicaa))
     
     (&lt;common-conditions&gt; C (&lt;&gt; ('ciao "ciao" '(ciao))))
     
     ((&lt;common-conditions&gt;) C)       &rArr; #t
     (is-a? C &lt;common-conditions&gt;)   &rArr; #t
     (C who)                         &rArr; ciao
     (C message)                     &rArr; "ciao"
     (C irritants)                   &rArr; (ciao)
</pre>
   <p class="noindent">we can catch an exception raising a <code>&lt;common-conditions&gt;</code> compound
condition object as follows:

<pre class="example">     (try
          (raise (&lt;common-conditions&gt; ('ciao "ciao" '(ciao))))
       (catch E
         (&amp;assertion
          (exit 1))
         (&lt;common-conditions&gt;
          (E who))
         (else
          (raise E))))
     &rArr; ciao
</pre>
   <p>If we want to add some other simple condition type to the compound we
can just create a new label for it:

<pre class="example">     (define-condition-type &amp;whatever
         (parent &amp;condition)
       (fields a b c))
     
     (define-label &amp;tuple
       (parent &lt;common-conditions&gt;)
       (protocol
        (lambda ()
          (lambda (who message irritants a b c)
            (condition (&lt;common-conditions&gt; (who message irritants))
                       (&amp;whatever (a b c))))))
       (predicate (&amp;whatever))
       (virtual-fields (immutable a (slot-ref &lt;&gt; a &amp;whatever))
                       (immutable b (slot-ref &lt;&gt; b &amp;whatever))
                       (immutable c (slot-ref &lt;&gt; c &amp;whatever))))
</pre>
   <p class="noindent">and use <code>try</code> to catch it:

<pre class="example">     (try
          (raise (&amp;tuple ('ciao "ciao" '(ciao) 1 2 3)))
       (catch E
         (&amp;assertion
          (exit 1))
         (&lt;common-conditions&gt;
          (list (E who) (E a)))
         (else
          (raise E))))
     &rArr; (ciao 1)
</pre>
   <p>We can use the <code>finally</code> body to execute code, in any case, after
the body and possibly the <code>catch</code> clause have been evaluated:

<pre class="example">     ;; without exceptions
     (let ((a 1))
       (try
           (set! a (+ a 10))
         (catch E
           (&amp;error     E)
           (&amp;warning   E)
           (else       E))
         (finally
          (set! a (+ a 100))))
       a)
     &rArr; 111
     
     ;; with raised exception
     (let ((a 1))
       (try
           (raise (&amp;warning ()))
         (catch E
           (&amp;error     E)
           (&amp;warning   (set! a (+ a 10)))
           (else       E))
         (finally
          (set! a (+ a 100))))
       a)
     &rArr; 111
</pre>
   <!-- page -->
   </body></html>

