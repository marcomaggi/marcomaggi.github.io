<html lang="en">
<head>
<title>format escape complex - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="format.html#format" title="format">
<link rel="prev" href="format-escape-flonums.html#format-escape-flonums" title="format escape flonums">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d3 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="format-escape-complex"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="format-escape-flonums.html#format-escape-flonums">format escape flonums</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="format.html#format">format</a>
<hr>
</div>

<h3 class="section">40.6 Escape sequences for complex numbers</h3>

<div class="defun">
&mdash; Escape: <b>~i</b><var><a name="index-g_t_007ei-3556"></a></var><br>
<blockquote><p>Complex fixed&ndash;point float.  Parameters: <var>width</var>, <var>decimals</var>,
<var>scale</var>, <var>overflowchar</var>, <var>padchar</var>.

        <p>Output the argument as a complex number, with both real and imaginary
part shown (even if one or both are zero).

        <p>The parameters and modifiers are the same as for fixed&ndash;point <code>~f</code>
described above.  The real and imaginary parts are both output with the
same given parameters and modifiers, except that for the imaginary part
the <code>@</code> modifier is always enabled, so as to print a <code>+</code> sign
between the real and imaginary parts.

     <pre class="example">          (format #t "~i" 1)  -| 1.0+0.0i
</pre>
        <p>Notice that the imaginary unit character <code>i</code> is excluded from the
counting for width and padding. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~p</code><var><a name="index-g_t_0040code_007b_007ep_007d-3557"></a></var><br>
<blockquote><p>Plural.  No parameters.

        <p>Output nothing if the argument is 1, or &lsquo;<samp><span class="samp">s</span></samp>&rsquo; for any other
value.

     <pre class="example">          (format #t "enter name~p" 1) -| enter name
          (format #t "enter name~p" 2) -| enter names
</pre>
        <p><code>~@p</code> prints &lsquo;<samp><span class="samp">y</span></samp>&rsquo; for 1 or &lsquo;<samp><span class="samp">ies</span></samp>&rsquo; otherwise.

     <pre class="example">          (format #t "pupp~@p" 1) -| puppy
          (format #t "pupp~@p" 2) -| puppies
</pre>
        <p><code>~:p</code> re-uses the preceding argument instead of taking a new
one, which can be convenient when printing some sort of count.

     <pre class="example">          (format #t "~d cat~:p" 9)   -| 9 cats
          (format #t "~d pupp~:@p" 5) -| 5 puppies
</pre>
        <p><code>~p</code> is designed for English plurals and there's no attempt to
support other languages.  <code>~[</code> conditionals (below) may be able to
help.  When using <code>gettext</code> to translate messages <code>ngettext</code>
is probably best though. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~y</code><var><a name="index-g_t_0040code_007b_007ey_007d-3558"></a></var><br>
<blockquote><p>Pretty print.  No parameters.

        <p>Output an argument with <code>pretty-print</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~?</code><var><a name="index-g_t_0040code_007b_007e_003f_007d-3559"></a></var><br>
&mdash; Escape: <code>~k</code><var><a name="index-g_t_0040code_007b_007ek_007d-3560"></a></var><br>
<blockquote><p>Sub-format.  No parameters.

        <p>Take a format string argument and a second argument which is a list of
arguments for that string, and output the result.

     <pre class="example">          (format #t "~?" "~d ~d" '(1 2))    -| 1 2
</pre>
        <p><code>~@?</code> takes arguments for the sub-format directly rather than
in a list.

     <pre class="example">          (format #t "~@? ~s" "~d ~d" 1 2 "foo") -| 1 2 "foo"
</pre>
        <p><code>~?</code> and <code>~k</code> are the same, <code>~k</code> is provided for
T-Scheme compatibility. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~*</code><var><a name="index-g_t_0040code_007b_007e_002a_007d-3561"></a></var><br>
<blockquote><p>Argument jumping.  Parameter: <var>N</var>.

        <p>Move forward <var>N</var> arguments (default 1) in the argument list. 
<code>~:*</code> moves backwards.  (<var>N</var> cannot be negative.)

     <pre class="example">          (format #f "~d ~2*~d" 1 2 3 4) &rArr; "1 4"
          (format #f "~d ~:*~d" 6)       &rArr; "6 6"
</pre>
        <p><code>~@*</code> moves to argument number <var>N</var>.  The first argument is
number 0 (and that's the default for <var>N</var>).

     <pre class="example">          (format #f "~d~d again ~@*~d~d" 1 2) &rArr; "12 again 12"
          (format #f "~d~d~d ~1@*~d~d" 1 2 3)  &rArr; "123 23"
</pre>
        <p>A <code>#</code> move to the end followed by a <code>:</code> modifier move
back can be used for an absolute position relative to the end of the
argument list, a reverse of what the <code>@</code> modifier does.

     <pre class="example">          (format #t "~#*~2:*~a" 'a 'b 'c 'd)   -| c
</pre>
        <p>At the end of the format string the current argument postion doesn't
matter, any further arguments are ignored. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~t</code><var><a name="index-g_t_0040code_007b_007et_007d-3562"></a></var><br>
<blockquote><p>Advance to a column position.  Parameters: <var>colnum</var>, <var>colinc</var>,
<var>padchar</var>.

        <p>Output <var>padchar</var> (space by default) to move to the given
<var>colnum</var> column.  The start of the line is column 0, the default
for <var>colnum</var> is 1.

     <pre class="example">          (format #f "~tX")  &rArr; " X"
          (format #f "~3tX") &rArr; "   X"
</pre>
        <p>If the current column is already past <var>colnum</var>, then the move is
to there plus a multiple of <var>colinc</var>, ie. column
<var>colnum</var> + <var>N</var> * <var>colinc</var> for the smallest <var>N</var>
which makes that value greater than or equal to the current column. 
The default <var>colinc</var> is 1 (which means no further move).

     <pre class="example">          (format #f "abcd~2,5,'.tx") &rArr; "abcd...x"
</pre>
        <p><code>~@t</code> takes <var>colnum</var> as an offset from the current column. 
<var>colnum</var> many pad characters are output, then further padding to
make the current column a multiple of <var>colinc</var>, if it isn't
already so.

     <pre class="example">          (format #f "a~3,5'*@tx") &rArr; "a****x"
</pre>
        <p><code>~t</code> is implemented using <code>port-column</code>, so it works even
there has been other output before <code>format</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~~</code><var><a name="index-g_t_0040code_007b_007e_007e_007d-3563"></a></var><br>
<blockquote><p>Tilde character.  Parameter: <var>n</var>.

        <p>Output a tilde character <code>~</code>, or <var>n</var> many if a parameter is
given.  Normally <code>~</code> introduces an escape sequence, <code>~~</code>
is the way to output a literal tilde. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~%</code><var><a name="index-g_t_0040code_007b_007e_0025_007d-3564"></a></var><br>
<blockquote><p>Newline.  Parameter: <var>n</var>.

        <p>Output a newline character, or <var>n</var> many if a parameter is given. 
A newline (or a few newlines) can of course be output just by
including them in the format string. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~&amp;</code><var><a name="index-g_t_0040code_007b_007e_0026_007d-3565"></a></var><br>
<blockquote><p>Start a new line.  Parameter: <var>n</var>.

        <p>Output a newline if not already at the start of a line.  With a
parameter, output that many newlines, but with the first only if not
already at the start of a line.  So for instance 3 would be a newline
if not already at the start of a line, and 2 further newlines. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~_</code><var><a name="index-g_t_0040code_007b_007e_005f_007d-3566"></a></var><br>
<blockquote><p>Space character.  Parameter: <var>n</var>.

     <!-- For reference, in Common Lisp ~_ is a conditional newline, but -->
     <!-- slib fmtdoc.txi described it as a space, so we keep that. -->
        <p>Output a space character, or <var>n</var> many if a parameter is given.

        <p>With a variable parameter this is one way to insert runtime calculated
padding (<code>~t</code> or the various field widths can do similar
things).

     <pre class="example">          (format #f "~v_foo" 4) &rArr; "    foo"
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Escape: <code>~/</code><var><a name="index-g_t_0040code_007b_007e_002f_007d-3567"></a></var><br>
<blockquote><p>Tab character.  Parameter: <var>n</var>.

        <p>Output a tab character, or <var>n</var> many if a parameter is given. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~|</code><var><a name="index-g_t_0040code_007b_007e_007c_007d-3568"></a></var><br>
<blockquote><p>Formfeed character.  Parameter: <var>n</var>.

        <p>Output a formfeed character, or <var>n</var> many if a parameter is given. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~!</code><var><a name="index-g_t_0040code_007b_007e_0021_007d-3569"></a></var><br>
<blockquote><p>Force output.  No parameters.

        <p>At the end of output, call <code>force-output</code> to flush any buffers on
the destination.  <code>~!</code> can occur anywhere in the format string, but
the force is done at the end of output.

        <p>When output is to a string (destination <code>#f</code>), <code>~!</code> does
nothing. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <code>~newline</code><var><a name="index-g_t_0040code_007b_007enewline_007d-3570"></a></var><br>
<blockquote><!-- (ie.@: newline character) -->
        <p>Continuation line.  No parameters.

        <p>Skip this newline and any following whitespace in the format string,
ie. don't send it to the output.  This can be used to break up a
long format string for readability, but not print the extra
whitespace.

     <pre class="example">          (format #f "abc~
                      ~d def~
                      ~d" 1 2) &rArr; "abc1 def2"
</pre>
        <p><code>~:newline</code> skips the newline but leaves any further whitespace
to be printed normally.

        <p><code>~@newline</code> prints the newline then skips following
whitespace. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <b>~( ~)</b><var><a name="index-g_t_007e_0028-_007e_0029-3571"></a></var><br>
<blockquote><p>Case conversion.  No parameters.

        <p>Between <code>~(</code> and <code>~)</code> the case of all output is changed. 
The modifiers on <code>~(</code> control the conversion.

          <ul>
<li><code>~(</code>
Lower case. 
<!-- FIXME: The : and @ modifiers are not yet documented because the -->
<!-- code applies string-capitalize and string-capitalize-first to each -->
<!-- separate format:out-str call, which has various subtly doubtful -->
<!-- effects.  And worse they're applied to individual characters, -->
<!-- including literal characters in the format string, which has the -->
<!-- silly effect of being always an upcase. -->
<!-- The Common Lisp spec is apparently for the capitalization to be -->
<!-- applied in one hit to the whole of the output between ~( and ~). -->
<!-- (This can no doubt be implemented without accumulating all that -->
<!-- text, just by keeping a state or the previous char to tell whether -->
<!-- within a word.) -->
<!-- @deffn Escape -->
<!-- @code{:} - first letter of each word upper case, the rest lower -->
<!-- case, as per the @code{string-capitalize} function (@pxref{Alphabetic -->
<!-- Case Mapping}). -->
<!-- @deffn Escape -->
<!-- @code{@@} - first letter of just the first word upper case, the -->
<!-- rest lower case. -->
<li><code>~:@(</code>
Upper case. 
</ul>

        <p>For example,

     <pre class="example">          (format #t "~(Hello~)")   -| hello
          (format #t "~:@(Hello~)") -| HELLO
</pre>
        <p>In the future it's intended the modifiers <code>:</code> and <code>@</code>
alone will capitalize the first letters of words, as per Common Lisp
<code>format</code>, but the current implementation of this is flawed and
not recommended for use.

        <p>Case conversions do not nest, currently.  This might change in the
future, but if it does then it will be to Common Lisp style where the
outermost conversion has priority, overriding inner ones (making those
fairly pointless). 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <b>~</b><var>{ ~}<a name="index-g_t_007e-3572"></a></var><br>
<blockquote><p>Iteration.  Parameter: <var>maxreps</var> (for <code>~{</code>).

        <p>The format between <code>~{</code> and <code>~}</code> is iterated.  The
modifiers to <code>~{</code> determine how arguments are taken.  The
default is a list argument with each iteration successively consuming
elements from it.  This is a convenient way to output a whole list.

     <pre class="example">          (format #t "~{~d~}"     '(1 2 3))       -| 123
          (format #t "~{~s=~d ~}" '("x" 1 "y" 2)) -| "x"=1 "y"=2
</pre>
        <p><code>~:{</code> takes a single argument which is a list of lists, each
of those contained lists gives the arguments for the iterated format.

     <!-- @print{} on a new line here to avoid overflowing page width in DVI -->
     <pre class="example">          (format #t "~:{~dx~d ~}" '((1 2) (3 4) (5 6)))
          -| 1x2 3x4 5x6
</pre>
        <p><code>~@{</code> takes arguments directly, with each iteration
successively consuming arguments.

     <pre class="example">          (format #t "~@{~d~}"     1 2 3)       -| 123
          (format #t "~@{~s=~d ~}" "x" 1 "y" 2) -| "x"=1 "y"=2
</pre>
        <p><code>~:@{</code> takes list arguments, one argument for each iteration,
using that list for the format.

     <!-- @print{} on a new line here to avoid overflowing page width in DVI -->
     <pre class="example">          (format #t "~:@{~dx~d ~}" '(1 2) '(3 4) '(5 6))
          -| 1x2 3x4 5x6
</pre>
        <p>Iterating stops when there are no more arguments or when the
<var>maxreps</var> parameter to <code>~{</code> is reached (default no
maximum).

     <pre class="example">          (format #t "~2{~d~}" '(1 2 3 4)) -| 12
</pre>
        <p>If the format between <code>~{</code> and <code>~}</code> is empty, then a
format string argument is taken (before iteration argument(s)) and
used instead.  This allows a sub-format (like <code>~?</code> above) to be
iterated.

     <pre class="example">          (format #t "~{~}" "~d" '(1 2 3)) -| 123
</pre>
        <!-- FIXME: What is the @code{:} modifier to ~} meant to do?  The -->
     <!-- Common Lisp spec says it's a minimum of 1 iteration, but the -->
     <!-- format.scm code seems to merely make it have MAXREPS default to 1. -->
        <p>Iterations can be nested, an inner iteration operates in the same way
as described, but of course on the arguments the outer iteration
provides it.  This can be used to work into nested list structures. 
For example in the following the inner <code>~{~d~}x</code> is applied
to <code>(1 2)</code> then <code>(3 4 5)</code> etc.

     <pre class="example">          (format #t "~{~{~d~}x~}" '((1 2) (3 4 5))) -| 12x345x
</pre>
        <p>See also <code>~^</code> below for escaping from iteration. 
</p></blockquote></div>

<div class="defun">
&mdash; Escape: <b>~[ ~; ~]</b><var><a name="index-g_t_007e_005b-_007e_003b-_007e_005d-3573"></a></var><br>
<blockquote><p>Conditional.  Parameter: <var>selector</var>.

        <p>A conditional block is delimited by <code>~[</code> and <code>~]</code>, and
<code>~;</code> separates clauses within the block.  <code>~[</code> takes an
integer argument and that number clause is used.  The first clause is
number 0.

     <pre class="example">          (format #f "~[peach~;banana~;mango~]" 1)  &rArr; "banana"
</pre>
        <p>The <var>selector</var> parameter can be used for the clause number,
instead of taking an argument.

     <pre class="example">          (format #f "~2[peach~;banana~;mango~]") &rArr; "mango"
</pre>
        <p>If the clause number is out of range then nothing is output.  Or the
last clause can be <code>~:;</code> to use that for a number out of range.

     <pre class="example">          (format #f "~[banana~;mango~]"         99) &rArr; ""
          (format #f "~[banana~;mango~:;fruit~]" 99) &rArr; "fruit"
</pre>
        <p><code>~:[</code> treats the argument as a flag, and expects two clauses. 
The first is used if the argument is <code>#f</code> or the second
otherwise.

     <pre class="example">          (format #f "~:[false~;not false~]" #f)   &rArr; "false"
          (format #f "~:[false~;not false~]" 'abc) &rArr; "not false"
          
          (let ((n 3))
            (format #t "~d gnu~:[s are~; is~] here" n (= 1 n)))
          -| 3 gnus are here
</pre>
        <p><code>~@[</code> also treats the argument as a flag, and expects one
clause.  If the argument is <code>#f</code> then no output is produced and
the argument is consumed, otherwise the clause is used and the
argument is not consumed, it's left for the clause.  This can be used
for instance to suppress output if <code>#f</code> means something not
available.

     <pre class="example">          (format #f "~@[temperature=~d~]" 27) &rArr; "temperature=27"
          (format #f "~@[temperature=~d~]" #f) &rArr; ""
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Escape: <code>~^</code><var><a name="index-g_t_0040code_007b_007e_005e_007d-3574"></a></var><br>
<blockquote><p>Escape.  Parameters: <var>val1</var>, <var>val2</var>, <var>val3</var>.

        <p>Stop formatting if there are no more arguments.  This can be used for
instance to have a format string adapt to a variable number of
arguments.

     <pre class="example">          (format #t "~d~^ ~d" 1)   -| 1
          (format #t "~d~^ ~d" 1 2) -| 1 2
</pre>
        <p>Within a <code>~{</code> <code>~}</code> iteration, <code>~^</code> stops the
current iteration step if there are no more arguments to that step,
but continuing with possible further steps and the rest of the format. 
This can be used for instance to avoid a separator on the last
iteration, or to adapt to variable length argument lists.

     <pre class="example">          (format #f "~{~d~^/~} go"    '(1 2 3))     &rArr; "1/2/3 go"
          (format #f "~:{ ~d~^~d~} go" '((1) (2 3))) &rArr; " 1 23 go"
</pre>
        <!-- For reference, format.scm doesn't implement that Common Lisp ~:^ -->
     <!-- modifier which stops the entire iterating of ~:{ or ~@:{. -->
     <!-- FIXME: Believe the Common Lisp spec is for ~^ within ~[ ~] -->
     <!-- conditional to terminate the whole format (or iteration step if in -->
     <!-- an iteration).  But format.scm seems to terminate just the -->
     <!-- conditional form. -->
     <!-- (format #f "~[abc~^def~;ghi~] blah" 0) -->
     <!-- @result{} "abc blah"                    ;; looks wrong -->
     <!-- FIXME: Believe the Common Lisp spec is for ~^ within ~( ~) to end -->
     <!-- that case conversion and then also terminate the whole format (or -->
     <!-- iteration step if in an iteration).  But format.scm doesn't seem -->
     <!-- to do that quite right. -->
     <!-- (format #f "~d ~^ ~d" 1)      @result{} "1 " -->
     <!-- (format #f "~(~d ~^ ~d~)" 1)  @result{} ERROR -->
        <p>Within a <code>~?</code> sub-format, <code>~^</code> operates just on that
sub-format.  If it terminates the sub-format then the originating
format will still continue.

     <pre class="example">          (format #t "~? items" "~d~^ ~d" '(1))   -| 1 items
          (format #t "~? items" "~d~^ ~d" '(1 2)) -| 1 2 items
</pre>
        <p>The parameters to <code>~^</code> (which are numbers) change the condition
used to terminate.  For a single parameter, termination is when that
value is zero (notice this makes plain <code>~^</code> equivalent to
<code>~#^</code>).  For two parameters, termination is when those two are
equal.  For three parameters, termination is when <var>val1</var> &lt;=
<var>val2</var> and <var>val2</var> &lt;= <var>val3</var>. 
</p></blockquote></div>

<!-- FIXME: Good examples of these? -->
   <p>It's an error if there are not enough arguments for the escapes in the
format string, but any excess arguments are ignored.

   <p>Iterations <code>~{</code> <code>~}</code> and conditionals <code>~[</code>
<code>~;</code> <code>~]</code> can be nested, but must be properly nested,
meaning the inner form must be entirely within the outer form.  So
it's not possible, for instance, to try to conditionalize the endpoint
of an iteration.

<pre class="example">     (format #t "~{ ~[ ... ~] ~}" ...)       ;; good
     (format #t "~{ ~[ ... ~} ... ~]" ...)   ;; bad
</pre>
   <p>The same applies to case conversions <code>~(</code> <code>~)</code>, they
must properly nest with respect to iterations and conditionals (though
currently a case conversion cannot nest within another case
conversion).

   <p>When a sub-format (<code>~?</code>) is used, that sub-format string must
be self-contained.  It cannot for instance give a <code>~{</code> to
begin an iteration form and have the <code>~}</code> up in the
originating format, or similar.

<!-- end of file -->
   </body></html>

