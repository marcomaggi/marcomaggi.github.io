<html lang="en">
<head>
<title>silex semantics rules - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="silex-semantics.html#silex-semantics" title="silex semantics">
<link rel="prev" href="silex-semantics-action.html#silex-semantics-action" title="silex semantics action">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d12 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008-2011 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="silex-semantics-rules"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="silex-semantics-action.html#silex-semantics-action">silex semantics action</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="silex-semantics.html#silex-semantics">silex semantics</a>
<hr>
</div>

<h4 class="subsection">74.6.2 Matching the rules</h4>

<p>All lexical analysers generated by <code>(nausicaa parser-tools silex)</code>
are interactive.  That is, they read as few characters as possible to
get the longest match.  This is a useful property when the input is
coming from a terminal.  A lexical analyser is normally based on a
finite automaton; it is the case for the analysers generated by
<code>(nausicaa parser-tools silex)</code>.  A non&ndash;interactive analyser
always needs an extra character to provoke an invalid transition in the
automaton.  The longest match is detected this way.  With an interactive
analyser, an extra character is not required when it is impossible to
obtain a longer match.

   <p>A lexical analyser generated by <code>(nausicaa parser-tools silex)</code>
does not impose any <i>a priori</i> limit on the size of the lexemes.  The
internal buffer is extended each time it is necessary.

   <p>Each time the analyser is asked to return a token, it tries to match a
prefix of the input with a pattern.  There may be more than one possible
match; when it is the case, we say there is a conflict.  For example,
suppose we have those regular expressions:

<pre class="example">     begin
     [a-z]*
</pre>
   <p class="noindent">and the input is &lsquo;<samp><span class="samp">beginning1 ...</span></samp>&rsquo;.  We have a match with
the first expression and we have many different matches with the second. 
To resolve such a conflict, the longest match is chosen.  So the chosen
match is the one between the lexeme &lsquo;<samp><span class="samp">beginning</span></samp>&rsquo; and the second
pattern.

   <p>Suppose we have the same regular expressions but the input is
&lsquo;<samp><span class="samp">begin+ ...</span></samp>&rsquo;.  We have <em>two</em> longest match.  This
conflict is resolved by choosing the first pattern that allows a longest
match.  So the chosen match is between the lexeme &lsquo;<samp><span class="samp">begin</span></samp>&rsquo; and the
first pattern.

   <p>The analyser generated by <code>(nausicaa parser-tools silex)</code> allows
the empty lexeme to be matched if there is no longer match.  However, we
should take care not to call the analyser again without consuming at
least one character of the input: It would cause an infinite loop.

   <p>The pattern &lsquo;<samp><span class="samp">&lt;&lt;EOF&gt;&gt;</span></samp>&rsquo; is matched when the analyser is called and
the input system is at end of input.  In this situation, the marker is
matched even if there is a pattern that matches the empty lexeme.  The
analyser can be called again and again and the &lsquo;<samp><span class="samp">&lt;&lt;EOF&gt;&gt;</span></samp>&rsquo; pattern
will be matched each time, causing its corresponding action to be
evaluated each time, too.

   <p>The pattern &lsquo;<samp><span class="samp">&lt;&lt;ERROR&gt;&gt;</span></samp>&rsquo; is matched when the input system is not at
end of input and no other match is possible.  Depending on the action
associated with this pattern, our program may choose to stop or choose
to try to recover from the error.  To recover from the error, our
program has to read some characters from the input before it can call
the analyser again.

   <p>As example of error recovery consider the following code which just
shows the mechanism:

<pre class="example">     #!r6rs
     (import (nausicaa)
       (prefix (nausicaa parser-tools lexical-tokens) pt.)
       (prefix (nausicaa parser-tools silex) lex.)
       (prefix (nausicaa parser-tools silex lexer) lex.))
     
     (define description "%%
     A          (make &lt;lexical-token&gt;
                  (category: 'A)
                  (location: (make* &lt;source-location&gt;
                               #f yyline yycolumn yyoffset))
                  (value: yytext)
                  (length: (string-length yytext)))
     
     &lt;&lt;EOF&gt;&gt;    (make &lt;lexical-token&gt;
                  (category: '*eoi*)
                  (location: (make* &lt;source-location&gt;
                               #f yyline yycolumn yyoffset))
                  (value: (eof-object))
                  (length: 1))
     
     &lt;&lt;ERROR&gt;&gt;  (make &lt;lexical-token&gt;
                  (category: '*lexer-error*)
                  (location: (make* &lt;source-location&gt;
                               #f yyline yycolumn yyoffset))
                  (value: yytext)
                  (length: (string-length yytext)))
     ")
     
     (define table
       (lex.lex
         (lex.input-string: description)
         (lex.counters: 'all)
         (lex.library-language: '(nausicaa))
         (lex.library-imports:
           '((nausicaa parser-tools lexical-token)
             (nausicaa parser-tools source-location)))
         (lex.output-value: #t)
         (lex.lexer-format: 'decision-tree)))
     
     ;; correct string
     (let* ((IS      (lex.make-IS (lex.string: "AAA")
                                  (lex.counters: 'all)))
            (lexer (lex.make-lexer table IS)))
       (let (((T1 pt.&lt;lexical-token&gt;) (lexer))
             ((T2 pt.&lt;lexical-token&gt;) (lexer))
             ((T3 pt.&lt;lexical-token&gt;) (lexer))
             ((T4 pt.&lt;lexical-token&gt;) (lexer)))
         (list T1.category T2.category
               T3.category T4.category)))
     &rArr; (A A A *eoi*)
     
     ;; lexer error
     (let* ((IS      (lex.make-IS (lex.string: "AAAB")
                                  (lex.counters: 'all)))
            (lexer (lex.make-lexer table IS)))
       (let (((T1 pt.&lt;lexical-token&gt;) (lexer))
             ((T2 pt.&lt;lexical-token&gt;) (lexer))
             ((T3 pt.&lt;lexical-token&gt;) (lexer))
             ((T4 pt.&lt;lexical-token&gt;) (lexer)))
         (list T1.category T2.category
               T3.category T4.category)))
     &rArr; (A A A *lexer-error*)
     
     ;; lexer error and recovery
     (let* ((IS        (lex.make-IS (lex.string: "AAABBAA")
                       (lex.counters: 'all)))
            (lexer (lex.make-lexer table IS)))
       (let (((T1 pt.&lt;lexical-token&gt;) (lexer))
             ((T2 pt.&lt;lexical-token&gt;) (lexer))
             ((T3 pt.&lt;lexical-token&gt;) (lexer))
             ((T4 pt.&lt;lexical-token&gt;) (lexer)))
         ;; discard invalid characters,
         ;; we know there are 2 of them
         (let ((getc (lex.lexer-get-func-getc IS)))
           (getc)
           (getc))
         (let (((T5 pt.&lt;lexical-token&gt;) (lexer))
               ((T6 pt.&lt;lexical-token&gt;) (lexer))
               ((T7 pt.&lt;lexical-token&gt;) (lexer)))
           (list T1.category T2.category T3.category
                 T4.category
                 T5.category T6.category T7.category))))
     &rArr; (A A A *lexer-error* A A *eoi*)
</pre>
   <!-- page -->
   </body></html>

