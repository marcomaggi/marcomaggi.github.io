<html lang="en">
<head>
<title>parser-tools uri parser basic - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="parser_002dtools-uri-parser.html#parser_002dtools-uri-parser" title="parser-tools uri parser">
<link rel="next" href="parser_002dtools-uri-parser-authority.html#parser_002dtools-uri-parser-authority" title="parser-tools uri parser authority">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d7 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="parser-tools-uri-parser-basic"></a>
<a name="parser_002dtools-uri-parser-basic"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="parser_002dtools-uri-parser-authority.html#parser_002dtools-uri-parser-authority">parser-tools uri parser authority</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="parser_002dtools-uri-parser.html#parser_002dtools-uri-parser">parser-tools uri parser</a>
<hr>
</div>

<h5 class="subsubsection">12.5.4.1 Basic component parser functions</h5>

<p>The following functions will parse the elements of a <acronym>URI</acronym>; all of them
accept a <var>port</var> argument: it must be a binary input port supporting
the port position.  The following bindings are exported by the library
<code>(nausicaa parser-tools uri)</code>.

<div class="defun">
&mdash; Function: <b>parse-scheme</b><var> port<a name="index-parse_002dscheme-1957"></a></var><br>
<blockquote><p>Accumulate bytes from <var>port</var> while they are valid for the
<code>scheme</code> component.  If a colon is found: return a bytevector
holding the accumulated bytes, colon excluded; else return <code>#f</code>.

        <p>When successful: leave the port position referencing the byte after the
one representing the colon; if an error occurs: rewind the port position
to the one before this function call.

     <pre class="example">          (import (vicare)
            (prefix (nausicaa parser-tools uri) uri.))
          
          (define (mkport S)
            (open-bytevector-input-port (string-&gt;ascii S)))
          
          (define (doit S)
            (cond ((uri.parse-scheme (mkport S))
                   =&gt; ascii-&gt;string)
                  (else #f)))
          
          (doit "")               &rArr; #f
          (doit "hello")          &rArr; #f
          (doit "hel/lo:")        &rArr; #f
          
          (let ((P (mkport "http://ciao")))
            (ascii-&gt;string (uri.parse-scheme P))      &rArr; "http"
            (ascii-&gt;string (get-bytevector-some P)))  &rArr; "//ciao"
          
          (let ((P (mkport "A123+-.://ciao")))
            (ascii-&gt;string (uri.parse-scheme P))      &rArr; "A123+-."
            (ascii-&gt;string (get-bytevector-some P)))  &rArr; "//ciao"
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: <b>parse-hier-part</b><var> port<a name="index-parse_002dhier_002dpart-1958"></a></var><br>
<blockquote><p>Read bytes from <var>port</var> expecting to get, from the first byte a
<code>hier-part</code> component; parse the input decomposing it into its
subcomponents.

        <p>The relevant section of grammar from <acronym>RFC</acronym> 3986 follows:

     <pre class="example">          hier-part     = "//" authority path-abempty
                        / path-absolute
                        / path-rootless
                        / path-empty
</pre>
        <p>Return 3 values:

          <ol type=1 start=1>
<li><code>#f</code> or a possibly empty bytevector representing the
<code>authority</code> subcomponent.  When the authority is unspecified the
return value is <code>#f</code>.

          <li>A symbol specifying the type of path subcomponent: <code>path-abempty</code>,
<code>path-absolute</code>, <code>path-rootless</code>, <code>path-empty</code>.  When the
<code>authority</code> is specified: the type is always <code>path-abempty</code>.

          <li>Null or a list of bytevectors representing the path segments.
             </ol>

        <p>This function does not decode the percent&ndash;encoded bytes.

     <pre class="example">          #!vicare
          (import (vicare)
            (prefix (nausicaa parser-tools uri) uri.))
          
          (define (mkport S)
            (open-bytevector-input-port (string-&gt;ascii S)))
          
          (define (f1 str)
            (let*-values
                (((P) (mkport str))
                 ((authority path.type path.segments)
                  (uri.parse-hier-part P))
                 ((E) (eof-object? (lookahead-u8 P))))
              (values (and authority (ascii-&gt;string authority))
                      path.type (map ascii-&gt;string path.segments)
                      E)))
          
          (define (f2 str)
            (let*-values
                (((P) (mkport str))
                 ((authority path.type path.segments)
                  (uri.parse-hier-part P))
                 ((Q) (ascii-&gt;string (get-bytevector-all P))))
              (values (and authority (ascii-&gt;string authority))
                      path.type (map ascii-&gt;string path.segments)
                      Q)))
          
          ;;; specified authority, empty path
          
          (f1 "")
          &rArr; #f 'path-empty '() #t
          
          (f1 "//")
          &rArr; "" 'path-abempty '() #t
          
          (f1 "//ciao.it")
          &rArr; "ciao.it" 'path-abempty '() #t
          
          (f1 "//ciao.it/salut")
          &rArr; "ciao.it" 'path-abempty '("salut") #t
          
          ;;; unspecified authority, absolute path
          
          (f1 "/")
          &rArr; #f 'path-absolute '() #t
          
          (f1 "/ciao")
          &rArr; #f 'path-absolute '("ciao") #t
          
          (f1 "/ciao/salut")
          &rArr; #f 'path-absolute '("ciao" "salut") #t
          
          ;;; unspecified authority, rootless path
          
          (f1 ".")
          &rArr; #f 'path-rootless '(".") #t
          
          (f1 "ciao")
          &rArr; #f 'path-rootless '("ciao") #t
          
          (f1 "ciao/salut")
          &rArr; #f 'path-rootless '("ciao" "salut") #t
          
          ;;; specified authority, query
          
          (f2 "///?query")
          &rArr; "" 'path-abempty '("") "?query"
          
          (f2 "//ciao.it/salut?query")
          &rArr; "ciao.it" 'path-abempty '("salut") "?query"
          
          (f2 "//ciao.it?query")
          &rArr; "ciao.it" 'path-abempty '() "?query"
          
          (f2 "//?query")
          &rArr; "" 'path-abempty '() "?query"
          
          ;;; unspecified authority, query
          
          (f2 "/?query")
          &rArr; #f 'path-absolute '("") "?query"
          
          (f2 "/ciao?query")
          &rArr; #f 'path-absolute '("ciao") "?query"
          
          (f2 "/ciao/salut?query")
          &rArr; #f 'path-absolute '("ciao" "salut") "?query"
          
          (f2 "ciao?query")
          &rArr; #f 'path-rootless '("ciao") "?query"
          
          (f2 "ciao/salut/?query")
          &rArr; #f 'path-rootless '("ciao" "salut" "") "?query"
          
          (f2 "?query")
          &rArr; #f 'path-empty '() "?query"
          
          (f2 ".?query")
          &rArr; #f 'path-rootless '(".") "?query"
          
          (f2 "..?query")
          &rArr; #f 'path-rootless '("..") "?query"
          
          (f2 "./?query")
          &rArr; #f 'path-rootless '("." "") "?query"
          
          (f2 "./.?query")
          &rArr; #f 'path-rootless '("." ".") "?query"
          
          ;;; specified authority, fragment
          
          (f2 "///#fragment")
          &rArr; "" 'path-abempty '("") "#fragment"
          
          (f2 "//ciao.it/salut#fragment")
          &rArr; "ciao.it" 'path-abempty '("salut") "#fragment"
          
          (f2 "//ciao.it#fragment")
          &rArr; "ciao.it" 'path-abempty '() "#fragment"
          
          (f2 "//#fragment")
          &rArr; "" 'path-abempty '() "#fragment"
          
          ;;; unspecified authority, fragment
          
          (f2 "/#fragment")
          &rArr; #f 'path-absolute '("") "#fragment"
          
          (f2 "/ciao#fragment")
          &rArr; #f 'path-absolute '("ciao") "#fragment"
          
          (f2 "/ciao/salut#fragment")
          &rArr; #f 'path-absolute '("ciao" "salut") "#fragment"
          
          (f2 "/ciao/salut/#fragment")
          &rArr; #f 'path-absolute '("ciao" "salut" "") "#fragment"
          
          (f2 "ciao#fragment")
          &rArr; #f 'path-rootless '("ciao") "#fragment"
          
          (f2 "ciao/salut/#fragment")
          &rArr; #f 'path-rootless '("ciao" "salut" "") "#fragment"
          
          (f2 "#fragment")
          &rArr; #f 'path-empty '() "#fragment"
          
          (f2 ".#fragment")
          &rArr; #f 'path-rootless '(".") "#fragment"
          
          (f2 "..#fragment")
          &rArr; #f 'path-rootless '("..") "#fragment"
          
          (f2 "./#fragment")
          &rArr; #f 'path-rootless '("." "") "#fragment"
          
          (f2 "./.#fragment")
          &rArr; #f 'path-rootless '("." ".") "#fragment"
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: <b>parse-relative-part</b><var> port<a name="index-parse_002drelative_002dpart-1959"></a></var><br>
<blockquote><p>Read bytes from <var>port</var> expecting to get, from the first byte a
<code>relative-part</code> component; parse the input decomposing it into its
subcomponents.

        <p>This function works like <code>parse-hier-part</code> with the following
exception: rather than returning paths of type <code>path-rootless</code>, it
returns paths of type <code>path-noscheme</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>parse-query</b><var> port<a name="index-parse_002dquery-1960"></a></var><br>
<blockquote><p>Accumulate bytes from <var>port</var> while they are valid for a <code>query</code>
<acronym>URI</acronym> component; the first byte read from <var>port</var> must be a question
mark.  If, after the question mark and possibly other bytes, <acronym>EOF</acronym> or a
number&ndash;sign (&lsquo;<samp><span class="samp">#</span></samp>&rsquo;) is read: return a bytevector holding the
accumulated bytes, starting question mark excluded and ending
number&ndash;sign excluded.  If <acronym>EOF</acronym> is read first or a byte different from
a question mark is read first: return <code>#f</code>.

        <p>If successful: leave the port position to the byte after the last byte
of the <code>query</code> component; if an error occurs: rewind the port
position to the one before this function call.

        <p>Notice that an empty <code>query</code> component is valid (a question mark
followed by <acronym>EOF</acronym>).

     <pre class="example">          #!vicare
          (import (vicare)
            (prefix (nausicaa parser-tools uri) uri.))
          
          (define (mkport S)
            (open-bytevector-input-port (string-&gt;ascii S)))
          
          (uri.parse-query (mkport ""))           &rArr; #f
          (uri.parse-query (mkport "hello"))      &rArr; #f
          (uri.parse-query (mkport "#hello"))     &rArr; #f
          
          (ascii-&gt;string
           (uri.parse-query (mkport "?")))
          &rArr; ""
          
          (ascii-&gt;string
           (uri.parse-query (mkport "?the-query???")))
          &rArr; "the-query???"
          
          (let ((P (mkport "?ciao%3dciao#fragment")))
            (ascii-&gt;string (uri.parse-query P))       &rArr; "ciao%3dciao"
            (ascii-&gt;string (get-bytevector-some P)))  &rArr; "#fragment"
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: <b>parse-fragment</b><var> port<a name="index-parse_002dfragment-1961"></a></var><br>
<blockquote><p>Accumulate bytes from <var>port</var> while they are valid for a
<code>fragment</code> component; the first byte read from <var>port</var> must be a
number&ndash;sign.  If, after the number&ndash;sign and possibly other bytes are
read, <acronym>EOF</acronym> is read: return a bytevector holding the accumulated bytes,
starting number&ndash;sign excluded.  If the first byte is not a number&ndash;sign
or <acronym>EOF</acronym> is read first: return <code>#f</code>.

        <p>If successful: leave the port position to the byte after the last byte
of the <code>fragment</code> component; if an error occurs: rewind the port
position to the one before this function call.

        <p>Notice that an empty <code>fragment</code> component is valid (a number&ndash;sign
followed by <acronym>EOF</acronym>).

     <pre class="example">          (import (vicare)
            (prefix (nausicaa parser-tools uri) uri.))
          
          (define (mkport S)
            (open-bytevector-input-port (string-&gt;ascii S)))
          
          (uri.parse-fragment (mkport ""))         &rArr; #f
          (uri.parse-fragment (mkport "#hello#"))  &rArr; #f
          (uri.parse-fragment (mkport "hello"))    &rArr; #f
          (uri.parse-fragment (mkport "?hello"))   &rArr; #f
          
          (ascii-&gt;string
           (uri.parse-fragment (mkport "#")))
          &rArr; ""
          
          (ascii-&gt;string
           (uri.parse-fragment (mkport "#fragment???")))
          &rArr; "fragment???"
          
          (ascii-&gt;string
           (uri.parse-fragment (mkport "#ciao%3dciao")))
          &rArr; "ciao%3dciao"
</pre>
        </blockquote></div>

<!-- page -->
   </body></html>

