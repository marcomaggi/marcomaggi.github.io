<html lang="en">
<head>
<title>stdlib syntax-case parsing - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="stdlib-syntax_002dcase.html#stdlib-syntax_002dcase" title="stdlib syntax-case">
<link rel="prev" href="stdlib-syntax_002dcase-transformers.html#stdlib-syntax_002dcase-transformers" title="stdlib syntax-case transformers">
<link rel="next" href="stdlib-syntax_002dcase-identifier.html#stdlib-syntax_002dcase-identifier" title="stdlib syntax-case identifier">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d7 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="stdlib-syntax-case-parsing"></a>
<a name="stdlib-syntax_002dcase-parsing"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="stdlib-syntax_002dcase-identifier.html#stdlib-syntax_002dcase-identifier">stdlib syntax-case identifier</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="stdlib-syntax_002dcase-transformers.html#stdlib-syntax_002dcase-transformers">stdlib syntax-case transformers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="stdlib-syntax_002dcase.html#stdlib-syntax_002dcase">stdlib syntax-case</a>
<hr>
</div>

<h4 class="subsection">4.12.5 Parsing input and producing output</h4>

<p>Transformers can destructure their input with <code>syntax-case</code> and
rebuild their output with <code>syntax</code>.

<div class="defun">
&mdash; Syntax: <b>syntax-case</b><var> &lt;expression&gt; </var>(<var>&lt;literal&gt; <small class="dots">...</small></var>)<var> &lt;syntax-case clause&gt; <small class="dots">...</small><a name="index-syntax_002dcase-802"></a></var><br>
&mdash; Auxiliary Syntax: <b>_</b><var><a name="index-g_t_005f-803"></a></var><br>
&mdash; Auxiliary Syntax: <b>...</b><var><a name="index-g_t_002e_002e_002e-804"></a></var><br>
<blockquote><p>Each <var>&lt;literal&gt;</var> must be an identifier.  Each <var>&lt;syntax-case
clause&gt;</var> must take one of the following two forms.

     <pre class="example">          (<var>&lt;pattern&gt;</var> <var>&lt;output expression&gt;</var>)
          (<var>&lt;pattern&gt;</var> <var>&lt;fender&gt;</var> <var>&lt;output expression&gt;</var>)
</pre>
        <p><var>&lt;fender&gt;</var> and <var>&lt;output expression&gt;</var> must be
<var>&lt;expression&gt;</var>s.

        <p>A <var>&lt;pattern&gt;</var> is an identifier, constant, or one of the following.

     <pre class="example">          (<var>&lt;pattern&gt;</var> ...)
          (<var>&lt;pattern&gt;</var> <var>&lt;pattern&gt;</var> ... . <var>&lt;pattern&gt;</var>)
          (<var>&lt;pattern&gt;</var> ... <var>&lt;pattern&gt;</var> <var>&lt;ellipsis&gt;</var> <var>&lt;pattern&gt;</var> ...)
          (<var>&lt;pattern&gt;</var> ... <var>&lt;pattern&gt;</var> <var>&lt;ellipsis&gt;</var> <var>&lt;pattern&gt;</var> ... . <var>&lt;pattern&gt;</var>)
          #(<var>&lt;pattern&gt;</var> ...)
          #(<var>&lt;pattern&gt;</var> ... <var>&lt;pattern&gt;</var> <var>&lt;ellipsis&gt;</var> <var>&lt;pattern&gt;</var> ...)
</pre>
        <p>An <var>&lt;ellipsis&gt;</var> is the identifier &lsquo;<samp><span class="samp">...</span></samp>&rsquo; (three periods).

        <p>An identifier appearing within a <var>&lt;pattern&gt;</var> may be an underscore
&lsquo;<samp><span class="samp">_</span></samp>&rsquo;, an ellipsis &lsquo;<samp><span class="samp">...</span></samp>&rsquo; or a literal identifier listed in the
list of literals &lsquo;<samp><span class="samp">(</span><var>&lt;literal&gt;</var><span class="samp"> ...)</span></samp>&rsquo;.  All other
identifiers appearing within a <var>&lt;pattern&gt;</var> are <dfn>pattern
variables</dfn>.  It is a syntax violation if an ellipsis or underscore
appears in &lsquo;<samp><span class="samp">(</span><var>&lt;literal&gt;</var><span class="samp"> ...)</span></samp>&rsquo;.

        <p>&lsquo;<samp><span class="samp">_</span></samp>&rsquo; and &lsquo;<samp><span class="samp">...</span></samp>&rsquo; are the same as in the <code>(rnrs base (6))</code>
library.

        <p>Pattern variables match arbitrary input subforms and are used to refer
to elements of the input.  It is a syntax violation if the same pattern
variable appears more than once in a <var>&lt;pattern&gt;</var>.

        <p>Underscores also match arbitrary input subforms but are not pattern
variables and so cannot be used to refer to those elements.  Multiple
underscores may appear in a <var>&lt;pattern&gt;</var>.

        <p>A literal identifier matches an input subform if and only if the input
subform is an identifier and either both its occurrence in the input
expression and its occurrence in the list of literals have the same
lexical binding, or the two identifiers have the same name and both have
no lexical binding.

        <p>A subpattern followed by an ellipsis can match zero or more elements of
the input.

        <p>More formally, an input form F matches a pattern P if and
only if one of the following holds:

          <ul>
<li>P is an underscore.

          <li>P is a pattern variable.

          <li>P is a literal identifier and F is an equivalent
identifier in the sense of <code>free-identifier=?</code>.

          <li>P is of the form:

          <pre class="example">               (P_1 ... P_n)
</pre>
          <p class="noindent">and F is a list of n elements that match P_1
through P_n.

          <li>P is of the form:

          <pre class="example">               (P_1 ... P_n . P_x)
</pre>
          <p class="noindent">and F is a list or improper list of n or more elements
whose first n elements match P_1 through P_n and
whose nth cdr matches P_x.

          <li>P is of the form:

          <pre class="example">               (P_1 ... P_k P_e <var>&lt;ellipsis&gt;</var> P_(m+1) ... P_n)
</pre>
          <p class="noindent">where <var>&lt;ellipsis&gt;</var> is the identifier &lsquo;<samp><span class="samp">...</span></samp>&rsquo;  and F is a
proper list of n elements whose first k elements match
P_1 through P_k, whose next m-k elements each match
P_e, and whose remaining n-m elements match P_(m+1)
through P_n.

          <li>P is of the form:

          <pre class="example">               (P_1 ... P_k P_e <var>&lt;ellipsis&gt;</var> P_(m+1) ... P_n . P_x)
</pre>
          <p class="noindent">where <var>&lt;ellipsis&gt;</var> is the identifier &lsquo;<samp><span class="samp">...</span></samp>&rsquo;  and F is a
list or improper list of n elements whose first k elements
match P_1 through P_k, whose next m-k elements each
match P_e, whose next n-m elements match P_(m+1)
through P_n, and whose nth and final cdr matches
P_x.

          <li>P is of the form:

          <pre class="example">               #(P_1 ... P_n)
</pre>
          <p class="noindent">and F is a vector of n elements that match P_1
through P_n.

          <li>P is of the form:

          <pre class="example">               #(P_1 ... P_k P_e <var>&lt;ellipsis&gt;</var> P_(m+1) ... P_n)
</pre>
          <p class="noindent">where <var>&lt;ellipsis&gt;</var> is the identifier &lsquo;<samp><span class="samp">...</span></samp>&rsquo;  and F is a
vector of n or more elements whose first k elements match
P_1 through P_k, whose next m-k elements each match
P_e, and whose remaining n-m elements match P_(m+1)
through P_n.

          <li>P is a pattern datum (any nonlist, nonvector, nonsymbol datum)
and F is equal to P in the sense of the <code>equal?</code>
procedure. 
</ul>

        <p>A <code>syntax-case</code> expression first evaluates <var>&lt;expression&gt;</var>.  It
then attempts to match the <var>&lt;pattern&gt;</var> from the first
<var>&lt;syntax-case clause&gt;</var> against the resulting value, which is
unwrapped as necessary to perform the match.  If the pattern matches the
value and no <var>&lt;fender&gt;</var> is present, <var>&lt;output expression&gt;</var> is
evaluated and its value returned as the value of the <code>syntax-case</code>
expression.  If the pattern does not match the value, <code>syntax-case</code>
tries the second <var>&lt;syntax-case clause&gt;</var>, then the third, and so on. 
It is a syntax violation if the value does not match any of the
patterns.

        <p>If the optional <var>&lt;fender&gt;</var> is present, it serves as an additional
constraint on acceptance of a clause.  If the <var>&lt;pattern&gt;</var> of a given
<var>&lt;syntax-case clause&gt;</var> matches the input value, the corresponding
<var>&lt;fender&gt;</var> is evaluated.  If <var>&lt;fender&gt;</var> evaluates to a true
value, the clause is accepted; otherwise, the clause is rejected as if
the pattern had failed to match the value.  Fenders are logically a part
of the matching process, i.e., they specify additional matching
constraints beyond the basic structure of the input.

        <p>Pattern variables contained within a clause's <var>&lt;pattern&gt;</var> are bound
to the corresponding pieces of the input value within the clause's
<var>&lt;fender&gt;</var> (if present) and <var>&lt;output expression&gt;</var>.  Pattern
variables can be referenced only within <code>syntax</code> expressions (see
below).  Pattern variables occupy the same name space as program
variables and keywords.

        <p>If the <code>syntax-case</code> form is in tail context, the <var>&lt;output
expression&gt;</var>s are also in tail position. 
</p></blockquote></div>

<div class="defun">
&mdash; Syntax: <b>syntax</b><var> &lt;template&gt;<a name="index-syntax-805"></a></var><br>
<blockquote><p>A <code>syntax</code> expression is similar to a <code>quote</code> expression
except that:

          <ol type=1 start=1>
<li>The values of pattern variables appearing within <var>&lt;template&gt;</var> are
inserted into <var>&lt;template&gt;</var>.

          <li>Contextual information associated both with the input and with the
template is retained in the output to support lexical scoping.

          <li>The value of a <code>syntax</code> expression is a syntax object.
             </ol>

        <p>The following sharp&ndash;quote expression:

     <pre class="example">          #'<var>&lt;template&gt;</var>
</pre>
        <p class="noindent">is equivalent to:

     <pre class="example">          (syntax <var>&lt;template&gt;</var>)
</pre>
        <p class="noindent"><a href="scheme-lex-datum-abbreviations.html#scheme-lex-datum-abbreviations">scheme lex datum abbreviations</a> for the other abbreviations.

        <p>A <var>&lt;template&gt;</var> can be one among: a pattern variable, an identifier
that is not a pattern variable, a pattern datum, or one of the
following.

     <pre class="example">          (<var>&lt;subtemplate&gt;</var> ...)
          (<var>&lt;subtemplate&gt;</var> ... . <var>&lt;template&gt;</var>)
          #(<var>&lt;subtemplate&gt;</var> ...)
</pre>
        <p>A <var>&lt;subtemplate&gt;</var> is a <var>&lt;template&gt;</var> followed by zero or more
ellipses.

        <p>The value of a <code>syntax</code> form is a copy of <var>&lt;template&gt;</var> in which
the pattern variables appearing within the template are replaced with
the input subforms to which they are bound:

          <ul>
<li>Pattern data and identifiers that are not pattern variables or ellipses
are copied directly into the output.

          <li>A subtemplate followed by an ellipsis expands into zero or more
occurrences of the subtemplate.

          <li>Pattern variables that occur in subpatterns followed by one or more
ellipses may occur only in subtemplates that are followed by (at least)
as many ellipses:

               <ul>
<li>These pattern variables are replaced in the output by the input subforms
to which they are bound, distributed as specified.

               <li>If a pattern variable is followed by more ellipses in the subtemplate
than in the associated subpattern, the input form is replicated as
necessary.

               <li>The subtemplate must contain at least one pattern variable from a
subpattern followed by an ellipsis, and for at least one such pattern
variable, the subtemplate must be followed by exactly as many ellipses
as the subpattern in which the pattern variable appears (otherwise, the
expander would not be able to determine how many times the subform
should be repeated in the output). 
</ul>
          </ul>

     <p class="noindent">It is a syntax violation if the above constraints are not met.

        <p>A template of the form &lsquo;<samp><span class="samp">(</span><var>&lt;ellipsis&gt;</var> <var>&lt;template&gt;</var><span class="samp">)</span></samp>&rsquo; is
identical to <var>&lt;template&gt;</var>, except that ellipses within the template
have no special meaning.  That is, any ellipses contained within
<var>&lt;template&gt;</var> are treated as ordinary identifiers.  In particular,
the template &lsquo;<samp><span class="samp">(... ...)</span></samp>&rsquo; produces a single ellipsis.  This allows
macro uses to expand into forms containing ellipses.

        <p>The output produced by <code>syntax</code> is wrapped or unwrapped according
to the following rules:

          <ul>
<li>The copy of &lsquo;<samp><span class="samp">(</span><var>&lt;t1&gt;</var><span class="samp"> .  </span><var>&lt;t2&gt;</var><span class="samp">)</span></samp>&rsquo; is a pair if <var>&lt;t1&gt;</var>
or <var>&lt;t2&gt;</var> contain any pattern variables.

          <li>The copy of &lsquo;<samp><span class="samp">(</span><var>&lt;t&gt;</var> <var>&lt;ellipsis&gt;</var><span class="samp">)</span></samp>&rsquo; is a list if <var>&lt;t&gt;</var>
contains any pattern variables.

          <li>The copy of &lsquo;<samp><span class="samp">#(</span><var>&lt;t1&gt;</var><span class="samp"> ... </span><var>&lt;tn&gt;</var><span class="samp">)</span></samp>&rsquo; is a vector if any of
<var>&lt;t1&gt;</var>, <small class="dots">...</small>, <var>&lt;tn&gt;</var> contain any pattern variables.

          <li>The copy of any portion of <var>&lt;t&gt;</var> not containing any pattern
variables is a wrapped syntax object. 
</ul>

        <p>The input subforms inserted in place of the pattern variables are
wrapped if and only if the corresponding input subforms are wrapped. 
</p></blockquote></div>

   <p>The following definitions of <code>or</code> illustrate <code>syntax-case</code> and
<code>syntax</code>; the second is equivalent to the first but uses the
sharp&ndash;quote prefix instead of the full <code>syntax</code> form:

<pre class="example">     (define-syntax or
       (lambda (x)
         (syntax-case x ()
           ((_)
            (syntax #f))
           ((_ e)
            (syntax e))
           ((_ e1 e2 e3 ...)
            (syntax (let ((t e1))
                      (if t t (or e2 e3 ...))))))))
     
     (define-syntax or
       (lambda (x)
         (syntax-case x ()
           ((_)
            #'#f)
           ((_ e)
            #'e)
           ((_ e1 e2 e3 ...)
            #'(let ((t e1))
                (if t t (or e2 e3 ...)))))))
</pre>
   <p>The examples below define <dfn>identifier macros</dfn>, macro uses supporting
keyword references that do not necessarily appear in the first position
of a list&ndash;structured form; the second example uses
<code>make-variable-transformer</code> to handle the case where the keyword
appears on the left-hand side of a <code>set!</code> expression:

<pre class="example">     (define p (cons 4 5))
     (define-syntax p.car
       (lambda (x)
         (syntax-case x ()
     
           ((_ . rest)
            #'((car p) . rest))
     
           (_
            #'(car p)))))
     
     p.car                   &rArr; 4
     (set! p.car 15)         error--&gt; exception &amp;syntax
     
     (define p (cons 4 5))
     (define-syntax p.car
       (make-variable-transformer
         (lambda (x)
           (syntax-case x (set!)
     
             ((set! _ e)
              #'(set-car! p e))
     
             ((_ . rest)
              #'((car p) . rest))
     
             (_
              #'(car p))))))
     
     (set! p.car 15)
     
     p.car                   &rArr; 15
     p                       &rArr; (15 . 5)
</pre>
   <p>Any <code>syntax-rules</code> form can be expressed with <code>syntax-case</code> by
making the <code>lambda</code> expression and <code>syntax</code> expressions
explicit, and <code>syntax-rules</code> may be defined in terms of
<code>syntax-case</code> as follows.

<pre class="example">     (define-syntax syntax-rules
       (lambda (x)
         (syntax-case x ()
           ((_ (lit ...) ((k . p) t) ...)
            (for-all identifier? #'(lit ... k ...))
            #'(lambda (x)
                (syntax-case x (lit ...)
                  ((_ . p) #'t) ...))))))
</pre>
   <p>The <code>identifier-syntax</code> form of the base library (see <a href="baselib-transformers.html#baselib-transformers">baselib transformers</a>) may be defined in terms of <code>syntax-case</code>,
<code>syntax</code>, and <code>make-variable-transformer</code> as follows.

<pre class="example">     (define-syntax identifier-syntax
       (syntax-rules (set!)
         ((_ e)
          (lambda (x)
            (syntax-case x ()
              (id (identifier? #'id) #'e)
              ((_ x (... ...)) #'(e x (... ...))))))
         ((_ (id exp1) ((set! var val) exp2))
          (and (identifier? #'id) (identifier? #'var))
          (make-variable-transformer
            (lambda (x)
              (syntax-case x (set!)
                ((set! var val) #'exp2)
                ((id x (... ...)) #'(exp1 x (... ...)))
                (id (identifier? #'id) #'exp1)))))))
</pre>
   <!-- page -->
   </body></html>

