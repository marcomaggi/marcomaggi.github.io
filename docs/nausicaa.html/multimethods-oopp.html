<html lang="en">
<head>
<title>multimethods oopp - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="multimethods.html#multimethods" title="multimethods">
<link rel="prev" href="multimethods-next.html#multimethods-next" title="multimethods next">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d7 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="multimethods-oopp"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="multimethods-next.html#multimethods-next">multimethods next</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="multimethods.html#multimethods">multimethods</a>
<hr>
</div>

<h3 class="section">4.7 Notes on using generics as <acronym>OOPP</acronym> type methods</h3>

<p>It is possible to use generic functions as implementations of methods
for types defined using the library <code>(nausicaa language oopp)</code>;
doing it results in method behaviour which is traditional in
object&ndash;oriented systems.  For example, given the definitions:

<pre class="example">     (import (nausicaa))
     
     (define-class &lt;alpha&gt;
       (fields a)
       (methods (doit doit)))
     
     (define-class &lt;beta&gt;
       (parent &lt;alpha&gt;)
       (fields b)
       (methods (doit doit)))
     
     (define-generic doit (o arg))
     
     (define-method (doit (o &lt;alpha&gt;) arg)
       (list 'doit-alpha arg))
     
     (define-method (doit (o &lt;beta&gt;) arg)
       (list 'doit-beta arg))
</pre>
   <p class="noindent">we have:

<pre class="example">     (let (((o &lt;alpha&gt;) (&lt;alpha&gt; (1))))
       (o doit 10))
     &rArr; (doit-alpha 10)
     
     (let (((o &lt;beta&gt;) (&lt;beta&gt; (1 2))))
       (o doit 20))
     &rArr; (doit-beta 20)
</pre>
   <p class="noindent">but also:

<pre class="example">     (let (((o &lt;alpha&gt;) (&lt;beta&gt; (1 2))))
       (o doit 30))
     &rArr; (doit-beta 30)
</pre>
   <p class="noindent">in which <code>(o doit ---)</code> is meant to call the <code>doit</code> method of
<code>&lt;alpha&gt;</code>, because <code>o</code> is tagged as <code>&lt;alpha&gt;</code>, but
<code>&lt;beta&gt;</code> has redefined the method, so <code>doit</code> of <code>&lt;beta&gt;</code> is
called.  This behaviour can be obtained only with multimethods, not when
defining methods as plain functions or macros.

   <p>Another interesting use of generics as class methods is the
implementation of pre and post conditions.

   <p>The Object&ndash;Oriented Programming substitution principle states that: if
<code>&lt;beta&gt;</code> inherits from <code>&lt;alpha&gt;</code>, every chunk of code expecting
an <code>&lt;alpha&gt;</code> instance as argument must work when a <code>&lt;beta&gt;</code>
instance is used as argument.  We can write pre and post conditions in a
method implementation for <code>&lt;alpha&gt;</code> and pre and post conditions in
the method reimplementation for <code>&lt;beta&gt;</code>; when the reimplemented
method is called, it is correct to enforce both the pre and post
conditions for <code>&lt;beta&gt;</code> and for <code>&lt;alpha&gt;</code>.

   <p>The conditions for the <code>&lt;alpha&gt;</code> method must imply the conditions
for the <code>&lt;beta&gt;</code> method; for example, a precondition for
<code>&lt;alpha&gt;</code> can be that an argument is a positive integer, while a
precondition for <code>&lt;beta&gt;</code> can be that the integer is greater than
3.  It follows that the preconditions for <code>&lt;alpha&gt;</code> should be
tested before the preconditions of <code>&lt;beta&gt;</code>.

   <p>This is exactly what happens with <code>:before</code> and <code>:after</code>
methods when we use the <code>reverse-before-methods</code> clause in
<code>define-generic*</code>:

<pre class="example">     (import (nausicaa)
       (only (nausicaa checks)
             with-result add-result))
     
     (define-class &lt;alpha&gt;
       (fields a)
       (methods (doit doit)))
     
     (define-class &lt;beta&gt;
       (parent &lt;alpha&gt;)
       (fields b)
       (methods (doit doit)))
     
     (define-generic* doit (o arg)
       (reverse-before-methods #t))
     
     (define-method (doit (o &lt;alpha&gt;) arg)
       (list 'doit-alpha arg))
     
     (define-method (doit (o &lt;beta&gt;) arg)
       (list 'doit-beta arg))
     
     (define-method doit :before ((o &lt;alpha&gt;) arg)
       (add-result 'before-alpha))
     
     (define-method doit :after ((o &lt;alpha&gt;) arg)
       (add-result 'after-alpha))
     
     (define-method doit :before ((o &lt;beta&gt;) arg)
       (add-result 'before-beta))
     
     (define-method doit :after ((o &lt;beta&gt;) arg)
       (add-result 'after-beta))
     
     (with-result
      (let (((o &lt;alpha&gt;) (make &lt;beta&gt; 1 2)))
        (o.doit 30)))
     &rArr; ((doit-beta 30)
         (before-alpha   ;this is the order of invocation
          before-beta    ;for :BEFORE and :AFTER methods
          after-alpha
          after-beta))
</pre>
   <!-- end of file -->
   </body></html>

