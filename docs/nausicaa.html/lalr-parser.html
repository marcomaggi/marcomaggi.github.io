<html lang="en">
<head>
<title>lalr parser - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="lalr.html#lalr" title="lalr">
<link rel="prev" href="lalr-lexer.html#lalr-lexer" title="lalr lexer">
<link rel="next" href="lalr-grammar.html#lalr-grammar" title="lalr grammar">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d12 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008-2011 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="lalr-parser"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="lalr-grammar.html#lalr-grammar">lalr grammar</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="lalr-lexer.html#lalr-lexer">lalr lexer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="lalr.html#lalr">lalr</a>
<hr>
</div>

<h3 class="section">75.4 Running the parser</h3>

<p>Here we suppose to have used <code>lalr-parser</code> to generate a proper
Scheme library exporting a binding to the parser maker.  Let
<code>(calc-parser)</code> be the library specification and
<code>make-calc-parser</code> the name of the binding to the parser maker.

   <p>The parser maker is invoked with no arguments and returns a new parser
closure, which represents an instance of the parser.  To create a parser
closure we do:

<pre class="example">     (import (rnrs)
       (calc-parser)
       (prefix (nausicaa parser-tools silex lexer) lex.))
     
     (define parser (make-calc-parser))
</pre>
   <p>The <code>parser</code> function accepts two or three arguments: the lexer
closure, an error handler procedure, a custom value.  When invoked, it
consumes tokens from the lexer until the end of input is found or an
unrecoverable error occurs.

   <p>To invoke <code>parser</code> with a lexer generated by the <code>(nausicaa
parser-tools silex)</code> library, using a table in &lsquo;<samp><span class="samp">calc-lexer-table</span></samp>&rsquo; to
parse <var>input-string</var>, we do:

<pre class="example">     (let* ((IS        (lex.make-IS (string: <var>input-string</var>)))
            (lexer     (lex.make-lexer calc-lexer-table IS))
            (error-hnd (lambda (message token) ---))
            (yycustom  #f))
       (parser lexer error-hnd yycustom))
</pre>
   <p>The parser closure will return the value computed by the semantic clause
of the outer non&ndash;terminal, the <dfn>start symbol</dfn>.

<!--  -->
<h5 class="subsubheading">The lexical analyser</h5>

<p>The lexer closure must be a thunk invoked each time the parser needs to
lookahead in the token stream.  Its return value must be a record of
type <code>&lt;lexical-token&gt;</code>.  <a href="lexical_002dtokens.html#lexical_002dtokens">Lexical token records</a>

   <p>Once the lexer closure finds the end of input, it must return a token
with category &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo;; it must continue to return such a token if
invoked multiple times.

   <p>If the lexer closure finds a lexer error in the input, it must return a
token with category &lsquo;<samp><span class="samp">*lexer-error*</span></samp>&rsquo;; lexer errors are
unrecoverable.

   <p>If the lexer raises an exception, it will go through the parser closure
with no obstacles.

<!--  -->
<h5 class="subsubheading">The error procedure</h5>

<p>It must be a function accepting two arguments: an error message as
Scheme string, the lexical token that caused the error.  Its return
value does not matter for the parser itself.

   <p>If the error procedure returns, the parser closure attempts to recover
from the error and to resume parsing.  If it raises an exception parsing
may stop, depending on how the program deals with it.

   <p>A simple error procedure raising an exception looks like this:

<pre class="example">     (define (error-handler message token)
       (error #f
         (if (not (is-a? token &lt;lexical-token&gt;))
             message
           (let (((T &lt;lexical-token&gt;) token))
             (if (not (is-a? T.location &lt;source-location&gt;))
                 message
               (let (((P &lt;source-location&gt;) T.location))
                 (string-append
                   message
                   " line "   (if P.line   P.line.string   "?")
                   " column " (if P.column P.column.string "?"))))))
         token))
</pre>
   <p class="noindent">notice how the handler detects if the &lsquo;<samp><span class="samp">location</span></samp>&rsquo; field of the
<code>&lt;lexical-token&gt;</code> record is <code>#f</code> or a <code>&lt;source-location&gt;</code>
record.

   <p>The error procedure is invoked:

     <ul>
<li>When an invalid value is returned by the lexer.  If the value is not a
<code>&lt;lexical-token&gt;</code> record, the error procedure is invoked with the
offending value as second argument.

     <p>Parsing stops and the return value of the parser closure is the return
value of the error procedure, if any.

     <li>When the stream of tokens returned by the lexer violates parser's
grammar.

          <ul>
<li>If the error is an unexpected end&ndash;of&ndash;input, the second argument is a
<code>&lt;lexical-token&gt;</code> record with &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; in the category field.

          <p>Parsing stops and the return value of the parser closure is the return
value of the error procedure, if any.

          <li>If the error is another grammar violation, the error procedure is
invoked with the offending value as second argument; its return value,
if any, is discarded.

          <p>If the error procedure returns, the parser will try to recover from the
error and resume parsing; if error recovery fails, the parser behaves as
if the end&ndash;of&ndash;input is found. 
</ul>
     </ul>

<!-- page -->
   </body></html>

