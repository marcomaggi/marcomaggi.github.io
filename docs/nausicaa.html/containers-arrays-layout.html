<html lang="en">
<head>
<title>containers arrays layout - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="containers-arrays.html#containers-arrays" title="containers arrays">
<link rel="prev" href="containers-arrays-conventions.html#containers-arrays-conventions" title="containers arrays conventions">
<link rel="next" href="containers-arrays-proc.html#containers-arrays-proc" title="containers arrays proc">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d7 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="containers-arrays-layout"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="containers-arrays-proc.html#containers-arrays-proc">containers arrays proc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="containers-arrays-conventions.html#containers-arrays-conventions">containers arrays conventions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="containers-arrays.html#containers-arrays">containers arrays</a>
<hr>
</div>

<h4 class="subsection">10.4.2 Layout of elements in the vector</h4>

<p>A multidimensional array is a special <acronym>API</acronym> to access built&ndash;in Scheme
vectors.  If we fill the underlying vector with integers representing
the vector index of the elements, for an array of one dimension and four
elements, the vector is:

<pre class="example">     #(0 1 2 3)
</pre>
   <p>For an array of two dimensions with 3 rows and 4 columns,
we can compute the vector index by multiplying the row coordinate by the
number of columns, then adding the column coordinate:

<pre class="example">     ;;     coordinates   formula
     #( 0   ; 0 0         0 * 4 + 0 * 1
        1   ; 0 1         0 * 4 + 1 * 1
        2   ; 0 2         0 * 4 + 2 * 1
        3   ; 0 3         0 * 4 + 3 * 1
        4   ; 1 0         1 * 4 + 0 * 1
        5   ; 1 1         1 * 4 + 1 * 1
        6   ; 1 2         1 * 4 + 2 * 1
        7   ; 1 3         1 * 4 + 3 * 1
        8   ; 2 0         2 * 4 + 0 * 1
        9   ; 2 1         2 * 4 + 1 * 1
       10   ; 2 2         2 * 4 + 2 * 1
       11)  ; 2 3         2 * 4 + 3 * 1
</pre>
   <p>For an array of three dimensions with 2 planes, 3 rows and
4 columns, we can compute the vector index by multiplying the
plane, row and column coordinates by the appropriate factor:

<pre class="example">     ;;     coordinates    formula
     #( 0   ; 0 0 0        0 * (3 * 4) + 0 * 4 + 0 * 1
        1   ; 0 0 1        0 * (3 * 4) + 0 * 4 + 1 * 1
        2   ; 0 0 2        0 * (3 * 4) + 0 * 4 + 2 * 1
        3   ; 0 0 3        0 * (3 * 4) + 0 * 4 + 3 * 1
        4   ; 0 1 0        0 * (3 * 4) + 1 * 4 + 0 * 1
        5   ; 0 1 1        0 * (3 * 4) + 1 * 4 + 1 * 1
        6   ; 0 1 2        0 * (3 * 4) + 1 * 4 + 2 * 1
        7   ; 0 1 3        0 * (3 * 4) + 1 * 4 + 3 * 1
        8   ; 0 2 0        0 * (3 * 4) + 2 * 4 + 0 * 1
        9   ; 0 2 1        0 * (3 * 4) + 2 * 4 + 1 * 1
       10   ; 0 2 2        0 * (3 * 4) + 2 * 4 + 2 * 1
       11   ; 0 2 3        0 * (3 * 4) + 2 * 4 + 3 * 1
       12   ; 1 0 3        1 * (3 * 4) + 0 * 4 + 0 * 1
       13   ; 1 0 3        1 * (3 * 4) + 0 * 4 + 1 * 1
       14   ; 1 0 3        1 * (3 * 4) + 0 * 4 + 2 * 1
       15   ; 1 0 3        1 * (3 * 4) + 0 * 4 + 3 * 1
       16   ; 1 1 3        1 * (3 * 4) + 1 * 4 + 0 * 1
       17   ; 1 1 3        1 * (3 * 4) + 1 * 4 + 1 * 1
       18   ; 1 1 3        1 * (3 * 4) + 1 * 4 + 2 * 1
       19   ; 1 1 3        1 * (3 * 4) + 1 * 4 + 3 * 1
       20   ; 1 2 3        1 * (3 * 4) + 2 * 4 + 0 * 1
       21   ; 1 2 3        1 * (3 * 4) + 2 * 4 + 1 * 1
       22   ; 1 2 3        1 * (3 * 4) + 2 * 4 + 2 * 1
       23)  ; 1 2 3        1 * (3 * 4) + 2 * 4 + 3 * 1
</pre>
   <p class="noindent">that is:

<pre class="example">     index = plane * (3 * 4) + row * 4 + column * 1
</pre>
   <p>Generalising: the rightmost coordinate is always multiplied by 1,
while the others are multiplied by a product between the length of the
dimensions.

   <p>Precisely, let's call N the number of dimensions of an array, and
let's index the dimensions with 0 &lt;= k &lt; N; then: D(k) is
the length of the k-th dimension; C(k) is the k-th
coordinate of an element and F(k) is its factor.  The index
of the element is computed with:

<pre class="example">     index = F(0) * C(0) + F(1) * C(1) + ... + F(N-1) * C(N-1)
</pre>
   <p class="noindent">being:

<pre class="example">     0 &lt;= k &lt; N-2   =&gt;   F(k) = D(k+1) * D(k+2) * ... * D(N-1)
     
          k = N-1   =&gt;   F(N-1) = 1
</pre>
   <p class="noindent">we note explicitly that D(0) is <strong>never</strong> used in the
computation of the factors, and that D(k) is <strong>not</strong> used in
the computation of F(k).

   <p>If <code>dimensions</code> is the list of dimensions of an array, the
following function will compute and return the list of factors:

<pre class="example">     (define (%compute-factors dimensions)
       (let loop ((dims    (cdr dimensions))
                  (factors '()))
         (if (null? dims)
             (reverse (cons 1 factors))
           (loop (cdr dims)
                 (cons (apply * dims) factors)))))
</pre>
   <!-- page -->
   </body></html>

