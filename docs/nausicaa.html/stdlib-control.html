<html lang="en">
<head>
<title>stdlib control - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="stdlib.html#stdlib" title="stdlib">
<link rel="prev" href="stdlib-sorting.html#stdlib-sorting" title="stdlib sorting">
<link rel="next" href="stdlib-records.html#stdlib-records" title="stdlib records">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d3 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="stdlib-control"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="stdlib-records.html#stdlib-records">stdlib records</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="stdlib-sorting.html#stdlib-sorting">stdlib sorting</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="stdlib.html#stdlib">stdlib</a>
<hr>
</div>

<h3 class="section">4.5 Control structures</h3>

<p><a name="index-g_t_0040rsixlibrary_007bcontrol_007d_002c-library-366"></a><a name="index-Library_002c-_0040rsixlibrary_007bcontrol_007d-367"></a>

   <p>This chapter describes the <code>(rnrs control (6))</code> library, which provides
useful control structures.

<div class="defun">
&mdash; Syntax: <b>when</b><var> &lt;test&gt; &lt;expression1&gt; &lt;expression2&gt; <small class="dots">...</small><a name="index-when-368"></a></var><br>
&mdash; Syntax: <b>unless</b><var> &lt;test&gt; &lt;expression1&gt; &lt;expression2&gt; <small class="dots">...</small><a name="index-unless-369"></a></var><br>
<blockquote><p>&lt;test&gt; must be an expression.

        <p>A <code>when</code> expression is evaluated by evaluating the &lt;test&gt;
expression.  If &lt;test&gt; evaluates to a true value, the remaining
&lt;expression&gt;s are evaluated in order, and the results of the last
&lt;expression&gt; are returned as the results of the entire <code>when</code>
expression.  Otherwise, the <code>when</code> expression returns unspecified
values.

        <p>An <code>unless</code> expression is evaluated by evaluating the &lt;test&gt;
expression.  If &lt;test&gt; evaluates to <code>#f</code>, the remaining
&lt;expression&gt;s are evaluated in order, and the results of the last
&lt;expression&gt; are returned as the results of the entire
<code>unless</code> expression.  Otherwise, the <code>unless</code> expression
returns unspecified values.

        <p>The final &lt;expression&gt; is in tail context if the <code>when</code> or
<code>unless</code> form is itself in tail context.

     <pre class="example">          (when (&gt; 3 2) 'greater)         &rArr; greater
          (when (&lt; 3 2) 'greater)         &rArr; #&lt;unspecified&gt;
          (unless (&gt; 3 2) 'less)          &rArr; #&lt;unspecified&gt;
          (unless (&lt; 3 2) 'less)          &rArr; less
</pre>
        <p>The <code>when</code> and <code>unless</code> expressions are derived forms.  They
could be defined by the following macros:

     <pre class="example">          (define-syntax when
            (syntax-rules ()
              ((when test result1 result2 ...)
               (if test
                   (begin result1 result2 ...)))))
          
          (define-syntax unless
            (syntax-rules ()
              ((unless test result1 result2 ...)
               (if (not test)
                   (begin result1 result2 ...)))))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Syntax: <b>do</b> ((<var>&lt;variable1&gt; &lt;init1&gt; &lt;step1&gt;</var>)<var> <small class="dots">...</small></var>) (<var>&lt;test&gt; &lt;expression&gt; <small class="dots">...</small></var>)<var> &lt;command&gt; <small class="dots">...</small><a name="index-do-370"></a></var><br>
<blockquote><p>The &lt;init&gt;s, &lt;step&gt;s, &lt;test&gt;s, and &lt;command&gt;s
must be expressions.  The &lt;variable&gt;s must be pairwise distinct
variables.

        <p>The <code>do</code> expression is an iteration construct.  It specifies a set
of variables to be bound, how they are to be initialized at the start,
and how they are to be updated on each iteration.

        <p>A <code>do</code> expression is evaluated as follows: The &lt;init&gt;
expressions are evaluated (in some unspecified order), the
&lt;variable&gt;s are bound to fresh locations, the results of the
&lt;init&gt; expressions are stored in the bindings of the
&lt;variable&gt;s, and then the iteration phase begins.

        <p>Each iteration begins by evaluating &lt;test&gt;; if the result is
<code>#f</code>, then the &lt;command&gt;s are evaluated in order for effect,
the &lt;step&gt; expressions are evaluated in some unspecified order, the
&lt;variable&gt;s are bound to fresh locations holding the results, and
the next iteration begins.

        <p>If &lt;test&gt; evaluates to a true value, the &lt;expression&gt;s are
evaluated from left to right and the values of the last
&lt;expression&gt; are returned.  If no &lt;expression&gt;s are present,
then the <code>do</code> expression returns unspecified values.

        <p>The region consists of the entire <code>do</code> expression except for the
&lt;init&gt;s.

        <p>A &lt;step&gt; may be omitted, in which case the effect is the same as if
<code>(&lt;variable&gt; &lt;init&gt; &lt;variable&gt;)</code> had been written
instead of <code>(&lt;variable&gt; &lt;init&gt;)</code>.

        <p>If a <code>do</code> expression appears in a tail context, the
&lt;expression&gt;s are a &lt;tail sequence&gt; in the sense of report
section <a href="baselib-tail-call.html#baselib-tail-call">baselib tail call</a>, i.e., the last &lt;expression&gt; is
also in a tail context.

     <pre class="example">          (do ((vec (make-vector 5))
               (i 0 (+ i 1)))
              ((= i 5) vec)
            (vector-set! vec i i))
          &rArr; #(0 1 2 3 4)
          
          (let ((x '(1 3 5 7 9)))
            (do ((x x (cdr x))
                 (sum 0 (+ sum (car x))))
                ((null? x) sum)))
          &rArr; 25
</pre>
        <p>The following definition of <code>do</code> uses a trick to expand the
variable clauses.

     <pre class="example">          (define-syntax do
            (syntax-rules ()
              ((do ((var init step ...) ...)
                   (test expr ...)
                   command ...)
               (letrec
                 ((loop
                   (lambda (var ...)
                     (if test
                         (begin
                           #f ; avoid empty begin
                           expr ...)
                         (begin
                           command
                           ...
                           (loop (do "step" var step ...)
                                 ...))))))
                 (loop init ...)))
              ((do "step" x)
               x)
              ((do "step" x y)
               y)))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Syntax: <b>case-lambda</b><var> &lt;case-lambda clause&gt; <small class="dots">...</small><a name="index-case_002dlambda-371"></a></var><br>
<blockquote><p>Each &lt;case-lambda clause&gt; must be of the form:

     <pre class="example">          (&lt;formals&gt; &lt;body&gt;)
</pre>
        <p>&lt;formals&gt; must be as in a <code>lambda</code> form (<a href="baselib-expressions-procedures.html#baselib-expressions-procedures">baselib expressions procedures</a>), and &lt;body&gt; is as described in report
section <a href="baselib-bodies.html#baselib-bodies">baselib bodies</a>.

        <p>A <code>case-lambda</code> expression evaluates to a procedure.  This
procedure, when applied, tries to match its arguments to the
&lt;case-lambda clause&gt;s in order.  The arguments match a clause if
one of the following conditions is fulfilled:

          <ul>
<li>&lt;formals&gt; has the form <code>(&lt;variable&gt; ...)</code> and the
number of arguments is the same as the number of formal parameters in
&lt;formals&gt;.

          <li>&lt;formals&gt; has the form:

          <pre class="example">               (&lt;variable1&gt; ... &lt;variablen&gt; . &lt;variable_(n+1)&gt;)
</pre>
          <p class="noindent">and the number of arguments is at least n.

          <li>&lt;formals&gt; has the form <code>&lt;variable&gt;</code>. 
</ul>

        <p>For the first clause matched by the arguments, the variables of the
&lt;formals&gt; are bound to fresh locations containing the argument
values in the same arrangement as with <code>lambda</code>.

        <p>The last expression of a &lt;body&gt; in a <code>case-lambda</code> expression
is in tail context.

        <p>If the arguments match none of the clauses, an exception with condition
type <code>&amp;assertion</code> is raised.

     <pre class="example">          (define foo
            (case-lambda
             (() 'zero)
             ((x) (list 'one x))
             ((x y) (list 'two x y))
             ((a b c d . e) (list 'four a b c d e))
             (rest (list 'rest rest))))
          
          (foo)                   &rArr; zero
          (foo 1)                 &rArr; (one 1)
          (foo 1 2)               &rArr; (two 1 2)
          (foo 1 2 3)             &rArr; (rest (1 2 3))
          (foo 1 2 3 4)           &rArr; (four 1 2 3 4 ())
</pre>
        <p>The <code>case-lambda</code> keyword can be defined in terms of <code>lambda</code>
by the following macros:

     <pre class="example">          (define-syntax case-lambda
            (syntax-rules ()
              ((_ (fmls b1 b2 ...))
               (lambda fmls b1 b2 ...))
              ((_ (fmls b1 b2 ...) ...)
               (lambda args
                 (let ((n (length args)))
                   (case-lambda-help args n
                     (fmls b1 b2 ...) ...))))))
          
          (define-syntax case-lambda-help
            (syntax-rules ()
              ((_ args n)
               (assertion-violation #f
                 "unexpected number of arguments"))
              ((_ args n ((x ...) b1 b2 ...) more ...)
               (if (= n (length '(x ...)))
                   (apply (lambda (x ...) b1 b2 ...) args)
                   (case-lambda-help args n more ...)))
              ((_ args n ((x1 x2 ... . r) b1 b2 ...) more ...)
               (if (&gt;= n (length '(x1 x2 ...)))
                   (apply (lambda (x1 x2 ... . r) b1 b2 ...)
                             args)
                   (case-lambda-help args n more ...)))
              ((_ args n (r b1 b2 ...) more ...)
               (apply (lambda r b1 b2 ...) args))))
</pre>
        </blockquote></div>

<!-- page -->
   </body></html>

