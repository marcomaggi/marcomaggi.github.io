<html lang="en">
<head>
<title>parser-tools lalr intro states - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="parser_002dtools-lalr-intro.html#parser_002dtools-lalr-intro" title="parser-tools lalr intro">
<link rel="prev" href="parser_002dtools-lalr-intro-look.html#parser_002dtools-lalr-intro-look" title="parser-tools lalr intro look">
<link rel="next" href="parser_002dtools-lalr-intro-error.html#parser_002dtools-lalr-intro-error" title="parser-tools lalr intro error">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d6 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="parser-tools-lalr-intro-states"></a>
<a name="parser_002dtools-lalr-intro-states"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="parser_002dtools-lalr-intro-error.html#parser_002dtools-lalr-intro-error">parser-tools lalr intro error</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="parser_002dtools-lalr-intro-look.html#parser_002dtools-lalr-intro-look">parser-tools lalr intro look</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="parser_002dtools-lalr-intro.html#parser_002dtools-lalr-intro">parser-tools lalr intro</a>
<hr>
</div>

<h5 class="subsubsection">11.3.1.5 From symbol sequences to states</h5>

<p>We have seen that parser searches the grammar for an action associated
to a sequence of categories; this is inefficient.  We can represent the
grammar with a directed graph, having a single source and a single sink,
in which:

     <ul>
<li>Each sequence of categories having an action is represented by a
state&ndash;node.

     <li>Every shift and every reduce causes a transaction from one node to the
other.

     <li>The lookahead determines which outgoing transaction link to take from a
given node. 
</ul>

   <p>There are many possible expressions and many possible paths in the
graph; for example, the following expressions:

<pre class="example">     1
     1 + 2
     1 + (2 * 3)
     3 * 4
</pre>
   <p class="noindent">and much more can be represented by the following sequences of
terminals:

<pre class="example">     N *eoi*
     N A N *eoi*
     N A O N M N C *eoi*
     N M N *eoi*
</pre>
   <p class="noindent">which in turn are represented by the following graph, in which every
node has a numeric index (from 0 to 11) and every terminal
category (&lsquo;<samp><span class="samp">N</span></samp>&rsquo;, &lsquo;<samp><span class="samp">A</span></samp>&rsquo;, &lsquo;<samp><span class="samp">M</span></samp>&rsquo;, &lsquo;<samp><span class="samp">C</span></samp>&rsquo;, &lsquo;<samp><span class="samp">O</span></samp>&rsquo;) has the
associated action between parenthesis (&lsquo;<samp><span class="samp">s</span></samp>&rsquo; for shift, &lsquo;<samp><span class="samp">r</span></samp>&rsquo; for
reduce, &lsquo;<samp><span class="samp">a</span></samp>&rsquo; for accept):

<pre class="example">              (11) finish
               ^
               |
               |*eoi*(a)
          N(s) |
      (0)----&gt;(1)&lt;------------+------------------------------
     start     |              |                              |
               |              |*eoi*(r)                      |
               | A(s)    N(s) |           *eoi*(r)           |
               +-----&gt;(2)---&gt;(3)&lt;-------------------------   |
               |       |                                  |  |
               |       |                                  |  |
               |       | O(s)   N(s)   M(s)   N(s)   C(s) |  |
               |        ----&gt;(4)---&gt;(5)---&gt;(6)---&gt;(7)---&gt;(8) |
               |                                             |
               |                                             |
               | M(s)    N(s)      *eoi*(r)                  |
                -----&gt;(9)---&gt;(10)----------------------------
</pre>
   <p>Starting from node 0, with each shift and reduce we move our
position in the graph to some node.  What matters to select the next
action to perform, is just the node we are in and the category of the
lookahead token.

   <p>Let's try it with the expression &lsquo;<samp><span class="samp">1 + 2</span></samp>&rsquo;; we add a stack for the
current node number:

<pre class="example">     #(#f   1   +   2  #&lt;eof&gt;)
     #( S   N   A   N   *eoi*)
     #( 0  #f  #f  #f      #f)
        |
        p
</pre>
   <p class="noindent">the lookahead returns &lsquo;<samp><span class="samp">N</span></samp>&rsquo; and the grammar associates &lsquo;<samp><span class="samp">[0, N]</span></samp>&rsquo;
with &lsquo;<samp><span class="samp">[1, shift]</span></samp>&rsquo;:

<pre class="example">     #(#f   1   +   2  #&lt;eof&gt;)
     #( S   N   A   N   *eoi*)
     #( 0   1  #f  #f      #f)
            |
            p
</pre>
   <p class="noindent">the lookahead returns &lsquo;<samp><span class="samp">A</span></samp>&rsquo; and the grammar associates &lsquo;<samp><span class="samp">[1, A]</span></samp>&rsquo;
with &lsquo;<samp><span class="samp">[2, shift]</span></samp>&rsquo;:

<pre class="example">     #(#f   1   +   2  #&lt;eof&gt;)
     #( S   N   A   N   *eoi*)
     #( 0   1   2  #f      #f)
                |
                p
</pre>
   <p class="noindent">the lookahead returns &lsquo;<samp><span class="samp">N</span></samp>&rsquo; and the grammar associates &lsquo;<samp><span class="samp">[2, N]</span></samp>&rsquo;
with &lsquo;<samp><span class="samp">[3, shift]</span></samp>&rsquo;:

<pre class="example">     #(#f   1   +   2  #&lt;eof&gt;)
     #( S   N   A   N   *eoi*)
     #( 0   1   2   3      #f)
                    |
                    p
</pre>
   <p class="noindent">the lookahead returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the grammar associates &lsquo;<samp><span class="samp">[3,
*eoi*]</span></samp>&rsquo; with &lsquo;<samp><span class="samp">[1, reduce]</span></samp>&rsquo;:

<pre class="example">     #(#f   3  #&lt;eof&gt;  #f  #f)
     #( S   N   *eoi*  #f  #f)
     #( 0   1      #f  #f  #f)
            |
            p
</pre>
   <p class="noindent">the lookahead returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the grammar associates &lsquo;<samp><span class="samp">[1,
*eoi*]</span></samp>&rsquo; with &lsquo;<samp><span class="samp">[11, accept]</span></samp>&rsquo;.

<!-- page -->
   </body></html>

