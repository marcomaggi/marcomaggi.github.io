<html lang="en">
<head>
<title>parser-tools lalr intro tokens - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="parser_002dtools-lalr-intro.html#parser_002dtools-lalr-intro" title="parser-tools lalr intro">
<link rel="next" href="parser_002dtools-lalr-intro-want.html#parser_002dtools-lalr-intro-want" title="parser-tools lalr intro want">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d7 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="parser-tools-lalr-intro-tokens"></a>
<a name="parser_002dtools-lalr-intro-tokens"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="parser_002dtools-lalr-intro-want.html#parser_002dtools-lalr-intro-want">parser-tools lalr intro want</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="parser_002dtools-lalr-intro.html#parser_002dtools-lalr-intro">parser-tools lalr intro</a>
<hr>
</div>

<h5 class="subsubsection">12.3.1.1 Splitting expressions in semantic tokens</h5>

<p>The first step is to split the expression in <dfn>tokens</dfn>: basic
elements having a semantic meaning.  In &lsquo;<samp><span class="samp">3 * 4 - 5</span></samp>&rsquo; there are five
of them:

<pre class="example">     3       -&gt; number
     *       -&gt; operator
     4       -&gt; number
     -       -&gt; operator
     5       -&gt; number
</pre>
   <p>Splitting the input into tokens is the job of the lexer.  We cannot
decide what the lexer has to do if we do not define the parser grammar
first.

   <p>We can be sure that we want to deal with every number 3 in the
same way, the same goes for every operator *.  But there is more
of this.

   <p>Scheme implements the functions <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>
which can be applied to every Scheme's number object; so it is
reasonable to state that: we are not interested in the concrete value of
each number, but only in the abstract fact that they are numbers.  We
can say that all the number tokens are in the same <dfn>category</dfn>; let's
use the Scheme symbol &lsquo;<samp><span class="samp">N</span></samp>&rsquo; to indicate it.  &lsquo;<samp><span class="samp">N</span></samp>&rsquo; is an
abstraction for each number.

   <p>The Scheme functions <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> are all
applied in the same way, but the arithmetic operators +-*/ are
not: + and - can be both unary and binary, * and
/ take precedence over + and -.  We might come up
with the following alternative categorisations:

     <ul>
<li>All the operator tokens are in the same category.

     <li>The operators + and - are in a category; the operators
* and / are in another category.

     <li>Each operator has its own category. 
</ul>

   <p>Putting all the tokens equal to each other in the same category is
always safe, but it leads to an explosion of the number of categories;
this complicates the definition of the grammar.  Experience shows that
&ldquo;it works&rdquo; to put + and - in a category, let's call it
&lsquo;<samp><span class="samp">A</span></samp>&rsquo; like addition, and * and / in another category,
let's call it &lsquo;<samp><span class="samp">M</span></samp>&rsquo; like multiplication.

   <p>With these abstractions, we can see the expression &lsquo;<samp><span class="samp">3 * 4 - 5</span></samp>&rsquo; as
the following ordered sequence of categorised tokens:

<pre class="example">     [N, 3]  [M, *]  [N, 4]  [A, -]  [N, 5]
</pre>
   <p class="noindent">the parser will not be interested in the concrete values, only in the
categories; so it will see the sequence as just:

<pre class="example">     N M N A N
</pre>
   <p>We want to support parentheses, too.  The semantic meaning of the open
parenthesis is different from the semantic meaning of the closed one;
(1 + 2) makes sense, but (1 + 2( is wrong; giving
different semantic meaning to the parentheses is mandatory to recognise
nested expressions like (1 * (2 + 3)).  So we assign the open
parenthesis to the category &lsquo;<samp><span class="samp">O</span></samp>&rsquo; and the closed one to the category
&lsquo;<samp><span class="samp">C</span></samp>&rsquo;; with these abstractions, the expression:

<pre class="example">     (6 - (7 - 8)) * 2
</pre>
   <p class="noindent">is tokenised by the following ordered sequence (from left to right, then
top to bottom):

<pre class="example">     [O, (]  [N, 6]  [A, -]  [O, (]  [N, 7]  [A, -]
     [N, 8]  [C, )]  [C, )]  [M, *]  [N, 2]
</pre>
   <p class="noindent">but the parser is interested only in the categories:

<pre class="example">     O N A O N A N C C M N
</pre>
   <p>The categories defined so far are not the only ones with which an LR
parser is concerned; we call them <dfn>terminal categories</dfn> or
<dfn>terminal symbols</dfn> or just <dfn>terminals</dfn>, because they are direct
abstractions of concrete values.  In contrast, the other categories are
called <dfn>non&ndash;terminal categories</dfn> or <dfn>non&ndash;terminal symbols</dfn> or
just <dfn>non&ndash;terminals</dfn>, because they are higher level abstractions
for sequences of terminals and nested non&ndash;terminals.

   <p>When modeling a terminal with a Scheme object, we need at least two
fields:

     <ol type=1 start=1>
<li>The Scheme symbol representing the category.

     <li>The Scheme object representing the concrete value.  We can represent:

          <ul>
<li>Number tokens with Scheme number objects.

          <li>Operator tokens with the Scheme functions implementing them.

          <li>Parenthesis tokens with the Scheme characters &lsquo;<samp><span class="samp">#\(</span></samp>&rsquo; and &lsquo;<samp><span class="samp">#\)</span></samp>&rsquo;. 
</ul>
     </ol>

   <p>Experience shows that it is useful to define yet another token: the
end&ndash;of-input; it is used by the lexer to signal that no more tokens are
available.  We need to define a new terminal category for this, let's
call it &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo;.  The concrete value of this terminal is not
important, we can just select &lsquo;<samp><span class="samp">(eof-object)</span></samp>&rsquo;; in what follows we
will display it as &lsquo;<samp><span class="samp">#&lt;eof&gt;</span></samp>&rsquo;.

   <p>Putting all together, given the input expression:

<pre class="example">     (6 - (7 - 8)) * 2
</pre>
   <p class="noindent">the lexer transforms it into the ordered sequence of tokens:

<pre class="example">     [O, (]  [N, 6]  [A, -]  [O, (]  [N, 7]  [A, -]
     [N, 8]  [C, )]  [C, )]  [M, *]  [N, 2]  [*eoi*, #&lt;eof&gt;]
</pre>
   <p class="noindent">and the parser will operate on the terminal categories:

<pre class="example">     O N A O N A N C C M N *eoi*
</pre>
   <!-- page -->
   </body></html>

