<html lang="en">
<head>
<title>stdlib records syntactic layer - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="stdlib-records.html#stdlib-records" title="stdlib records">
<link rel="prev" href="stdlib-records-mutability.html#stdlib-records-mutability" title="stdlib records mutability">
<link rel="next" href="stdlib-records-procedural-layer.html#stdlib-records-procedural-layer" title="stdlib records procedural layer">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d5 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="stdlib-records-syntactic-layer"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="stdlib-records-procedural-layer.html#stdlib-records-procedural-layer">stdlib records procedural layer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="stdlib-records-mutability.html#stdlib-records-mutability">stdlib records mutability</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="stdlib-records.html#stdlib-records">stdlib records</a>
<hr>
</div>

<h4 class="subsection">4.6.3 Syntactic layer</h4>

<p><a name="index-g_t_0040rsixlibrary_007brecords-syntactic_007d_002c-library-372"></a><a name="index-Library_002c-_0040rsixlibrary_007brecords-syntactic_007d-373"></a>

   <p>The syntactic layer is provided by the <code>(rnrs records syntactic (6))</code>
library.  Some details of the specification are explained in terms of
the specification of the procedural layer.  <a href="stdlib-records-procedural-layer.html#stdlib-records-procedural-layer">Procedural layer</a>

   <p>The record&ndash;type&ndash;defining form <code>define-record-type</code> is a
definition and can appear anywhere any other <var>&lt;definition&gt;</var> can
appear.

<div class="defun">
&mdash; Syntax: <b>define-record-type</b><var> &lt;name spec&gt; &lt;record clause&gt;*<a name="index-define_002drecord_002dtype-374"></a></var><br>
<blockquote><!-- @deffnx {Auxiliary Syntax} fields -->
     <!-- @deffnx {Auxiliary Syntax} mutable -->
     <!-- @deffnx {Auxiliary Syntax} immutable -->
     <!-- @deffnx {Auxiliary Syntax} parent -->
     <!-- @deffnx {Auxiliary Syntax} protocol -->
     <!-- @deffnx {Auxiliary Syntax} sealed -->
     <!-- @deffnx {Auxiliary Syntax} opaque -->
     <!-- @deffnx {Auxiliary Syntax} nongenerative -->
     <!-- @deffnx {Auxiliary Syntax} parent-rtd -->
        <p>A <code>define-record-type</code> form defines a record type along with
associated constructor descriptor and constructor, predicate, field
accessors, and field mutators.  The <code>define-record-type</code> form
expands into a set of definitions in the environment where
<code>define-record-type</code> appears; hence, it is possible to refer to the
bindings (except for that of the record type itself) recursively.

        <p>The <var>&lt;name spec&gt;</var> specifies the names of the record type,
constructor, and predicate. It must take one of the following forms:

     <pre class="example">          (<var>&lt;record name&gt;</var> <var>&lt;constructor name&gt;</var> <var>&lt;predicate name&gt;</var>)
          <var>&lt;record name&gt;</var>
</pre>
        <p><var>&lt;record name&gt;</var>, <var>&lt;constructor name&gt;</var>, and <var>&lt;predicate name&gt;</var>
must all be identifiers.

        <p><var>&lt;record name&gt;</var>, taken as a symbol, becomes the name of the record
type.  (See the description of <code>make-record-type-descriptor</code>
below.)  Additionally, it is bound by this definition to an expand&ndash;time
or run&ndash;time representation of the record type and can be used as parent
name in syntactic record&ndash;type definitions that extend this
definition. It can also be used as a handle to gain access to the
underlying record&ndash;type descriptor and constructor descriptor (see
<code>record-type-descriptor</code> and <code>record-constructor-descriptor</code>
below).

        <p><var>&lt;constructor name&gt;</var> is defined by this definition to be a
constructor for the defined record type, with a protocol specified by
the &lsquo;<samp><span class="samp">protocol</span></samp>&rsquo; clause, or, in its absence, using a default
protocol.  For details, see the description of the &lsquo;<samp><span class="samp">protocol</span></samp>&rsquo;
clause below.

        <p><var>&lt;predicate name&gt;</var> is defined by this definition to a predicate for
the defined record type.

        <p>The second form of <var>&lt;name spec&gt;</var> is an abbreviation for the first
form, where the name of the constructor is generated by prefixing the
record name with &lsquo;<samp><span class="samp">make-</span></samp>&rsquo;, and the predicate name is generated by
adding a question mark (&lsquo;<samp><span class="samp">?</span></samp>&rsquo;) to the end of the record name. For
example, if the record name is &lsquo;<samp><span class="samp">frob</span></samp>&rsquo;, the name of the constructor
is <code>make-frob</code>, and the predicate name is <code>frob?</code>.

        <p>Each <var>&lt;record clause&gt;</var> must take one of the following forms; it is a
syntax violation if multiple <var>&lt;record clause&gt;</var>s of the same kind
appear in a <code>define-record-type</code> form. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>fields</b><var> &lt;field spec&gt;*<a name="index-fields-375"></a></var><br>
<blockquote><p>Each <var>&lt;field spec&gt;</var> has one of the following forms

     <pre class="example">          (immutable <var>&lt;field name&gt;</var> <var>&lt;accessor name&gt;</var>)
          (mutable <var>&lt;field name&gt;</var>
                   <var>&lt;accessor name&gt;</var> <var>&lt;mutator name&gt;</var>)
          (immutable <var>&lt;field name&gt;</var>)
          (mutable <var>&lt;field name&gt;</var>)
          <var>&lt;field name&gt;</var>
</pre>
        <p><var>&lt;field name&gt;</var>, <var>&lt;accessor name&gt;</var>, and <var>&lt;mutator name&gt;</var> must
all be identifiers.  The first form declares an immutable field called
<var>&lt;field name&gt;</var>, with the corresponding accessor named <var>&lt;accessor
name&gt;</var>.  The second form declares a mutable field called <var>&lt;field
name&gt;</var>, with the corresponding accessor named <var>&lt;accessor name&gt;</var>, and
with the corresponding mutator named <var>&lt;mutator name&gt;</var>.

        <p>If <var>&lt;field spec&gt;</var> takes the third or fourth form, the accessor name
is generated by appending the record name and field name with a hyphen
separator, and the mutator name (for a mutable field) is generated by
adding a &lsquo;<samp><span class="samp">-set!</span></samp>&rsquo; suffix to the accessor name.  For example, if the
record name is &lsquo;<samp><span class="samp">frob</span></samp>&rsquo; and the field name is &lsquo;<samp><span class="samp">widget</span></samp>&rsquo;, the
accessor name is <code>frob-widget</code> and the mutator name is
<code>frob-widget-set!</code>.

        <p>If <var>&lt;field spec&gt;</var> is just a <var>&lt;field name&gt;</var> form, it is an
abbreviation for <code>(immutable </code><var>&lt;field name&gt;</var><code>)</code>.

        <p>The <var>&lt;field name&gt;</var>s become, as symbols, the names of the fields in
the record&ndash;type descriptor being created, in the same order.

        <p>The &lsquo;<samp><span class="samp">fields</span></samp>&rsquo; clause may be absent; this is equivalent to an empty
&lsquo;<samp><span class="samp">fields</span></samp>&rsquo; clause. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>parent</b><var> &lt;parent name&gt;<a name="index-parent-376"></a></var><br>
<blockquote><p>Specifies that the record type is to have parent type <var>&lt;parent
name&gt;</var>, where <var>&lt;parent name&gt;</var> is the <var>&lt;record name&gt;</var> of a record
type previously defined using <code>define-record-type</code>.  The
record&ndash;type definition associated with <var>&lt;parent name&gt;</var> must not be
sealed.  If no &lsquo;<samp><span class="samp">parent</span></samp>&rsquo; clause and no &lsquo;<samp><span class="samp">parent-rtd</span></samp>&rsquo;
(<a href="stdlib-records-procedural-layer.html#stdlib-records-procedural-layer">stdlib records procedural layer</a>) clause is present, the record
type is a base type. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>protocol</b><var> &lt;expression&gt;<a name="index-protocol-377"></a></var><br>
<blockquote><p><var>&lt;expression&gt;</var> is evaluated in the same environment as the
<code>define-record-type</code> form, and must evaluate to a protocol
appropriate for the record type being defined.

        <p>The protocol is used to create a record&ndash;constructor descriptor as
described below.  If no &lsquo;<samp><span class="samp">protocol</span></samp>&rsquo; clause is specified, a
constructor descriptor is still created using a default protocol.  The
clause can be absent only if the record type being defined has no parent
type, or if the parent definition does not specify a protocol. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>sealed</b><var> #t<a name="index-sealed-378"></a></var><br>
&mdash; Auxiliary Syntax: <b>sealed</b><var> #f<a name="index-sealed-379"></a></var><br>
<blockquote><p>If this option is specified with operand <code>#t</code>, the defined record
type is sealed, i.e., no extensions of the record type can be created. 
If this option is specified with operand <code>#f</code>, or is absent, the
defined record type is not sealed. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>opaque</b><var> #t<a name="index-opaque-380"></a></var><br>
&mdash; Auxiliary Syntax: <b>opaque</b><var> #f<a name="index-opaque-381"></a></var><br>
<blockquote><p>If this option is specified with operand <code>#t</code>, or if an opaque parent
record type is specified, the defined record type is opaque.  Otherwise,
the defined record type is not opaque.  See the specification of
&lsquo;<samp><span class="samp">record-rtd</span></samp>&rsquo; below for details. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>nongenerative</b><var> &lt;uid&gt;<a name="index-nongenerative-382"></a></var><br>
&mdash; Auxiliary Syntax: <b>nongenerative</b><var><a name="index-nongenerative-383"></a></var><br>
<blockquote><p>This specifies that the record type is nongenerative with uid
<var>&lt;uid&gt;</var>, which must be an <var>&lt;identifier&gt;</var>.  If <var>&lt;uid&gt;</var> is
absent, a unique uid is generated at macro&ndash;expansion time.  If two
record&ndash;type definitions specify the same <var>uid</var>, then the
record&ndash;type definitions should be equivalent, i.e., the implied
arguments to <code>make-record-type-descriptor</code> must be equivalent as
described under <code>make-record-type-descriptor</code>.

        <p>If this condition is not met, it is either considered a syntax violation
or an exception with condition type <code>&amp;assertion</code> is raised.  If the
condition is met, a single record type is generated for both
definitions.

        <p>In the absence of a &lsquo;<samp><span class="samp">nongenerative</span></samp>&rsquo; clause, a new record type is
generated every time a <code>define-record-type</code> form is evaluated:

     <pre class="example">          (let ((f (lambda (x)
                     (define-record-type r ...)
                     (if x r? (make-r ...)))))
            ((f #t) (f #f)))
          &rArr; #f
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>parent-rtd</b><var> &lt;parent rtd&gt; &lt;parent cd&gt;<a name="index-parent_002drtd-384"></a></var><br>
<blockquote><p>Specifies that the record type is to have its parent type specified by
<var>&lt;parent rtd&gt;</var>, which should be an expression evaluating to a
record&ndash;type descriptor, and <var>&lt;parent cd&gt;</var>, which should be an
expression evaluating to a constructor descriptor (<a href="stdlib-records-procedural-layer.html#stdlib-records-procedural-layer"><code>make-record-constructor-descriptor</code></a>).  Either
<var>&lt;parent rtd&gt;</var> or <var>&lt;parent cd&gt;</var> can evaluate to <code>#f</code>.  The
record&ndash;type definition associated with the value of <var>&lt;parent rtd&gt;</var>
must not be sealed.  Moreover, a record&ndash;type definition must not have
both a &lsquo;<samp><span class="samp">parent</span></samp>&rsquo; and a &lsquo;<samp><span class="samp">parent-rtd</span></samp>&rsquo; clause. 
</p></blockquote></div>

   <blockquote>
<strong>Note</strong> The syntactic layer is designed to allow record&ndash;instance
sizes and field offsets to be determined at expand time, i.e., by a
macro definition of <code>define-record-type</code>, as long as the parent (if
any) is known.  Implementations that take advantage of this may generate
less efficient constructor, accessor, and mutator code when the
&lsquo;<samp><span class="samp">parent-rtd</span></samp>&rsquo; clause is used, since the type of the parent is
generally not known until run time.  The &lsquo;<samp><span class="samp">parent</span></samp>&rsquo; clause should
therefore be used instead when possible. 
</blockquote>

   <p>All bindings created by <code>define-record-type</code> (for the record type,
the constructor, the predicate, the accessors, and the mutators) must
have names that are pairwise distinct.

   <p>The constructor created by a <code>define-record-type</code> form is a
procedure as follows:

     <ul>
<li>If there is no &lsquo;<samp><span class="samp">parent</span></samp>&rsquo; clause and no &lsquo;<samp><span class="samp">protocol</span></samp>&rsquo; clause, the
constructor accepts as many arguments as there are fields, in the same
order as they appear in the &lsquo;<samp><span class="samp">fields</span></samp>&rsquo; clause, and returns a record
object with the fields initialized to the corresponding arguments.

     <li>If there is no &lsquo;<samp><span class="samp">parent</span></samp>&rsquo; or &lsquo;<samp><span class="samp">parent-rtd</span></samp>&rsquo; clause and a
&lsquo;<samp><span class="samp">protocol</span></samp>&rsquo; clause, the protocol expression must evaluate to a
procedure that accepts a single argument.  The protocol procedure is
called once during the evaluation of the <code>define-record-type</code> form
with a procedure <var>p</var> as its argument.  It should return a procedure,
which will become the constructor bound to <var>&lt;constructor name&gt;</var>.  The
procedure <var>p</var> accepts as many arguments as there are fields, in the
same order as they appear in the &lsquo;<samp><span class="samp">fields</span></samp>&rsquo; clause, and returns a
record object with the fields initialized to the corresponding
arguments.

     <p>The constructor returned by the protocol procedure can accept an
arbitrary number of arguments, and should call <var>p</var> once to construct
a record object, and return that record object.

     <p>For example, the following protocol expression for a record&ndash;type
definition with three fields creates a constructor that accepts values
for all fields, and initializes them in the reverse order of the
arguments:

     <pre class="example">          (lambda (p)
            (lambda (v1 v2 v3)
              (p v3 v2 v1)))
</pre>
     <li>If there is both a &lsquo;<samp><span class="samp">parent</span></samp>&rsquo; clause and a &lsquo;<samp><span class="samp">protocol</span></samp>&rsquo; clause,
then the protocol procedure is called once with a procedure <var>n</var> as
its argument.  As in the previous case, the protocol procedure should
return a procedure, which will become the constructor bound to
<var>&lt;constructor name&gt;</var>.  However, <var>n</var> is different from <var>p</var> in
the previous case: It accepts arguments corresponding to the arguments
of the constructor of the parent type.  It then returns a procedure
<var>p</var> that accepts as many arguments as there are (additional) fields
in this type, in the same order as in the &lsquo;<samp><span class="samp">fields</span></samp>&rsquo; clause, and
returns a record object with the fields of the parent record types
initialized according to their constructors and the arguments to
<var>n</var>, and the fields of this record type initialized to its arguments
of <var>p</var>.

     <p>The constructor returned by the protocol procedure can accept an
arbitrary number of arguments, and should call <var>n</var> once to construct
the procedure <var>p</var>, and call <var>p</var> once to create the record
object, and finally return that record object.

     <p>For example, the following protocol expression assumes that the
constructor of the parent type takes three arguments:

     <pre class="example">          (lambda (n)
            (lambda (v1 v2 v3 x1 x2 x3 x4)
              (let ((p (n v1 v2 v3)))
                (p x1 x2 x3 x4))))
</pre>
     <p>The resulting constructor accepts seven arguments, and initializes the
fields of the parent types according to the constructor of the parent
type, with <var>v1</var>, <var>v2</var>, and <var>v3</var> as arguments.  It also
initializes the fields of this record type to the values of <var>x1</var>,
<small class="dots">...</small>, <var>x4</var>.

     <li>If there is a &lsquo;<samp><span class="samp">parent</span></samp>&rsquo; clause, but no &lsquo;<samp><span class="samp">protocol</span></samp>&rsquo; clause, then
the parent type must not have a &lsquo;<samp><span class="samp">protocol</span></samp>&rsquo; clause itself.  The
constructor bound to <var>&lt;constructor name&gt;</var> is a procedure that accepts
arguments corresponding to the parent types' constructor first, and then
one argument for each field in the same order as in the &lsquo;<samp><span class="samp">fields</span></samp>&rsquo;
clause.  The constructor returns a record object with the fields
initialized to the corresponding arguments.

     <li>If there is a &lsquo;<samp><span class="samp">parent-rtd</span></samp>&rsquo; clause, then the constructor is as with
a &lsquo;<samp><span class="samp">parent</span></samp>&rsquo; clause, except that the constructor of the parent type
is determined by the constructor descriptor of the &lsquo;<samp><span class="samp">parent-rtd</span></samp>&rsquo;
clause. 
</ul>

   <p>A protocol may perform other actions consistent with the requirements
described above, including mutation of the new record or other side
effects, before returning the record.

   <p>Any definition that takes advantage of implicit naming for the
constructor, predicate, accessor, and mutator names can be rewritten
trivially to a definition that specifies all names explicitly. For
example, the implicit&ndash;naming record definition:

<pre class="example">     (define-record-type frob
       (fields (mutable widget))
       (protocol
         (lambda (p)
           (lambda (n) (p (make-widget n))))))
</pre>
   <p class="noindent">is equivalent to the following explicit&ndash;naming record definition.

<pre class="example">     (define-record-type (frob make-frob frob?)
       (fields (mutable widget
                        frob-widget
                        frob-widget-set!))
       (protocol
         (lambda (p)
           (lambda (n) (p (make-widget n))))))
</pre>
   <p>Also, the implicit&ndash;naming record definition:

<pre class="example">     (define-record-type point (fields x y))
</pre>
   <p class="noindent">is equivalent to the following explicit&ndash;naming record definition:

<pre class="example">     (define-record-type (point make-point point?)
       (fields
         (immutable x point-x)
         (immutable y point-y)))
</pre>
   <p>With implicit naming, it is still possible to specify some of the names
explicitly; for example, the following overrides the choice of accessor
and mutator names for the widget field.

<pre class="example">     (define-record-type frob
       (fields (mutable widget getwid setwid!))
       (protocol
         (lambda (p)
           (lambda (n) (p (make-widget n))))))
</pre>
   <div class="defun">
&mdash; Syntax: <b>record-type-descriptor</b><var> &lt;record name&gt;<a name="index-record_002dtype_002ddescriptor-385"></a></var><br>
<blockquote><p>Evaluates to the record&ndash;type descriptor (see below) associated with the
type specified by <var>&lt;record name&gt;</var>.

        <blockquote>
<strong>NOTE</strong> The <code>record-type-descriptor</code> procedure works on both
opaque and non&ndash;opaque record types. 
</blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Syntax: <b>record-constructor-descriptor</b><var> &lt;record name&gt;<a name="index-record_002dconstructor_002ddescriptor-386"></a></var><br>
<blockquote><p>Evaluates to the record&ndash;constructor descriptor (see below) associated
with <var>&lt;record name&gt;</var>. 
</p></blockquote></div>

   <p>The following example uses the <code>record?</code> procedure from the
<code>(rnrs records inspection (6))</code> library:

<pre class="example">     (define-record-type (point make-point point?)
       (fields (immutable x point-x)
               (mutable y point-y set-point-y!))
       (nongenerative
         point-4893d957-e00b-11d9-817f-00111175eb9e))
     
     (define-record-type (cpoint make-cpoint cpoint?)
       (parent point)
       (protocol
        (lambda (n)
          (lambda (x y c)
            ((n x y) (color-&gt;rgb c)))))
       (fields
         (mutable rgb cpoint-rgb cpoint-rgb-set!)))
     
     (define (color-&gt;rgb c)
       (cons 'rgb c))
     
     (define p1 (make-point 1 2))
     (define p2 (make-cpoint 3 4 'red))
     
     (point? p1)                             &rArr; #t
     (point? p2)                             &rArr; #t
     (point? (vector))                       &rArr; #f
     (point? (cons 'a 'b))                   &rArr; #f
     (cpoint? p1)                            &rArr; #f
     (cpoint? p2)                            &rArr; #f
     (point-x p1)                            &rArr; 1
     (point-y p1)                            &rArr; 2
     (point-x p2)                            &rArr; 3
     (point-y p2)                            &rArr; 4
     (cpoint-rgb p2)                         &rArr; (rgb . red)
     
     (set-point-y! p1 17)                    &rArr; unspecified
     (point-y p1)                            &rArr; 17
     
     (record-rtd p1)
     &rArr; (record-type-descriptor point)
     
     (define-record-type (ex1 make-ex1 ex1?)
       (protocol (lambda (p) (lambda a (p a))))
       (fields (immutable f ex1-f)))
     
     (define ex1-i1 (make-ex1 1 2 3))
     (ex1-f ex1-i1)                          &rArr; (1 2 3)
     
     (define-record-type (ex2 make-ex2 ex2?)
       (protocol
         (lambda (p) (lambda (a . b) (p a b))))
       (fields (immutable a ex2-a)
               (immutable b ex2-b)))
     
     (define ex2-i1 (make-ex2 1 2 3))
     (ex2-a ex2-i1)                          &rArr; 1
     (ex2-b ex2-i1)                          &rArr; (2 3)
     
     (define-record-type (unit-vector
                          make-unit-vector
                          unit-vector?)
       (protocol
        (lambda (p)
          (lambda (x y z)
            (let ((length
                    (sqrt (+ (* x x)
                             (* y y)
                             (* z z)))))
              (p (/ x length)
                 (/ y length)
                 (/ z length))))))
       (fields (immutable x unit-vector-x)
               (immutable y unit-vector-y)
               (immutable z unit-vector-z)))
     
     (define *ex3-instance* #f)
     
     (define-record-type ex3
       (parent cpoint)
       (protocol
        (lambda (n)
          (lambda (x y t)
            (let ((r ((n x y 'red) t)))
              (set! *ex3-instance* r)
              r))))
       (fields
        (mutable thickness))
       (sealed #t) (opaque #t))
     
     (define ex3-i1 (make-ex3 1 2 17))
     (ex3? ex3-i1)                           &rArr; #t
     (cpoint-rgb ex3-i1) &rArr; (rgb . red)
     (ex3-thickness ex3-i1)                  &rArr; 17
     (ex3-thickness-set! ex3-i1 18)          &rArr; unspecified
     (ex3-thickness ex3-i1)                  &rArr; 18
     *ex3-instance*                          &rArr; ex3-i1
     
     (record? ex3-i1)                        &rArr; #f
</pre>
   <!-- page -->
   </body></html>

