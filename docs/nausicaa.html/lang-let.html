<html lang="en">
<head>
<title>lang let - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="lang.html#lang" title="lang">
<link rel="prev" href="lang-lang.html#lang-lang" title="lang lang">
<link rel="next" href="lang-loop.html#lang-loop" title="lang loop">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d3 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="lang-let"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="lang-loop.html#lang-loop">lang loop</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="lang-lang.html#lang-lang">lang lang</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="lang.html#lang">lang</a>
<hr>
</div>

<h3 class="section">9.2 Binding constructs</h3>

<div class="defun">
&mdash; Syntax: <b>and-let*</b><var> &lt;formals&gt; . &lt;body&gt;<a name="index-and_002dlet_002a-924"></a></var><br>
<blockquote><p>Like an ordinary <code>and</code>, an <code>and-let*</code> special form evaluates
the expressions in &lt;formals&gt; in order until the first one that
yields <code>#f</code>.  Unlike <code>and</code>, however, a non&ndash;<code>#f</code> result of
one expression can be bound to a fresh variable and used in the
subsequent expressions.  <code>and-let*</code> is a cross&ndash;breed between
<code>let*</code> and <code>and</code>.

        <p>&lt;formals&gt; can be the empty list, or a list of the following
elements:

          <dl>
<dt><code>(&lt;varname&gt; &lt;expression&gt;)</code><dd>evaluate &lt;expression&gt;; if the result is <code>#f</code>: return <code>#f</code>
immediately, else bind the result to &lt;varname&gt;; &lt;varname&gt; is
available to the rest of the &lt;expressions&gt;, and the <code>BODY</code>;

          <br><dt><code>&lt;expression&gt;</code><dd>evaluate &lt;expression&gt;; if the result is <code>#f</code>: return <code>#f</code>
immediately;

          <br><dt><code>&lt;bound-variable&gt;</code><dd>look up &lt;bound-variable&gt;; if the value is <code>#f</code>; return <code>#f</code>
immediately; &lt;bound-varname&gt; is available to the rest of the
&lt;expressions&gt;, and the &lt;body&gt;. 
</dl>

        <p>If all the &lt;expression&gt;s and &lt;bound-variable&gt;s in &lt;formals&gt;
evaluate to true, the forms in &lt;body&gt; are evaluated and the result
of the last one returned. 
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Syntax: <b>begin0-let</b> ((<var>&lt;var0&gt; &lt;expr0&gt;</var>) (<var>&lt;var&gt; &lt;expr&gt;</var>)<var> ...</var>)<var> &lt;form0&gt; &lt;form&gt; ...<a name="index-begin0_002dlet-925"></a></var><br>
&mdash; Syntax: <b>begin0-let</b> (((<var>&lt;var0&gt; ...</var>)<var> &lt;expr0&gt;</var>) ((<var>&lt;var&gt; ...</var>)<var> &lt;expr&gt;</var>)<var> ...</var>)<var> &lt;form0&gt; &lt;form&gt; ...<a name="index-begin0_002dlet-926"></a></var><br>
<blockquote><p>Bind the result of &lt;expr&gt; to &lt;var&gt; as in <code>let</code> or
<code>let-values</code>, evaluate the forms in the resulting environment, then
return &lt;var0&gt; possibly as multiple values. 
</p></blockquote></div>

<div class="defun">
&mdash; Syntax: <b>begin0-let*</b> ((<var>&lt;var0&gt; &lt;expr0&gt;</var>) (<var>&lt;var&gt; &lt;expr&gt;</var>)<var> ...</var>)<var> &lt;form0&gt; &lt;form&gt; ...<a name="index-begin0_002dlet_002a-927"></a></var><br>
&mdash; Syntax: <b>begin0-letrec</b> ((<var>&lt;var0&gt; &lt;expr0&gt;</var>) (<var>&lt;var&gt; &lt;expr&gt;</var>)<var> ...</var>)<var> &lt;form0&gt; &lt;form&gt; ...<a name="index-begin0_002dletrec-928"></a></var><br>
<blockquote><p>Like <code>begin0-let</code>, but bind the identifiers using <code>let*</code> and
<code>letrec</code>. 
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Syntax: <b>receive</b><var> &lt;formals&gt; &lt;expression&gt; . &lt;body&gt;<a name="index-receive-929"></a></var><br>
<blockquote><p>The mechanism provided for binding identifiers to the values of a
multiple&ndash;valued expression are <code>call-with-values</code>,
<code>let-values</code>, <code>let*-values</code>.  <code>receive</code> is another
concise and readable syntax for creating such bindings.

        <p>&lt;formals&gt; can have any of 3 forms:

          <dl>
<dt><code>(&lt;variable1&gt; ... &lt;variableN&gt;)</code><dd>The environment in which the <code>receive</code>&ndash;expression is evaluated is
extended by binding &lt;variable1&gt;, ..., &lt;variableN&gt; to fresh
locations.  The &lt;expression&gt; is evaluated, and its values are
stored into those locations (it is an error if &lt;expression&gt; does
not have exactly N values).

          <br><dt><code>&lt;variable&gt;</code><dd>The environment in which the <code>receive</code>&ndash;expression is evaluated is
extended by binding &lt;variable&gt; to a fresh location.  The
&lt;expression&gt; is evaluated, its values are converted into a newly
allocated list, and the list is stored in the location bound to
&lt;variable&gt;.

          <br><dt><code>(&lt;variable1&gt; ... &lt;variableN&gt; . &lt;variableN+1&gt;)</code><dd>The environment in which the <code>receive</code>&ndash;expression is evaluated is
extended by binding &lt;variable1&gt;, ..., &lt;variableN+1&gt; to fresh
locations.  The &lt;expression&gt; is evaluated.  Its first N
values are stored into the locations bound to &lt;variable1&gt;, ...,
&lt;variableN&gt;.  Any remaining values are converted into a newly
allocated list, which is stored into the location bound to
&lt;variableN+1&gt; (it is an error if &lt;expression&gt; does not have at
least N values. 
</dl>

        <p>In any case, the expressions in &lt;body&gt; are evaluated sequentially in
the extended environment.  The results of the last expression in the
body are the values of the &lt;receive&gt;&ndash;expression. 
</p></blockquote></div>

<!--  -->
<div class="defun">
&mdash; Syntax: <b>define-values</b> (<var>&lt;var0&gt; &lt;var&gt; ...</var>)<var> &lt;form0&gt; &lt;form&gt; ...<a name="index-define_002dvalues-930"></a></var><br>
<blockquote><p>Evaluate the given forms and bind the, possibly multiple, result of the
last one to the given &lt;var&gt; identifiers. 
</p></blockquote></div>

<!-- page -->
   </body></html>

