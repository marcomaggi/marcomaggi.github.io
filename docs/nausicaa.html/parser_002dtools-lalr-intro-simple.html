<html lang="en">
<head>
<title>parser-tools lalr intro simple - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="parser_002dtools-lalr-intro.html#parser_002dtools-lalr-intro" title="parser-tools lalr intro">
<link rel="prev" href="parser_002dtools-lalr-intro-want.html#parser_002dtools-lalr-intro-want" title="parser-tools lalr intro want">
<link rel="next" href="parser_002dtools-lalr-intro-look.html#parser_002dtools-lalr-intro-look" title="parser-tools lalr intro look">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d6 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="parser-tools-lalr-intro-simple"></a>
<a name="parser_002dtools-lalr-intro-simple"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="parser_002dtools-lalr-intro-look.html#parser_002dtools-lalr-intro-look">parser-tools lalr intro look</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="parser_002dtools-lalr-intro-want.html#parser_002dtools-lalr-intro-want">parser-tools lalr intro want</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="parser_002dtools-lalr-intro.html#parser_002dtools-lalr-intro">parser-tools lalr intro</a>
<hr>
</div>

<h5 class="subsubsection">11.3.1.3 Simplified parser behaviour</h5>

<p>We can describe the desired behaviour of the LR driver in terms of three
basic actions: lookahead, shift, reduce; with the addition of two
special actions: accept, error.  We assume that the parser can consult a
data structure called <dfn>grammar</dfn> and decide what to do, we can think
of it as an associative container.

   <p>We scan the vectors using a variable &lsquo;<samp><span class="samp">p</span></samp>&rsquo; (as in &ldquo;pointer&rdquo;)
holding the index of the current element; at first &lsquo;<samp><span class="samp">p</span></samp>&rsquo; is set to
zero, so it references the terminal &lsquo;<samp><span class="samp">S</span></samp>&rsquo;:

<pre class="example">     #(#f  1  +  2  #&lt;eof&gt;)
     #( S  N  A  N   *eoi*)
        |
        p
</pre>
   <p>The first action is always a <dfn>lookahead</dfn>, that is: to look at the
element at index &lsquo;<samp><span class="samp">1 + p</span></samp>&rsquo; and acquire its category; such element is
always a terminal, in this case with symbol &lsquo;<samp><span class="samp">N</span></samp>&rsquo;.

   <p>The parser searches the grammar for the sequence &lsquo;<samp><span class="samp">S N</span></samp>&rsquo;: it finds
that the action associated to it is a <dfn>shift</dfn>, that is: increment
&lsquo;<samp><span class="samp">p</span></samp>&rsquo; by 1.  The parser obeys:

<pre class="example">     #(#f  1  +  2  #&lt;eof&gt;)
     #( S  N  A  N   *eoi*)
           |
           p
</pre>
   <p>A shift action is similar to pushing a value on a stack; for this
reason, we name the Scheme vectors <dfn>stacks</dfn> and the variable
&lsquo;<samp><span class="samp">p</span></samp>&rsquo; <dfn>stack pointer</dfn>.

   <p>After a shift, the parser always performs a lookahead, it acquires the
symbol &lsquo;<samp><span class="samp">A</span></samp>&rsquo;.  Parser searches the grammar for the sequences &lsquo;<samp><span class="samp">S
N A</span></samp>&rsquo; and &lsquo;<samp><span class="samp">N A</span></samp>&rsquo;, in this order, stopping at the first with an action
associated to it; it finds that &lsquo;<samp><span class="samp">S N A</span></samp>&rsquo; has no action, but &lsquo;<samp><span class="samp">N
A</span></samp>&rsquo; is associated to a shift.  Parser obeys:

<pre class="example">     #(#f  1  +  2  #&lt;eof&gt;)
     #( S  N  A  N   *eoi*)
              |
              p
</pre>
   <p>Again after a shift, the parser performs a lookahead; it acquires the
symbol &lsquo;<samp><span class="samp">N</span></samp>&rsquo;.  Parser searches the grammar for each of the sequences:

<pre class="example">     S N A N
     N A N
     A N
</pre>
   <p class="noindent">stopping at the first with an action associated to it; the action
associated to &lsquo;<samp><span class="samp">N A N</span></samp>&rsquo; is a shift.  Parser obeys:

<pre class="example">     #(#f  1  +  2  #&lt;eof&gt;)
     #( S  N  A  N   *eoi*)
                 |
                 p
</pre>
   <p>After the shift, parser performs a lookahead; it acquires the symbol
&lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo;.  Parser searches the grammar for each of the sequences:

<pre class="example">     S N A N *eoi*
     N A N *eoi*
     A N *eoi*
     N *eoi*
</pre>
   <p class="noindent">stopping at the first with an action associated to it; the action
associated to &lsquo;<samp><span class="samp">N A N *eoi*</span></samp>&rsquo; is a <dfn>reduce</dfn>: take the values
associated to &lsquo;<samp><span class="samp">N A N</span></samp>&rsquo;, that is &lsquo;<samp><span class="samp">1 + 2</span></samp>&rsquo;, and use them as
arguments for the semantic action the grammar associates to &lsquo;<samp><span class="samp">N A N
*eoi*</span></samp>&rsquo;.

   <p>We have established that we want the semantic actions to compute the
given expression, so the result of the evaluation is &lsquo;<samp><span class="samp">3</span></samp>&rsquo;; parser
searches the grammar, finding that the result associated to &lsquo;<samp><span class="samp">N A N
*eoi*</span></samp>&rsquo; has to be of category &lsquo;<samp><span class="samp">N</span></samp>&rsquo;; so it mutates the stacks and the
stack pointer as follows:

<pre class="example">     #(#f  3 #&lt;eof&gt;  #f  #f)
     #( S  N  *eoi*  #f  #f)
           |
           p
</pre>
   <p>After a reduce, parser performs a lookahead; it acquires the symbol
&lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo;, again.  Parser searches the grammar for the sequences
&lsquo;<samp><span class="samp">S N *eoi*</span></samp>&rsquo; and &lsquo;<samp><span class="samp">N *eoi*</span></samp>&rsquo;; it finds the action associated to
&lsquo;<samp><span class="samp">S N *eoi*</span></samp>&rsquo; is <dfn>accept</dfn>, that is: stop parsing and return the
value referenced by the stack pointer, which is &lsquo;<samp><span class="samp">3</span></samp>&rsquo;.

   <p>Let's see, more briefly, what happens when parsing:

<pre class="example">     #(#f  1  +  2  *  3  #&lt;eof&gt;)
     #( S  N  A  N  M  N   *eoi*)
        |
        p
</pre>
   <p class="noindent">everything is the same as before until:

<pre class="example">     #(#f  1  +  2  *  3  #&lt;eof&gt;)
     #( S  N  A  N  M  N   *eoi*)
                 |
                 p
</pre>
   <p class="noindent">in the previous example the lookahead returned &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the
grammar said &ldquo;reduce&rdquo; for &lsquo;<samp><span class="samp">N A N *eoi*</span></samp>&rsquo;; here the lookahead
returns &lsquo;<samp><span class="samp">M</span></samp>&rsquo; and the grammar says &ldquo;shift&rdquo; for &lsquo;<samp><span class="samp">N A N M</span></samp>&rsquo;:

<pre class="example">     #(#f  1  +  2  *  3  #&lt;eof&gt;)
     #( S  N  A  N  M  N   *eoi*)
                    |
                    p
</pre>
   <p class="noindent">the lookahead returns &lsquo;<samp><span class="samp">N</span></samp>&rsquo; and the grammar says &ldquo;shift&rdquo; for
&lsquo;<samp><span class="samp">N M N</span></samp>&rsquo;:

<pre class="example">     #(#f  1  +  2  *  3  #&lt;eof&gt;)
     #( S  N  A  N  M  N   *eoi*)
                       |
                       p
</pre>
   <p class="noindent">the lookahead returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the grammar says &ldquo;reduce&rdquo; for
&lsquo;<samp><span class="samp">N M N *eoi*</span></samp>&rsquo;:

<pre class="example">     #(#f  1  +  6  #&lt;eof&gt;  #f #f)
     #( S  N  A  N   *eoi*  #f #f)
                 |
                 p
</pre>
   <p class="noindent">the lookahead returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the grammar says &ldquo;reduce&rdquo; for
&lsquo;<samp><span class="samp">N A N *eoi*</span></samp>&rsquo;:

<pre class="example">     #(#f  7  #&lt;eof&gt;  #f #f #f #f)
     #( S  N   *eoi*  #f #f #f #f)
           |
           p
</pre>
   <p class="noindent">the lookahead returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the grammar says &ldquo;accept&rdquo; for
&lsquo;<samp><span class="samp">S N *eoi*</span></samp>&rsquo;.

<!-- page -->
   </body></html>

