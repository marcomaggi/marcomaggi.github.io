<html lang="en">
<head>
<title>lalr grammar examples single - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="lalr-grammar-examples.html#lalr-grammar-examples" title="lalr grammar examples">
<link rel="prev" href="lalr-grammar-examples-helpers.html#lalr-grammar-examples-helpers" title="lalr grammar examples helpers">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d4 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="lalr-grammar-examples-single"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="lalr-grammar-examples-helpers.html#lalr-grammar-examples-helpers">lalr grammar examples helpers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="lalr-grammar-examples.html#lalr-grammar-examples">lalr grammar examples</a>
<hr>
</div>

<h5 class="subsubsection">57.5.6.2 Single token parser</h5>

<p>The following example defines a parser accepting only a single token of
category &lsquo;<samp><span class="samp">A</span></samp>&rsquo;, which must be followed by the end&ndash;of&ndash;input
&lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo;.  Every other input sequence causes an error; this includes
an &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; token alone.

<pre class="example">     (define (example . tokens)
       (let* ((lexer        (make-lexer tokens))
              (make-parser  (lalr-parser
                              (output-value: #t)
                              (terminals: '(A))
                              (rules: '((e (A) : $1)))))
              (parser       (make-parser)))
         (parser lexer error-handler)))
     
     ;;Parse the sequence: A *eoi*
     (example (make-token 'A 1))
     &rArr; 1
     
     ;;Parse the sequence: *eoi*
     (example)
     &rArr; ("unexpected end of input" . (eof-object))
</pre>
   <p class="noindent">the following test raises an error:

<pre class="example">     (example (make-token 'A 1)
              (make-token 'A 2)
              (make-token 'A 3)))
     &rArr; ("unexpected end of input" . (eof-object))
</pre>
   <p class="noindent">we will come back to this test when describing the error recovery
mechanism.  <a href="lalr-grammar-error.html#lalr-grammar-error">Error recovery</a>

<!--  -->
<h5 class="subsubheading">Accepting &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; alone</h5>

<p>The following parser defines a grammar which accepts the sequence
&lsquo;<samp><span class="samp">A *eoi*</span></samp>&rsquo;, but also accepts &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; alone.

<pre class="example">     (define (example . tokens)
       (let* ((lexer        (make-lexer tokens))
              (make-parser  (lalr-parser
                              (output-value: #t)
                              (terminals: '(A))
                              (rules: '((e (A) : $1)
                                           ()  : 0))))
              (parser       (make-parser)))
         (parser lexer error-handler)))
     
     ;;Parse the sequence: A *eoi*
     (example (make-token 'A 1))
     &rArr; 1
     
     ;;Parse the sequence: *eoi*
     (example)
     &rArr; 0
</pre>
   <p>When the input is a single &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; token: The parser returns the
value of the semantic action in &lsquo;<samp><span class="samp">() : 0</span></samp>&rsquo;.  When the input is the
sequence &lsquo;<samp><span class="samp">A *eoi*</span></samp>&rsquo;: The parser returns the value of the semantic
action in &lsquo;<samp><span class="samp">(A) : $1</span></samp>&rsquo;.  Let's understand why.

   <p>Using the reasoning of the introduction (see <a href="lalr-intro.html#lalr-intro">lalr intro</a>), we can
imagine the tokens of the sequence &lsquo;<samp><span class="samp">A *eoi*</span></samp>&rsquo; on the following
stacks:

<pre class="example">     #(#f  1  #&lt;eof&gt;)
     #(S   A   *eoi*)
       |
       p
</pre>
   <p class="noindent">the first lookahead returns &lsquo;<samp><span class="samp">A</span></samp>&rsquo; and the action is shift, we
&ldquo;enter&rdquo; the right&ndash;hand side rule &lsquo;<samp><span class="samp">(A)</span></samp>&rsquo;:

<pre class="example">     #(#f  1  #&lt;eof&gt;)
     #(S   A   *eoi*)
           |
           p
</pre>
   <p class="noindent">the second lookahead returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the action is reduce, we
&ldquo;leave&rdquo; the right&ndash;hand side rule &lsquo;<samp><span class="samp">(A)</span></samp>&rsquo;; one couple is popped
from the stack and one couple is pushed:

<pre class="example">     #(#f  1  #&lt;eof&gt;)
     #(S   e   *eoi*)
           |
           p
</pre>
   <p class="noindent">the value has not changed because the semantic clause is just &lsquo;<samp><span class="samp">$1</span></samp>&rsquo;
which is &lsquo;<samp><span class="samp">1</span></samp>&rsquo; itself; the third lookahead returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and
the action is accept (the value &lsquo;<samp><span class="samp">1</span></samp>&rsquo;).

   <p>We can imagine the tokens of the sequence &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; on the following
stacks:

<pre class="example">     #(#f  #&lt;eof&gt;)
     #(S   *eoi*)
       |
       p
</pre>
   <p class="noindent">the first lookahead returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the action is reduce, we
enter and leave the right&ndash;hand side rule &lsquo;<samp><span class="samp">()</span></samp>&rsquo; in a single step; no
couples are popped from the stacks, but a couple is pushed:

<pre class="example">     #(#f  0  #&lt;eof&gt;)
     #(S   e   *eoi*)
           |
           p
</pre>
   <p class="noindent">we see the result of the semantic clause; the second lookahead returns
&lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the action is accept (the value &lsquo;<samp><span class="samp">0</span></samp>&rsquo;).

<!--  -->
<h5 class="subsubheading">Accepting fixed sequences</h5>

<p>The following parser defines a grammar which accepts the following fixed
sequences:

<pre class="example">     *eoi*
     A *eoi*
     A A *eoi*
     A A A *eoi*
</pre>
   <p class="noindent">the return value of the parser is the list of values from the tokens.

<pre class="example">     (define (example . tokens)
       (let* ((lexer        (make-lexer tokens))
              (make-parser  (lalr-parser
                              (output-value: #t)
                              (terminals: '(A))
                              (rules: '((e (A)     : (list $1)
                                           (A A)   : (list $1 $2)
                                           (A A A) : (list $1 $2 $3)
                                           ()      : 0)))))
              (parser       (make-parser)))
         (parser lexer error-handler)))
     
     ;;Parse the sequence: A *eoi*
     (example (make-token 'A 1))
     &rArr; (1)
     
     ;;Parse the sequence: A A *eoi*
     (example (make-token 'A 1)
              (make-token 'A 2))
     &rArr; (1 2)
     
     ;;Parse the sequence: A A A *eoi*
     (example (make-token 'A 1)
              (make-token 'A 2)
              (make-token 'A 3))
     &rArr; (1 2 3)
     
     ;;Parse the sequence: *eoi*
     (example)
     &rArr; 0
</pre>
   <!--  -->
<h5 class="subsubheading">Accepting a sequence of arbitrary length</h5>

<p>The following parser defines a grammar which accepts a sequence of
&lsquo;<samp><span class="samp">A</span></samp>&rsquo; tokens of any length; it also accepts &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; alone.

<pre class="example">     (define (example . tokens)
       (let* ((lexer        (make-lexer tokens))
              (make-parser  (lalr-parser
                              (output-value: #t)
                              (terminals: '(A))
                              (rules: '((e (e A) : $2
                                           (A)   : $1
                                           ()    : 0)))))
              (parser       (make-parser)))
         (parser lexer error-handler)))
     
     ;;Parse the sequence: *eoi*
     (example)
     &rArr; 0
     
     ;;Parse the sequence: A *eoi*
     (example (make-token 'A 1))
     &rArr; 1
     
     ;;Parse the sequence: A A A *eoi*
     (example (make-token 'A 1)
              (make-token 'A 2)
              (make-token 'A 3))
     &rArr; 3
</pre>
   <p class="noindent">in the last test example, notice that the parser's return value is the
value of the last parsed token (&lsquo;<samp><span class="samp">3</span></samp>&rsquo;), while the other values are
discarded.  This is because the whole sequence matches the right&ndash;hand
side rule &lsquo;<samp><span class="samp">(e A)</span></samp>&rsquo; and its semantic clause is &lsquo;<samp><span class="samp">$2</span></samp>&rsquo;, which is
the value of the token matching the last terminal &lsquo;<samp><span class="samp">A</span></samp>&rsquo;.

<!--  -->
<h5 class="subsubheading">Returning all the values from an arbitrary sequence</h5>

<p>If we want all the values in the sequence we can use the following
parser:

<pre class="example">     (define (example . tokens)
       (let* ((lexer        (make-lexer tokens))
              (make-parser  (lalr-parser
                              (output-value: #t)
                              (terminals: '(A))
                              (rules: '((e (e A) : (cons $2 $1)
                                           (A)   : (list $1)
                                           ()    : 0)))))
              (parser       (make-parser)))
         (parser lexer error-handler)))
     
     ;;Parse the sequence: *eoi*
     (example)
     &rArr; 0
     
     ;;Parse the sequence: A *eoi*
     (example (make-token 'A 1))
     &rArr; (1)
     
     ;;Parse the sequence: A A *eoi*
     (example (make-token 'A 1)
              (make-token 'A 2))
     &rArr; (2 1)
     
     ;;Parse the sequence: A A A *eoi*
     (example (make-token 'A 1)
              (make-token 'A 2)
              (make-token 'A 3))
     &rArr; (3 2 1)
</pre>
   <p class="noindent">we notice that the values are returned in reverse order; this is
because, making the semantic clauses explicit, the following are
equivalent:

<pre class="example">     (cons 2 (list 1))
     
     (example (make-token 'A 1)
              (make-token 'A 2))
</pre>
   <p class="noindent">and also the following:

<pre class="example">     (cons 3 (cons 2 (list 1)))
     
     (example (make-token 'A 1)
              (make-token 'A 2)
              (make-token 'A 3))
</pre>
   <p class="noindent">in more detail, when parsing the sequence &lsquo;<samp><span class="samp">A A *eoi*</span></samp>&rsquo; we can
imagine the following stacks:

<pre class="example">     #(#f  1  2  #&lt;eof&gt;)
     #(S   A  A   *eoi*)
       |
       p
</pre>
   <p class="noindent">the first lookahead returns &lsquo;<samp><span class="samp">A</span></samp>&rsquo; and the action is shift:

<pre class="example">     #(#f  1  2  #&lt;eof&gt;)
     #(S   A  A   *eoi*)
           |
           p
</pre>
   <p class="noindent">the second lookahead returns &lsquo;<samp><span class="samp">A</span></samp>&rsquo; and the action is reduce:

<pre class="example">     #(#f  (1)  2  #&lt;eof&gt;)
     #(S    e   A   *eoi*)
            |
            p
</pre>
   <p class="noindent">the third lookahead returns &lsquo;<samp><span class="samp">A</span></samp>&rsquo; and the action is shift:

<pre class="example">     #(#f  (1)  2  #&lt;eof&gt;)
     #(S    e   A   *eoi*)
                |
                p
</pre>
   <p class="noindent">the fourth lookahead returns &lsquo;<samp><span class="samp">A</span></samp>&rsquo; and the action is reduce:

<pre class="example">     #(#f  (2 . (1))  #&lt;eof&gt;  #f)
     #(S    e          *eoi*  #f)
            |
            p
</pre>
   <p class="noindent">and we know that &lsquo;<samp><span class="samp">(2 . (1))</span></samp>&rsquo; is &lsquo;<samp><span class="samp">(2 1)</span></samp>&rsquo;; the fifth lookahead
returns &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; and the action is accept.

<!-- page -->
   </body></html>

