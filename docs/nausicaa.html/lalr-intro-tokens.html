<html lang="en">
<head>
<title>lalr intro tokens - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="lalr-intro.html#lalr-intro" title="lalr intro">
<link rel="next" href="lalr-intro-want.html#lalr-intro-want" title="lalr intro want">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d4 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="lalr-intro-tokens"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="lalr-intro-want.html#lalr-intro-want">lalr intro want</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="lalr-intro.html#lalr-intro">lalr intro</a>
<hr>
</div>

<h4 class="subsection">57.1.1 Splitting expressions in semantic tokens</h4>

<p>The first step is to split the expression in <dfn>tokens</dfn>, that is basic
elements having a semantic meaning.  In &lsquo;<samp><span class="samp">3 * 4 - 5</span></samp>&rsquo; there are five
of them:

<pre class="example">     3       -&gt; number
     *       -&gt; operator
     4       -&gt; number
     -       -&gt; operator
     5       -&gt; number
</pre>
   <p>Splitting the input into tokens is the job of the lexer.  We cannot
decide what the lexer has to do if we do not define the parser grammar
first.

   <p>We can be sure that we want to deal with every number 3 in the
same way, the same goes for every operator *.  But there is more
of this.

   <p>Scheme implements the functions <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>
which can be applied to every Scheme's number object; so it is
reasonable to state that: We are not interested in the concrete value of
each number, but only in the abstract fact that they are numbers.  We
can say that all the number tokens are in the same <dfn>category</dfn>; let's
use the Scheme symbol &lsquo;<samp><span class="samp">N</span></samp>&rsquo; to indicate it.  &lsquo;<samp><span class="samp">N</span></samp>&rsquo; is an
abstraction for each number.

   <p>The Scheme functions <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> are all
applied in the same way, but the arithmetic operators +-*/ are
not: + and - can be both unary and binary, * and
/ take precedence over + and -.  We may come up
with the following alternative categorisations:

     <ul>
<li>All the operator tokens are in the same category.

     <li>The operators + and - are in a category; the operators
* and / are in another category.

     <li>Each operator has its own category. 
</ul>

   <p>Putting all the tokens equal to each other in the same category is
always safe, but it leads to an explosion of the number of categories;
this complicates the definition of the grammar.  Experience shows that
&ldquo;it works&rdquo; to put + and - in a category, let's call it
&lsquo;<samp><span class="samp">A</span></samp>&rsquo; like addition, and * and / in another category,
let's call it &lsquo;<samp><span class="samp">M</span></samp>&rsquo; like multiplication.

   <p>With these abstractions, we can see the expression &lsquo;<samp><span class="samp">3 * 4 - 5</span></samp>&rsquo; as
the following ordered sequence of categorised tokens:

<pre class="example">     [N, 3]  [M, *]  [N, 4]  [A, -]  [N, 5]
</pre>
   <p class="noindent">the parser will not be interested in the concrete values, only in the
categories; so it will see the sequence as just:

<pre class="example">     N M N A N
</pre>
   <p>We want to support parentheses, too.  The semantic meaning of the open
parenthesis is different from the semantic meaning of the closed one;
(1 + 2) makes sense, but (1 + 2( is wrong; giving
different semantic meaning to the parentheses is mandatory to recognise
nested expressions like (1 * (2 + 3)).  So we assign the open
parenthesis to the category &lsquo;<samp><span class="samp">O</span></samp>&rsquo; and the closed one to the category
&lsquo;<samp><span class="samp">C</span></samp>&rsquo;; with these abstractions, the expression:

<pre class="example">     (6 - (7 - 8)) * 2
</pre>
   <p class="noindent">is tokenised by the following ordered sequence (from left to right, then
top to bottom):

<pre class="example">     [O, (]  [N, 6]  [A, -]  [O, (]  [N, 7]  [A, -]
     [N, 8]  [C, )]  [C, )]  [M, *]  [N, 2]
</pre>
   <p class="noindent">but the parser is interested only in the categories:

<pre class="example">     O N A O N A N C C M N
</pre>
   <p>The categories defined so far are not the only ones with which an LR
parser is concerned; we call them <dfn>terminal categories</dfn> or
<dfn>terminal symbols</dfn> or just <dfn>terminals</dfn>, because they are direct
abstractions of concrete values.  In contrast, the other categories are
called <dfn>non&ndash;terminal categories</dfn> or <dfn>non&ndash;terminal symbols</dfn> or
just <dfn>non&ndash;terminals</dfn>, because they are higher level abstractions
for sequences of terminals and nested non&ndash;terminals.

   <p>When modeling a terminal with a Scheme object, we need at least two
fields:

     <ol type=1 start=1>
<li>The Scheme symbol representing the category.

     <li>The Scheme object representing the concrete value.  We can represent:

          <ul>
<li>Number tokens with Scheme number objects.

          <li>Operator tokens with the Scheme functions implementing them.

          <li>Parenthesis tokens with the Scheme characters &lsquo;<samp><span class="samp">#\(</span></samp>&rsquo; and &lsquo;<samp><span class="samp">#\)</span></samp>&rsquo;. 
</ul>
     </ol>

   <p>Experience shows that it is useful to define yet another token: The
end&ndash;of-input; it is used by the lexer to signal the no more tokens are
available.  We need to define a new terminal category for this, let's
call it &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo;.  The concrete value of this terminal is not
important, we can just select &lsquo;<samp><span class="samp">(eof-object)</span></samp>&rsquo;; in what follows we
will display it as &lsquo;<samp><span class="samp">#&lt;eof&gt;</span></samp>&rsquo;.

   <p>Putting all together, given the input expression:

<pre class="example">     (6 - (7 - 8)) * 2
</pre>
   <p class="noindent">the lexer transforms it into the ordered sequence of tokens:

<pre class="example">     [O, (]  [N, 6]  [A, -]  [O, (]  [N, 7]  [A, -]
     [N, 8]  [C, )]  [C, )]  [M, *]  [N, 2]  [*eoi*, #&lt;eof&gt;]
</pre>
   <p class="noindent">and the parser will operate on the terminal categories:

<pre class="example">     O N A O N A N C C M N *eoi*
</pre>
   <!-- page -->
   </body></html>

