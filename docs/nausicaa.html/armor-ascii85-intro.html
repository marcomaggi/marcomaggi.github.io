<html lang="en">
<head>
<title>armor ascii85 intro - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="armor-ascii85.html#armor-ascii85" title="armor ascii85">
<link rel="next" href="armor-ascii85-encode.html#armor-ascii85-encode" title="armor ascii85 encode">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d13 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa/Scheme takes place at:

            `http://github.com/marcomaggi/nausicaa-scheme/'


Copyright (C) 2008-2011 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="armor-ascii85-intro"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="armor-ascii85-encode.html#armor-ascii85-encode">armor ascii85 encode</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="armor-ascii85.html#armor-ascii85">armor ascii85</a>
<hr>
</div>

<h4 class="subsection">67.6.1 Introduction to <acronym>ASCII</acronym>85 encoding</h4>

<p>This encoding differs from <code>base32</code> and <code>base64</code> in that:

     <ul>
<li>The output length depends upon the input data.

     <li>There is no padding. 
</ul>

<!--  -->
<h5 class="subsubheading">The encoder algorithm</h5>

<p>The encoder is meant to prefix the encoded data with the sequence
&lsquo;<samp><span class="samp">&lt;~</span></samp>&rsquo; and to append after the last byte the sequence &lsquo;<samp><span class="samp">~&gt;</span></samp>&rsquo;.

   <p>A string of 4 bytes Bn of binary input are encoded as
follows:

     <ol type=1 start=1>
<li>A tuple bytevector is formed as in:

     <pre class="example">          (define tuple-bv '#vu8(B0 B1 B2 B3))
</pre>
     <p class="noindent">and a tuple number is formed as in:

     <pre class="example">          (define tuple
            (bytevector-u32-ref tuple-bv 0 (endianness big)))
</pre>
     <li>5 moduli Mn resulting from division by 85 are
computed:

     <pre class="example">          (define D0 (div tuple 85))
          (define D1 (div D0 85))
          (define D2 (div D1 85))
          (define D3 (div D2 85))
          
          (define M0 (mod tuple 85))
          (define M1 (mod D0 85))
          (define M2 (mod D1 85))
          (define M3 (mod D2 85))
          (define M4 (mod D3 85))
</pre>
     <li>Character integers Cn are computed:

     <pre class="example">          (define bang-char (char-&gt;integer #\!))
          
          (define C0 (+ bang-char M0))
          (define C1 (+ bang-char M1))
          (define C2 (+ bang-char M2))
          (define C3 (+ bang-char M3))
          (define C4 (+ bang-char M4))
</pre>
     <li>The output bytevector is filled with the integers in &ldquo;reverse&rdquo; order:

     <pre class="example">          (define ascii-bv
            '#vu8(C4 C3 C2 C1 C0))
</pre>
     </ol>

   <p>The integers in the output bytevector are associated (according to
<code>integer-&gt;char</code>) to the characters between &lsquo;<samp><span class="samp">#\!</span></samp>&rsquo; (included)
and &lsquo;<samp><span class="samp">#\u</span></samp>&rsquo; (included).  As a special exception: when there are
4 input bytes and the corresponding tuple number is zero, a
single output byte is encoded, the one corresponding to the <acronym>ASCII</acronym>
character &lsquo;<samp><span class="samp">#\z</span></samp>&rsquo;.

   <p>Binary input is encoded in blocks of length 4, producing blocks
of length 5; the trailing bytes (less than 4) are encoded
in a similar way, starting with tuple bytevectors like:

<pre class="example">     (define tuple-bv-3 '#vu8(B0 B1 B2  0))
     (define tuple-bv-2 '#vu8(B0 B1  0  0))
     (define tuple-bv-1 '#vu8(B0  0  0  0))
</pre>
   <p class="noindent">computing the character integers Cn exaclty as above; finally
storing the characters as follows:

<pre class="example">     (define ascii-out-3 '#vu8(C4 C3 C2 C1))
     (define ascii-out-2 '#vu8(C4 C3 C2))
     (define ascii-out-1 '#vu8(C4 C3))
</pre>
   <p class="noindent">we see that: whichever the number of input bytes, we always have to
compute 5 moduli Mn.

<!--  -->
<h5 class="subsubheading">The decoder algorithm</h5>

<p>The decoder is meant to detect the opening sequence &lsquo;<samp><span class="samp">&lt;~</span></samp>&rsquo; at the
beginning of the encoded stream and the closing sequence &lsquo;<samp><span class="samp">~&gt;</span></samp>&rsquo; at
the end of the decoded stream.

   <p>A string of 5 bytes Cn of <acronym>ASCII</acronym> input characters is
decoded as follows:

     <ol type=1 start=1>
<li>5 moduli Mn are computed:

     <pre class="example">          (define encoded-input
            '#vu8(C4 C3 C2 C1 C0))
          
          (define M4 (- C4 bang-char))
          (define M3 (- C3 bang-char))
          (define M2 (- C2 bang-char))
          (define M1 (- C1 bang-char))
          (define M0 (- C0 bang-char))
</pre>
     <li>A tuple number is computed:

     <pre class="example">          (define bang-char (char-&gt;integer #\!))
          
          (define tuple
            (+ (* M4 85 85 85 85)
               (* M3 85 85 85)
               (* M2 85 85)
               (* M1 85)
                  M0))
</pre>
     <li>4 bytes Bn of binary output are extracted:

     <pre class="example">          (define &gt;&gt; bitwise-arithmetic-shift-right)
          
          (define B0 (bitwise-and #xFF (&gt;&gt; tuple 24)))
          (define B1 (bitwise-and #xFF (&gt;&gt; tuple 16)))
          (define B2 (bitwise-and #xFF (&gt;&gt; tuple  8)))
          (define B3 (bitwise-and #xFF     tuple))
</pre>
     <li>The output bytevector is formed:

     <pre class="example">          (define binary-output
            '#vu8(B0 B1 B2 B3))
</pre>
     </ol>

   <p><acronym>ASCII</acronym> input is decoded in blocks of length 5, producing blocks
of length 4; the trailing bytes (less than 5 more than
1) are decoded in a similar way, starting with tuple numbers
like:

<pre class="example">     (define tuple-4
       (+ (* M4 85 85 85 85)
          (* M3 85 85 85)
          (* M2 85 85)
          (* M1 85)
                85))
     
     (define tuple-3
       (+ (* M4 85 85 85 85)
          (* M3 85 85 85)
          (* M2 85 85)
          (*    85 85)))
     
     (define tuple-2
       (+ (* M4 85 85 85 85)
          (* M3 85 85 85)
          (*    85 85 85)))
</pre>
   <p class="noindent">and forming output bytevectors like:

<pre class="example">     (define binary-output-4 '#vu8(B0 B1 B2))
     (define binary-output-3 '#vu8(B0 B1))
     (define binary-output-2 '#vu8(B0))
</pre>
   <p>As a special exception: when an input byte associated to the character
&lsquo;<samp><span class="samp">#\z</span></samp>&rsquo; is found in the <acronym>ASCII</acronym> input, 4 zero bytes are
appended to the binary output.  The &lsquo;<samp><span class="samp">#\z</span></samp>&rsquo; character is legal only
at the <strong>beginning</strong> of an input block of 5 characters and
at the <strong>beginning</strong> of the last block of trailing characters. 
Trailing characters must come in blocks of at least 2 bytes.

<!-- page -->
   </body></html>

