<html lang="en">
<head>
<title>stdlib enum - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="stdlib.html#stdlib" title="stdlib">
<link rel="prev" href="stdlib-hashtable.html#stdlib-hashtable" title="stdlib hashtable">
<link rel="next" href="stdlib-complib.html#stdlib-complib" title="stdlib complib">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d12 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008-2011 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="stdlib-enum"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="stdlib-complib.html#stdlib-complib">stdlib complib</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="stdlib-hashtable.html#stdlib-hashtable">stdlib hashtable</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="stdlib.html#stdlib">stdlib</a>
<hr>
</div>

<h3 class="section">4.14 Enumerations</h3>

<p><a name="index-g_t_0040rsixlibrary_007benums_007d_002c-library-849"></a><a name="index-Library_002c-_0040rsixlibrary_007benums_007d-850"></a>

   <p>This chapter describes the <code>(rnrs enums (6))</code> library for dealing with
enumerated values and sets of enumerated values.  Enumerated values are
represented by ordinary symbols, while finite sets of enumerated values
form a separate type, known as the <dfn>enumeration sets</dfn>.  The
enumeration sets are further partitioned into sets that share the same
<dfn>universe</dfn> and <dfn>enumeration type</dfn>.  These universes and
enumeration types are created by the <code>make-enumeration</code> procedure. 
Each call to that procedure creates a new enumeration type.

   <p>This library interprets each enumeration set with respect to its
specific universe of symbols and enumeration type.  This facilitates
efficient implementation of enumeration sets and enables the complement
operation.

   <p>In the descriptions of the following procedures, <var>enum-set</var> ranges
over the enumeration sets, which are defined as the subsets of the
universes that can be defined using <code>make-enumeration</code>.

<div class="defun">
&mdash; Procedure: <b>make-enumeration</b><var> symbol-list<a name="index-make_002denumeration-851"></a></var><br>
<blockquote><p><var>symbol-list</var> must be a list of symbols.

        <p>The <code>make-enumeration</code> procedure creates a new enumeration type
whose universe consists of those symbols (in canonical order of their
first appearance in the list) and returns that universe as an
enumeration set whose universe is itself and whose enumeration type is
the newly created enumeration type. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>enum-set-universe</b><var> enum-set<a name="index-enum_002dset_002duniverse-852"></a></var><br>
<blockquote><p>Return the set of all symbols that comprise the universe of its
argument, as an enumeration set. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>enum-set-indexer</b><var> enum-set<a name="index-enum_002dset_002dindexer-853"></a></var><br>
<blockquote><p>Return a unary procedure that, given a symbol that is in the universe of
<var>enum-set</var>, returns its 0&ndash;origin index within the canonical
ordering of the symbols in the universe; given a symbol not in the
universe, the unary procedure returns <code>#f</code>.

     <pre class="example">          (let* ((e (make-enumeration '(red green blue)))
                 (i (enum-set-indexer e)))
            (list (i 'red) (i 'green) (i 'blue) (i 'yellow)))
          &rArr; (0 1 2 #f)
</pre>
        <p>The <code>enum-set-indexer</code> procedure could be defined as follows using
the <code>memq</code> procedure from the <code>(rnrs lists (6))</code> library:

     <pre class="example">          (define (enum-set-indexer set)
            (let* ((symbols (enum-set-&gt;list
                              (enum-set-universe set)))
                   (cardinality (length symbols)))
              (lambda (x)
                (cond
                 ((memq x symbols)
                  =&gt; (lambda (probe)
                       (- cardinality (length probe))))
                 (else #f)))))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>enum-set-constructor</b><var> enum-set<a name="index-enum_002dset_002dconstructor-854"></a></var><br>
<blockquote><p>Return a unary procedure that, given a list of symbols that belong to
the universe of <var>enum-set</var>, returns a subset of that universe that
contains exactly the symbols in the list.  The values in the list must
all belong to the universe. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>enum-set-&gt;list</b><var> enum-set<a name="index-enum_002dset_002d_003elist-855"></a></var><br>
<blockquote><p>Return a list of the symbols that belong to its argument, in the
canonical order of the universe of <var>enum-set</var>.

     <pre class="example">          (let* ((e (make-enumeration '(red green blue)))
                 (c (enum-set-constructor e)))
            (enum-set-&gt;list (c '(blue red))))    &rArr; (red blue)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>enum-set-member?</b><var> symbol enum-set<a name="index-enum_002dset_002dmember_003f-856"></a></var><br>
&mdash; Procedure: <b>enum-set-subset?</b><var> enum-set1 enum-set2<a name="index-enum_002dset_002dsubset_003f-857"></a></var><br>
&mdash; Procedure: <b>enum-set=?</b><var> enum-set1 enum-set2<a name="index-enum_002dset_003d_003f-858"></a></var><br>
<blockquote><p>The <code>enum-set-member?</code> procedure returns <code>#t</code> if its first
argument is an element of its second argument, <code>#f</code> otherwise.

        <p>The <code>enum-set-subset?</code> procedure returns <code>#t</code> if the universe of
<var>enum-set1</var> is a subset of the universe of <var>enum-set2</var>
(considered as sets of symbols) and every element of <var>enum-set1</var> is
a member of <var>enum-set2</var>.  It returns <code>#f</code> otherwise.

        <p>The <code>enum-set=?</code> procedure returns <code>#t</code> if <var>enum-set1</var> is a
subset of <var>enum-set2</var> and vice versa, as determined by the
<code>enum-set-subset?</code> procedure.  This implies that the universes of
the two sets are equal as sets of symbols, but does not imply that they
are equal as enumeration types.  Otherwise, <code>#f</code> is returned.

     <pre class="example">          (let* ((e (make-enumeration '(red green blue)))
                 (c (enum-set-constructor e)))
            (list
             (enum-set-member? 'blue (c '(red blue)))
             (enum-set-member? 'green (c '(red blue)))
             (enum-set-subset? (c '(red blue)) e)
             (enum-set-subset? (c '(red blue)) (c '(blue red)))
             (enum-set-subset? (c '(red blue)) (c '(red)))
             (enum-set=? (c '(red blue)) (c '(blue red)))))
          &rArr; (#t #f #t #t #f #t)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>enum-set-union</b><var> enum-set1 enum-set2<a name="index-enum_002dset_002dunion-859"></a></var><br>
&mdash; Procedure: <b>enum-set-intersection</b><var> enum-set1 enum-set2<a name="index-enum_002dset_002dintersection-860"></a></var><br>
&mdash; Procedure: <b>enum-set-difference</b><var> enum-set1 enum-set2<a name="index-enum_002dset_002ddifference-861"></a></var><br>
<blockquote><p><var>enum-set1</var> and <var>enum-set2</var> must be enumeration sets that have
the same enumeration type.

        <p>The <code>enum-set-union</code> procedure returns the union of <var>enum-set1</var>
and <var>enum-set2</var>.  The <code>enum-set-intersection</code> procedure
returns the intersection of <var>enum-set1</var> and <var>enum-set2</var>.  The
<code>enum-set-difference</code> procedure returns the difference of
<var>enum-set1</var> and <var>enum-set2</var>.

     <pre class="example">          (let* ((e (make-enumeration '(red green blue)))
                 (c (enum-set-constructor e)))
            (list (enum-set-&gt;list
                   (enum-set-union (c '(blue)) (c '(red))))
                  (enum-set-&gt;list
                   (enum-set-intersection (c '(red green))
                                          (c '(red blue))))
                  (enum-set-&gt;list
                   (enum-set-difference (c '(red green))
                                        (c '(red blue))))))
          &rArr; ((red blue) (red) (green))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>enum-set-complement</b><var> enum-set<a name="index-enum_002dset_002dcomplement-862"></a></var><br>
<blockquote><p>Return <var>enum-set</var>'s complement with respect to its universe.

     <pre class="example">          (let* ((e (make-enumeration '(red green blue)))
                 (c (enum-set-constructor e)))
            (enum-set-&gt;list
              (enum-set-complement (c '(red)))))
          &rArr; (green blue)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>enum-set-projection</b><var> enum-set1 enum-set2<a name="index-enum_002dset_002dprojection-863"></a></var><br>
<blockquote><p>Project <var>enum-set1</var> into the universe of <var>enum-set2</var>, dropping
any elements of <var>enum-set1</var> that do not belong to the universe of
<var>enum-set2</var>.  (If <var>enum-set1</var> is a subset of the universe of
<var>enum-set2</var>, no elements are dropped, and the injection is
returned.)

     <pre class="example">          (let ((e1 (make-enumeration
                      '(red green blue black)))
                (e2 (make-enumeration
                      '(red black white))))
            (enum-set-&gt;list
              (enum-set-projection e1 e2))))
          &rArr; (red black)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Syntax: <b>define-enumeration</b><var> ?type-name </var>(<var>?symbol <small class="dots">...</small></var>)<var> ?constructor-syntax<a name="index-define_002denumeration-864"></a></var><br>
<blockquote><p>The <code>define-enumeration</code> form defines an enumeration type and
provides two macros for constructing its members and sets of its
members.

        <p>A <code>define-enumeration</code> form is a definition and can appear anywhere
any other <var>?definition</var> can appear.

        <p><var>?type-name</var> is an identifier that is bound as a syntactic keyword;
<var>?symbol</var> <small class="dots">...</small> are the symbols that comprise the universe of the
enumeration (in order).

        <p><code>(</code><var>?type-name</var> <var>?symbol</var><code>)</code> checks at macro-expansion time
whether the name of <var>?symbol</var> is in the universe associated with
<var>?type-name</var>.  If it is, <code>(</code><var>?type-name</var> <var>?symbol</var><code>)</code>
is equivalent to <var>?symbol</var>.  It is a syntax violation if it
is not.

        <p><var>?constructor-syntax</var> is an identifier that is bound to a macro
that, given any finite sequence of the symbols in the universe, possibly
with duplicates, expands into an expression that evaluates to the
enumeration set of those symbols.

        <p><code>(</code><var>?constructor-syntax</var> <var>?symbol</var><code> ...)</code> checks at
macro-expansion time whether every <var>?symbol</var> ... is in the universe
associated with <var>?type-name</var>.  It is a syntax violation if one or
more is not.  Otherwise:

     <pre class="example">          (<var>?constructor-syntax</var> <var>?symbol</var> ...)
</pre>
        <p class="noindent">is equivalent to:

     <pre class="example">          ((enum-set-constructor (<var>?constructor-syntax</var>))
           '(<var>?symbol</var> ...))
</pre>
        <p>Example:

     <pre class="example">          (define-enumeration color
            (black white purple maroon)
            color-set)
          
          (color black)                      &rArr; black
          (color purpel)                     &rArr; exception &amp;syntax
          (enum-set-&gt;list (color-set))       &rArr; ()
          (enum-set-&gt;list
            (color-set maroon white))        &rArr; (white maroon)
</pre>
        <blockquote>
<strong>NOTE</strong> In the forms:

     <pre class="example">          (<var>?type-name</var> <var>?symbol</var>)
          (<var>?constructor-syntax</var> <var>?symbol</var> ...)
</pre>
        <p class="noindent">only the names of the <var>?symbol</var>s are significant. 
</blockquote>
        </p></blockquote></div>

<!-- page -->
   </body></html>

