<html lang="en">
<head>
<title>parser-tools lalr grammar precedence - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="parser_002dtools-lalr-grammar.html#parser_002dtools-lalr-grammar" title="parser-tools lalr grammar">
<link rel="prev" href="parser_002dtools-lalr-grammar-error.html#parser_002dtools-lalr-grammar-error" title="parser-tools lalr grammar error">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d7 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="parser-tools-lalr-grammar-precedence"></a>
<a name="parser_002dtools-lalr-grammar-precedence"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="parser_002dtools-lalr-grammar-error.html#parser_002dtools-lalr-grammar-error">parser-tools lalr grammar error</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="parser_002dtools-lalr-grammar.html#parser_002dtools-lalr-grammar">parser-tools lalr grammar</a>
<hr>
</div>

<h5 class="subsubsection">12.3.5.6 Operator precedence and associativity</h5>

<p>It is possible to explicitly assign precedences and associativity to
terminal symbols and productions a la Yacc.  Conflicts in the grammar
are handled in a conventional way, in the absence of precedence
directives: Shift/Reduce conflicts are resolved by shifting, and
Reduce/Reduce conflicts are resolved by choosing the rule listed first
in the grammar definition.

   <p>Let's define two operators &lsquo;<samp><span class="samp">ADD</span></samp>&rsquo; and &lsquo;<samp><span class="samp">MUL</span></samp>&rsquo; and the grammar:

<pre class="example">     ((EXPR (EXPR ADD EXPR)
            (EXPR MUL EXPR)
            (NUM)))
</pre>
   <!--  -->
<h5 class="subsubheading">Operator precedence</h5>

<p>Operator precedence is represented by an <dfn>operator index</dfn>: a
non&ndash;negative exact integer; the higher the integer the higher the
precedence.  When composing the <code>terminals:</code> clause:

     <ul>
<li>If we just write the terminal symbol, its precedence will be 0.

     <li>If we use an associativity specifier: its precedence index is 1
higher than its last predecessor in the list having an associativity
specification; if it is the first: its precedence index is 1. 
</ul>

<p class="noindent">examples:

<pre class="example">     ;;All the terminals have precedence index 0.
     (terminals: '(NUM ADD SUB MUL DIV))
     
     (terminals: '(NUM               ;precedence 0
                   (nonassoc: ADD)   ;precedence 1
                   (nonassoc: SUB)   ;precedence 2
                   (nonassoc: MUL)   ;precedence 3
                   (nonassoc: DIV))) ;precedence 4
     
     (terminals: '(NUM               ;precedence 0
                   (nonassoc: ADD)   ;precedence 1
                   (left:     SUB)   ;precedence 2
                   (right:    MUL)   ;precedence 3
                   DIV))             ;precedence 0
     
     (terminals: '(NUM               ;precedence 0
                   (left: ADD SUB)   ;precedence 1
                   (left: MUL DIV)   ;precedence 2
                   (right: POW)))    ;precedence 3
     
     (terminals: '(NUM               ;precedence 0
                   (left: ADD SUB)   ;precedence 1
                   (left: MUL DIV)   ;precedence 2
                   (nonassoc: UNARY) ;precedence 3
                   (right: POW)))    ;precedence 4
</pre>
   <p class="noindent">notice that last two examples in which &lsquo;<samp><span class="samp">ADD</span></samp>&rsquo; and &lsquo;<samp><span class="samp">SUB</span></samp>&rsquo; have
the same precedence as do &lsquo;<samp><span class="samp">MUL</span></samp>&rsquo; and &lsquo;<samp><span class="samp">DIV</span></samp>&rsquo;.

   <p>Operator precedence matters when parsing input sequences in which both
appear:

<pre class="example">     NUM ADD NUM MUL NUM
</pre>
     <ul>
<li>If &lsquo;<samp><span class="samp">ADD</span></samp>&rsquo; and &lsquo;<samp><span class="samp">MUL</span></samp>&rsquo; have the same precedence, there is a
Shift/Reduce conflict; the sequence can be parsed by shifting first as
in:

     <pre class="example">          NUM ADD NUM MUL NUM &rArr; NUM ADD EXPR &rArr; EXPR
</pre>
     <p class="noindent">or by reducing first as in:

     <pre class="example">          NUM ADD NUM MUL NUM &rArr; EXPR MUL NUM &rArr; EXPR
</pre>
     <p class="noindent">the generated parsers choose Shift in this case.

     <li>If &lsquo;<samp><span class="samp">MUL</span></samp>&rsquo; has higher precedence than &lsquo;<samp><span class="samp">ADD</span></samp>&rsquo;, subexpressions
containing &lsquo;<samp><span class="samp">MUL</span></samp>&rsquo; are reduced first no matter if they come before or
after:

     <pre class="example">          NUM ADD NUM MUL NUM &rArr; NUM ADD EXPR &rArr; EXPR
          NUM MUL NUM ADD NUM &rArr; EXPR ADD NUM &rArr; EXPR
</pre>
     </ul>

<!--  -->
<h5 class="subsubheading">Operator associativity</h5>

<p>Operator associativity matters when parsing input sequences in which
only one operator appears:

<pre class="example">     NUM ADD NUM ADD NUM
</pre>
     <ul>
<li>If &lsquo;<samp><span class="samp">ADD</span></samp>&rsquo; is left-associative, because listed in the
<code>terminals:</code> clause with the <code>left:</code> specifier, the first
subexpression is reduced first:

     <pre class="example">          NUM ADD NUM ADD NUM &rArr; EXPR ADD NUM &rArr; EXPR
</pre>
     <li>If &lsquo;<samp><span class="samp">ADD</span></samp>&rsquo; is right&ndash;associative, because listed in the
<code>terminals:</code> clause with the <code>right:</code> specifier, the second
subexpression is reduced first:

     <pre class="example">          NUM ADD NUM ADD NUM &rArr; NUM ADD EXPR &rArr; EXPR
</pre>
     <li>If &lsquo;<samp><span class="samp">ADD</span></samp>&rsquo; is non&ndash;associative, because listed in the
<code>terminals:</code> clause with the <code>nonassoc:</code> specifier, or has
no specified associativity: the expression is parsed as if &lsquo;<samp><span class="samp">ADD</span></samp>&rsquo; is
right&ndash;associative. 
</ul>

<!--  -->
<h5 class="subsubheading">Reduce/Reduce conflits</h5>

<p>Let's consider a different grammar containing two rules, one of which is
a subexpression of the other:

<pre class="example">     ((EXPR (EXPR ADD EXPR)
            (EXPR ADD EXPR ADD EXPR)
            (NUM)))
</pre>
   <p class="noindent">we have a Reduce/Reduce conflict; a sequence like:

<pre class="example">     NUM1 ADD NUM2 ADD NUM2
</pre>
   <p class="noindent">can be parsed by reducing the first subexpression:

<pre class="example">     NUM1 ADD NUM2 ADD NUM2 &rArr; EXPR ADD NUM2 &rArr; EXPR
</pre>
   <p class="noindent">or by reducing the whole expression:

<pre class="example">     NUM1 ADD NUM2 ADD NUM2 &rArr; EXPR
</pre>
   <p class="noindent">the generated parsers select the rule that comes first in the grammar
definition; in the above example the shorter rule comes first.

<!--  -->
<h5 class="subsubheading">Overriding the precedence among non-terminal rules</h5>

<p>It is sometimes desirable to give a rule a higher precedence than it
would have as determined by the contained terminal symbols.  For
example, let's consider the following arithmetic expressions grammar:

<pre class="example">     ((EXPR (ADD EXPR)              : (list $1 $2)
            (SUB EXPR)              : (list $1 $2)
            (EXPR ADD EXPR)         : (list $2 $1 $3)
            (EXPR SUB EXPR)         : (list $2 $1 $3)
            (EXPR MUL EXPR)         : (list $2 $1 $3)
            (EXPR DIV EXPR)         : (list $2 $1 $3)
            (NUM)                   : $1))
</pre>
   <p class="noindent">in which notice the rules defining the unary operators &lsquo;<samp><span class="samp">ADD</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">SUB</span></samp>&rsquo;.  If the terminal symbols are defined as:

<pre class="example">     (terminals: '(NUM
                   (left: ADD SUB)
                   (left: MUL DIV)))
</pre>
   <p class="noindent">multiplication and division will have the right precedence over binary
addition and binary subtraction, but also a wrong precedence over unary
&lsquo;<samp><span class="samp">ADD</span></samp>&rsquo; and &lsquo;<samp><span class="samp">SUB</span></samp>&rsquo;:

<pre class="example">     ADD NUM MUL NUM &rArr; ADD EXPR &rArr; EXPR
     SUB NUM MUL NUM &rArr; SUB EXPR &rArr; EXPR
</pre>
   <p class="noindent">in concrete examples:

<pre class="example">     + 1 * 2 &rArr; + (1 * 2)
     - 1 * 2 &rArr; - (1 * 2)
</pre>
   <p>We can override the precedence of the unary operators by defining
additional terminal symbols with highest precedence:

<pre class="example">     (terminals: '(NUM
                   (left: ADD SUB)
                   (left: MUL DIV))
                   (nonassoc: UADD)
                   (nonassoc: USUB))
</pre>
   <p class="noindent">and use the <code>prec:</code> specifier directly in the grammar definition:

<pre class="example">     ((EXPR (ADD EXPR (prec: UADD)): (list $1 $2)
            (SUB EXPR (prec: USUB)): (list $1 $2)
            (EXPR ADD EXPR)         : (list $2 $1 $3)
            (EXPR SUB EXPR)         : (list $2 $1 $3)
            (EXPR MUL EXPR)         : (list $2 $1 $3)
            (EXPR DIV EXPR)         : (list $2 $1 $3)
            (NUM)                   : $1))
</pre>
   <p class="noindent">this way the unary operators will have the right precedence:

<pre class="example">     ADD NUM MUL NUM &rArr; EXPR MUL EXPR &rArr; EXPR
     SUB NUM MUL NUM &rArr; EXPR MUL EXPR &rArr; EXPR
</pre>
   <p class="noindent">in concrete examples:

<pre class="example">     + 1 * 2 &rArr; (+ 1) * 2
     - 1 * 2 &rArr; (- 1) * 2
</pre>
   <p>In the grammar, the <code>prec:</code> specifier can appear only as last
element in the rule.

<!--  -->
<h5 class="subsubheading">Terminals precedence examples</h5>

<p>Example on the meaning of terminal precedence: two operators with the
same precedence.  Show that Shift/Reduce conflicts are resolved by
choosing Shift.

<pre class="example">     (define make-parser
       (lalr.lalr-parser
        (lalr.output-value: #t)
        (lalr.expect: 0)
        (lalr.terminals: '(NUM   ;precedence 0
                           ADD   ;precedence 0
                           MUL)) ;precedence 0
        (lalr.rules:
         '((EXPR (EXPR ADD EXPR) : (list $2 $1 $3)
                 (EXPR MUL EXPR) : (list $2 $1 $3)
                 (NUM)           : $1)))))
     
     (define-constant ADD        (make-token 'ADD '+))
     (define-constant MUL        (make-token 'MUL '*))
     (define-constant ONE        (make-token 'NUM 1))
     (define-constant TWO        (make-token 'NUM 2))
     (define-constant THREE      (make-token 'NUM 3))
     
     (doit ONE ADD TWO)              &rArr; (+ 1 2)
     (doit ONE MUL TWO)              &rArr; (* 1 2)
     
     (doit ONE ADD TWO MUL THREE)    &rArr; (+ 1 (* 2 3))
     (doit ONE MUL TWO ADD THREE)    &rArr; (* 1 (+ 2 3))
</pre>
   <p>On the meaning of terminal precedence: two non&ndash;associative operators
with different precedence.  Show that precedence always wins.

<pre class="example">     (define make-parser
       (lalr.lalr-parser
        (lalr.output-value: #t)
        (lalr.expect: 0)
        (lalr.terminals: '(NUM               ;precedence 0
                           (nonassoc: ADD)   ;precedence 1
                           (nonassoc: MUL))) ;precedence 2
        (lalr.rules:
         '((EXPR (EXPR ADD EXPR) : (list $2 $1 $3)
                 (EXPR MUL EXPR) : (list $2 $1 $3)
                 (NUM)           : $1)))))
     
     (define-constant ADD        (make-token 'ADD '+))
     (define-constant MUL        (make-token 'MUL '*))
     (define-constant ONE        (make-token 'NUM 1))
     (define-constant TWO        (make-token 'NUM 2))
     (define-constant THREE      (make-token 'NUM 3))
     
     (doit ONE ADD TWO)              &rArr; (+ 1 2)
     (doit ONE MUL TWO)              &rArr; (* 1 2)
     
     (doit ONE ADD TWO MUL THREE)    &rArr; (+ 1 (* 2 3))
     (doit ONE MUL TWO ADD THREE)    &rArr; (+ (* 1 2) 3)
</pre>
   <!--  -->
<h5 class="subsubheading">Terminals associativity examples</h5>

<p>On the meaning of terminal associativity: a left&ndash;associative operator
and a right&ndash;associative operator.

<pre class="example">     (define make-parser
       (lalr.lalr-parser
        (lalr.output-value: #t)
        (lalr.expect: 0)
        (lalr.terminals: '(NUM            ;precedence 0
                           (left:  ADD)   ;precedence 1
                           (right: MUL))) ;precedence 2
        (lalr.rules:
         '((EXPR (EXPR ADD EXPR) : (list $2 $1 $3)
                 (EXPR MUL EXPR) : (list $2 $1 $3)
                 (NUM)           : $1)))))
     
     (define-constant ADD        (make-token 'ADD '+))
     (define-constant MUL        (make-token 'MUL '*))
     (define-constant ONE        (make-token 'NUM 1))
     (define-constant TWO        (make-token 'NUM 2))
     (define-constant THREE      (make-token 'NUM 3))
     
     (doit ONE ADD TWO)              &rArr; (+ 1 2)
     (doit ONE MUL TWO)              &rArr; (* 1 2)
     
     ;;left-associative
     (doit ONE ADD TWO ADD THREE)    &rArr; (+ (+ 1 2) 3)
     
     ;;right-associative
     (doit ONE MUL TWO MUL THREE)    &rArr; (* 1 (* 2 3))
</pre>
   <p>On the meaning of terminal associativity: non&ndash;associative operators and
operators for which the associativity is unspecified are handled as
right&ndash;associative.

<pre class="example">     (define make-parser
       (lalr.lalr-parser
        (lalr.output-value: #t)
        (lalr.expect: 0)
        (lalr.terminals: '(NUM             ;precedence 0
                           (nonassoc: ADD) ;precedence 1
                           MUL))           ;precedence 0
        (lalr.rules:
         '((EXPR (EXPR ADD EXPR) : (list $2 $1 $3)
                 (EXPR MUL EXPR) : (list $2 $1 $3)
                 (NUM)           : $1)))))
     
     (define-constant ADD        (make-token 'ADD '+))
     (define-constant MUL        (make-token 'MUL '*))
     (define-constant ONE        (make-token 'NUM 1))
     (define-constant TWO        (make-token 'NUM 2))
     (define-constant THREE      (make-token 'NUM 3))
     
     (doit ONE ADD TWO)              &rArr; (+ 1 2)
     (doit ONE MUL TWO)              &rArr; (* 1 2)
     
     (doit ONE ADD TWO ADD THREE)    &rArr; (+ 1 (+ 2 3))
     (doit ONE MUL TWO MUL THREE)    &rArr; (* 1 (* 2 3))
</pre>
   <!--  -->
<h5 class="subsubheading">Reduce/Reduce conflicts examples</h5>

<p>On the meaning of Reduce/Reduce conflicts: the longest rule is given
first.  Operator precedence does matter.

<pre class="example">     (define make-parser
       (lalr.lalr-parser
        (lalr.output-value: #t)
        (lalr.expect: 0)
        (lalr.terminals: '(NUM               ;precedence 0
                           ADD               ;precedence 0
                           (nonassoc: SUB)   ;precedence 1
                           (left:     MUL)   ;precedence 2
                           (right:    DIV))) ;precedence 3
        (lalr.rules:
         '((EXPR
            (EXPR ADD EXPR ADD EXPR)     : (list $2 $1 $3 $5)
            (EXPR SUB EXPR SUB EXPR)     : (list $2 $1 $3 $5)
            (EXPR MUL EXPR MUL EXPR)     : (list $2 $1 $3 $5)
            (EXPR DIV EXPR DIV EXPR)     : (list $2 $1 $3 $5)
            (EXPR ADD EXPR)              : (list $2 $1 $3)
            (EXPR SUB EXPR)              : (list $2 $1 $3)
            (EXPR MUL EXPR)              : (list $2 $1 $3)
            (EXPR DIV EXPR)              : (list $2 $1 $3)
            (NUM)                        : $1)))))
     
     (define-constant ADD        (make-token 'ADD '+))
     (define-constant SUB        (make-token 'SUB '-))
     (define-constant MUL        (make-token 'MUL '*))
     (define-constant DIV        (make-token 'DIV '/))
     (define-constant ONE        (make-token 'NUM 1))
     (define-constant TWO        (make-token 'NUM 2))
     (define-constant THREE      (make-token 'NUM 3))
     (define-constant FOUR       (make-token 'NUM 4))
     
     (check (doit ONE ADD TWO)   &rArr; (+ 1 2)
     (check (doit ONE SUB TWO)   &rArr; (- 1 2)
     (check (doit ONE MUL TWO)   &rArr; (* 1 2)
     (check (doit ONE DIV TWO)   &rArr; (/ 1 2)
     
     ;;No associativity specified.
     (doit ONE ADD TWO
           ADD THREE)     &rArr; (+ 1 2 3)
     (doit ONE ADD TWO
           ADD THREE
           ADD FOUR)      &rArr; (+ 1 (+ 2 3 4))
     
     ;;Non-associative operator.
     (doit ONE SUB TWO
           SUB THREE)     &rArr; (- 1 2 3)
     (doit ONE SUB TWO
           SUB THREE
           SUB FOUR)      &rArr; (- 1 (- 2 3 4))
     
     ;;Left-associative operator.
     (doit ONE MUL TWO
           MUL THREE)     &rArr; (* (* 1 2) 3)
     (doit ONE MUL TWO
           MUL THREE
           MUL FOUR)      &rArr; (* (* (* 1 2) 3) 4)
     
     ;;Right-associative operator.
     (doit ONE DIV TWO
           DIV THREE)     &rArr; (/ 1 2 3)
     (doit ONE DIV TWO
           DIV THREE
           DIV FOUR)      &rArr; (/ 1 (/ 2 3 4))
</pre>
   <p>On the meaning of Reduce/Reduce conflicts: the longest rule is given
last.  Operator precedence does matter.

<pre class="example">     (define make-parser
       (lalr.lalr-parser
        (lalr.output-value: #t)
        (lalr.expect: 0)
        (lalr.terminals: '(NUM               ;precedence 0
                           ADD               ;precedence 0
                           (nonassoc: SUB)   ;precedence 1
                           (left:     MUL)   ;precedence 2
                           (right:    DIV))) ;precedence 3
        (lalr.rules:
         '((EXPR
            (EXPR ADD EXPR)              : (list $2 $1 $3)
            (EXPR SUB EXPR)              : (list $2 $1 $3)
            (EXPR MUL EXPR)              : (list $2 $1 $3)
            (EXPR DIV EXPR)              : (list $2 $1 $3)
            (EXPR ADD EXPR ADD EXPR)     : (list $2 $1 $3 $5)
            (EXPR SUB EXPR SUB EXPR)     : (list $2 $1 $3 $5)
            (EXPR MUL EXPR MUL EXPR)     : (list $2 $1 $3 $5)
            (EXPR DIV EXPR DIV EXPR)     : (list $2 $1 $3 $5)
            (NUM)                        : $1)))))
     
     (define-constant ADD        (make-token 'ADD '+))
     (define-constant SUB        (make-token 'SUB '-))
     (define-constant MUL        (make-token 'MUL '*))
     (define-constant DIV        (make-token 'DIV '/))
     (define-constant ONE        (make-token 'NUM 1))
     (define-constant TWO        (make-token 'NUM 2))
     (define-constant THREE      (make-token 'NUM 3))
     (define-constant FOUR       (make-token 'NUM 4))
     
     (doit ONE ADD TWO)   &rArr; (+ 1 2)
     (doit ONE SUB TWO)   &rArr; (- 1 2)
     (doit ONE MUL TWO)   &rArr; (* 1 2)
     (doit ONE DIV TWO)   &rArr; (/ 1 2)
     
     ;;No associativity specified.  Handled as right-associative
     ;;operator.
     (doit ONE ADD TWO
           ADD THREE)     &rArr; (+ 1 (+ 2 3))
     (doit ONE ADD TWO
           ADD THREE
           ADD FOUR)      &rArr; (+ 1 (+ 2 (+ 3 4)))
     
     ;;Non-associative operator.  Handled as right-associative
     ;;operator.
     (doit ONE SUB TWO
           SUB THREE)     &rArr; (- 1 (- 2 3))
     (doit ONE SUB TWO
           SUB THREE
           SUB FOUR)      &rArr; (- 1 (- 2 (- 3 4)))
     
     ;;Left-associative operator.
     (doit ONE MUL TWO
           MUL THREE)     &rArr; (* (* 1 2) 3)
     (doit ONE MUL TWO
           MUL THREE
           MUL FOUR)      &rArr; (* (* (* 1 2) 3) 4)
     
     ;;Right-associative operator.
     (doit ONE DIV TWO
           DIV THREE)     &rArr; (/ 1 (/ 2 3))
     (doit ONE DIV TWO
           DIV THREE
           DIV FOUR)      &rArr; (/ 1 (/ 2 (/ 3 4)))
</pre>
   <!-- page -->
   </body></html>

