<html lang="en">
<head>
<title>stdlib list - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="stdlib.html#stdlib" title="stdlib">
<link rel="prev" href="stdlib-bytevector.html#stdlib-bytevector" title="stdlib bytevector">
<link rel="next" href="stdlib-sorting.html#stdlib-sorting" title="stdlib sorting">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d5 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="stdlib-list"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="stdlib-sorting.html#stdlib-sorting">stdlib sorting</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="stdlib-bytevector.html#stdlib-bytevector">stdlib bytevector</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="stdlib.html#stdlib">stdlib</a>
<hr>
</div>

<h3 class="section">4.3 List utilities</h3>

<p><a name="index-g_t_0040rsixlibrary_007blists_007d_002c-library-338"></a><a name="index-Library_002c-_0040rsixlibrary_007blists_007d-339"></a>

   <p>This chapter describes the <code>(rnrs lists (6))</code> library, which contains
various useful procedures that operate on lists.

<div class="defun">
&mdash; Procedure: <b>find</b><var> proc list<a name="index-find-340"></a></var><br>
<blockquote><p><var>proc</var> should accept one argument and return a single value. 
<var>proc</var> should not mutate <var>list</var>.  The <code>find</code> procedure
applies <var>proc</var> to the elements of <var>list</var> in order.  If
<var>proc</var> returns a true value for an element, <code>find</code> immediately
returns that element.  If <var>proc</var> returns <code>#f</code> for all elements
of the list, <code>find</code> returns <code>#f</code>.  <var>proc</var> is always called
in the same dynamic environment as <code>find</code> itself.

     <pre class="example">          (find even? '(3 1 4 1 5 9))
          &rArr; 4
          
          (find even? '(3 1 5 1 5 9))
          &rArr; #f
</pre>
        <p><strong>Implementation responsibilities:</strong> The implementation must check
that <var>list</var> is a chain of pairs up to the found element, or that it
is indeed a list if no element is found.  It should not check that it is
a chain of pairs beyond the found element.  The implementation must
check the restrictions on <var>proc</var> to the extent performed by applying
it as described.  An implementation may check whether <var>proc</var> is an
appropriate argument before applying it. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>for-all</b><var> proc list1 list2 <small class="dots">...</small> listn<a name="index-for_002dall-341"></a></var><br>
&mdash; Procedure: <b>exists</b><var> proc list1 list2 <small class="dots">...</small> listn<a name="index-exists-342"></a></var><br>
<blockquote><p>The <var>list</var>s should all have the same length, and <var>proc</var> should
accept n arguments and return a single value.  <var>proc</var> should
not mutate the <var>list</var> arguments.

        <p>For natural numbers i = 0, 1, <small class="dots">...</small>, the <code>for-all</code>
procedure successively applies <var>proc</var> to arguments x_i^1
<small class="dots">...</small> x_i^n, where x_i^j is the i-th element of
<var>listj</var>, until <code>#f</code> is returned.

        <p>If <var>proc</var> returns true values for all but the last element of
<var>list1</var>, <code>for-all</code> performs a tail call of <var>proc</var> on the
k-th elements, where k is the length of <var>list1</var>.  If
<var>proc</var> returns <code>#f</code> on any set of elements, <code>for-all</code>
returns <code>#f</code> after the first such application of <var>proc</var>.  If the
<var>list</var>s are all empty, <code>for-all</code> returns <code>#t</code>.

        <p>For natural numbers i = 0, 1, <small class="dots">...</small>, the <code>exists</code>
procedure applies <var>proc</var> successively to arguments x_i^1
<small class="dots">...</small> x_i^n, where x_i^j is the i-th element of
<var>listj</var>, until a true value is returned.

        <p>If <var>proc</var> returns <code>#f</code> for all but the last elements of the
<var>list</var>s, <code>exists</code> performs a tail call of <var>proc</var> on the
<em>k</em>th elements, where <em>k</em> is the length of <var>list1</var>.  If
<var>proc</var> returns a true value on any set of elements, <code>exists</code>
returns that value after the first such application of <var>proc</var>.  If
the <var>list</var>s are all empty, <code>exists</code> returns <code>#f</code>.

        <p><var>proc</var> is always called in the same dynamic environment as
<code>for-all</code> or, respectively, <code>exists</code> itself.

     <pre class="example">          (for-all even? '(3 1 4 1 5 9))
          &rArr; #f
          
          (for-all even? '(3 1 4 1 5 9 . 2))
          &rArr; #f
          
          (for-all even? '(2 4 14))
          &rArr; #t
          
          (for-all even? '(2 4 14 . 9))
          error--&gt; exception &amp;assertion
          
          (for-all (lambda (n) (and (even? n) n))
                   '(2 4 14))
          &rArr; 14
          
          (for-all &lt; '(1 2 3) '(2 3 4))
          &rArr; #t
          
          (for-all &lt; '(1 2 4) '(2 3 4))
          &rArr; #f
          
          (exists even? '(3 1 4 1 5 9))
          &rArr; #t
          
          (exists even? '(3 1 1 5 9))
          &rArr; #f
          
          (exists even? '(3 1 1 5 9 . 2))
          error--&gt; exception &amp;assertion
          
          (exists (lambda (n) (and (even? n) n))
                  '(2 1 4 14))
          &rArr; 2
          
          (exists &lt; '(1 2 4) '(2 3 4))
          &rArr; #t
          
          (exists &gt; '(1 2 3) '(2 3 4))
          &rArr; #f
</pre>
        <p><strong>Implementation responsibilities:</strong> The implementation must check
that the <var>list</var>s are chains of pairs to the extent necessary to
determine the return value.  If this requires traversing the lists
entirely, the implementation should check that the <var>list</var>s all have
the same length.  If not, it should not check that the <var>list</var>s are
chains of pairs beyond the traversal.  The implementation must check the
restrictions on <var>proc</var> to the extent performed by applying it as
described.  An implementation may check whether <var>proc</var> is an
appropriate argument before applying it. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>filter</b><var> proc list<a name="index-filter-343"></a></var><br>
&mdash; Procedure: <b>partition</b><var> proc list<a name="index-partition-344"></a></var><br>
<blockquote><p><var>proc</var> should accept one argument and return a single value. 
<var>proc</var> should not mutate <var>list</var>.

        <p>The <code>filter</code> procedure applies <var>proc</var> to each element of
<var>list</var> and returns a list of the elements of <var>list</var> for which
<var>proc</var> returned a true value.

        <p>The <code>partition</code> procedure also applies <var>proc</var> to each element
of <var>list</var>, but returns two values, the first one a list of the
elements of <var>list</var> for which <var>proc</var> returned a true value, and
the second a list of the elements of <var>list</var> for which <var>proc</var>
returned <code>#f</code>.

        <p>In both cases, the elements of the result list(s) are in the same order
as they appear in the input list.  <var>proc</var> is always called in the
same dynamic environment as <code>filter</code> or, respectively,
<code>partition</code> itself.  If multiple returns occur from <code>filter</code>
or <code>partitions</code>, the return values returned by earlier returns are
not mutated.

     <pre class="example">          (filter even? '(3 1 4 1 5 9 2 6))
          &rArr; (4 2 6)
          
          (partition even? '(3 1 4 1 5 9 2 6))
          &rArr; (4 2 6) (3 1 1 5 9)   ; two values
</pre>
        <p><strong>Implementation responsibilities:</strong> The implementation must check
the restrictions on <var>proc</var> to the extent performed by applying it as
described.  An implementation may check whether <var>proc</var> is an
appropriate argument before applying it. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fold-left</b><var> combine nil list1 list2 <small class="dots">...</small> listn<a name="index-fold_002dleft-345"></a></var><br>
<blockquote><p>The <var>list</var>s should all have the same length.  <var>combine</var> must be
a procedure; it should accept one more argument than there are
<var>list</var>s and return a single value; it should not mutate the
<var>list</var> arguments.

        <p>The <code>fold-left</code> procedure iterates the <var>combine</var> procedure over
an accumulator value and the elements of the <var>list</var>s from left to
right, starting with an accumulator value of <var>nil</var>.

        <p>More specifically, <code>fold-left</code> returns <var>nil</var> if the <var>list</var>s
are empty.  If they are not empty, <var>combine</var> is first applied to
<var>nil</var> and the respective first elements of the <var>list</var>s in order. 
The result becomes the new accumulator value, and <var>combine</var> is
applied to the new accumulator value and the respective next elements of
the <var>list</var>.  This step is repeated until the end of the list is
reached; then the accumulator value is returned.

        <p><var>combine</var> is always called in the same dynamic environment as
<code>fold-left</code> itself.

     <pre class="example">          (fold-left + 0 '(1 2 3 4 5))
          &rArr; 15
          
          (fold-left (lambda (a e)
                       (cons e a))
                     '()
                     '(1 2 3 4 5))
          &rArr; (5 4 3 2 1)
          
          (fold-left (lambda (count x)
                       (if (odd? x)
                           (+ count 1)
                         count))
                     0
                     '(3 1 4 1 5 9 2 6 5 3))
          &rArr; 7
          
          (fold-left (lambda (max-len s)
                       (max max-len (string-length s)))
                     0
                     '("longest" "long" "longer"))
          &rArr; 7
          
          (fold-left cons '(q) '(a b c))
          &rArr; ((((q) . a) . b) . c)
          
          (fold-left + 0 '(1 2 3) '(4 5 6))
          &rArr; 21
</pre>
        <p><strong>Implementation responsibilities:</strong> The implementation should
check that the <var>list</var>s all have the same length.  The implementation
must check the restrictions on <var>combine</var> to the extent performed by
applying it as described.  An implementation may check whether
<var>combine</var> is an appropriate argument before applying it. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fold-right</b><var> combine nil list1 list2 <small class="dots">...</small> listn<a name="index-fold_002dright-346"></a></var><br>
<blockquote><p>The <var>list</var>s should all have the same length.  <var>combine</var> must be
a procedure; it should accept one more argument than there are
<var>list</var>s and return a single value; <var>combine</var> should not mutate
the <var>list</var> arguments.

        <p>The <code>fold-right</code> procedure iterates the <var>combine</var> procedure
over the elements of the <var>list</var>s from right to left and an
accumulator value, starting with an accumulator value of <var>nil</var>.

        <p>More specifically, <code>fold-right</code> returns <var>nil</var> if the
<var>list</var>s are empty.  If they are not empty, <var>combine</var> is first
applied to the respective last elements of the <var>list</var>s in order and
<var>nil</var>.  The result becomes the new accumulator value, and
<var>combine</var> is applied to the respective previous elements of the
<var>list</var>s and the new accumulator value.  This step is repeated until
the beginning of the list is reached; then the accumulator value is
returned.

        <p><var>proc</var> is always called in the same dynamic environment as
<code>fold-right</code> itself.

     <pre class="example">          (fold-right + 0 '(1 2 3 4 5))
          &rArr; 15
          
          (fold-right cons '() '(1 2 3 4 5))
          &rArr; (1 2 3 4 5)
          
          (fold-right (lambda (x l)
                        (if (odd? x) (cons x l) l))
                      '()
                      '(3 1 4 1 5 9 2 6 5))
          &rArr; (3 1 1 5 9 5)
          
          (fold-right cons '(q) '(a b c))
          &rArr; (a b c q)
          
          (fold-right + 0 '(1 2 3) '(4 5 6))
          &rArr; 21
</pre>
        <p><strong>Implementation responsibilities:</strong> The implementation should
check that the <var>list</var>s all have the same length.  The implementation
must check the restrictions on <var>combine</var> to the extent performed by
applying it as described.  An implementation may check whether
<var>combine</var> is an appropriate argument before applying it. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>remp</b><var> proc list<a name="index-remp-347"></a></var><br>
&mdash; Procedure: <b>remove</b><var> obj list<a name="index-remove-348"></a></var><br>
&mdash; Procedure: <b>remv</b><var> obj list<a name="index-remv-349"></a></var><br>
&mdash; Procedure: <b>remq</b><var> obj list<a name="index-remq-350"></a></var><br>
<blockquote><p><var>proc</var> should accept one argument and return a single value. 
<var>proc</var> should not mutate <var>list</var>.

        <p>Each of these procedures returns a list of the elements of <var>list</var>
that do not satisfy a given condition.

        <p>The <code>remp</code> procedure applies <var>proc</var> to each element of
<var>list</var> and returns a list of the elements of <var>list</var> for which
<var>proc</var> returned <code>#f</code>.  <var>proc</var> is always called in the same
dynamic environment as <code>remp</code> itself.

        <p>The <code>remove</code>, <code>remv</code>, and <code>remq</code> procedures return a list
of the elements that are not <var>obj</var>.  The <code>remq</code> procedure uses
<code>eq?</code> to compare <var>obj</var> with the elements of <var>list</var>, while
<code>remv</code> uses <code>eqv?</code> and <code>remove</code> uses <code>equal?</code>.

        <p>The elements of the result list are in the same order as they appear in
the input list.  If multiple returns occur from <code>remp</code>, the return
values returned by earlier returns are not mutated.

     <pre class="example">          (remp even? '(3 1 4 1 5 9 2 6 5))
          &rArr; (3 1 1 5 9 5)
          
          (remove 1 '(3 1 4 1 5 9 2 6 5))
          &rArr; (3 4 5 9 2 6 5)
          
          (remv 1 '(3 1 4 1 5 9 2 6 5))
          &rArr; (3 4 5 9 2 6 5)
          
          (remq 'foo '(bar foo baz))
          &rArr; (bar baz)
</pre>
        <p><strong>Implementation responsibilities:</strong> The implementation must check
the restrictions on <var>proc</var> to the extent performed by applying it as
described.  An implementation may check whether <var>proc</var> is an
appropriate argument before applying it. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>memp</b><var> proc list<a name="index-memp-351"></a></var><br>
&mdash; Procedure: <b>member</b><var> obj list<a name="index-member-352"></a></var><br>
&mdash; Procedure: <b>memv</b><var> obj list<a name="index-memv-353"></a></var><br>
&mdash; Procedure: <b>memq</b><var> obj list<a name="index-memq-354"></a></var><br>
<blockquote><p><var>proc</var> should accept one argument and return a single value. 
<var>proc</var> should not mutate <var>list</var>.

        <p>These procedures return the first sublist of <var>list</var> whose car
satisfies a given condition, where the sublists of <var>lists</var> are the
lists returned by <code>(list-tail </code><var>list</var> <var>k</var><code>)</code> for <var>k</var> less
than the length of <var>list</var>.

        <p>The <code>memp</code> procedure applies <var>proc</var> to the cars of the sublists
of <var>list</var> until it finds one for which <var>proc</var> returns a true
value.  <var>proc</var> is always called in the same dynamic environment as
<code>memp</code> itself.

        <p>The <code>member</code>, <code>memv</code>, and <code>memq</code> procedures look for the
first occurrence of <var>obj</var>.  If <var>list</var> does not contain an
element satisfying the condition, then <code>#f</code> (not the empty list) is
returned.  The <code>member</code> procedure uses <code>equal?</code> to compare
<var>obj</var> with the elements of <var>list</var>, while <code>memv</code> uses
<code>eqv?</code> and <code>memq</code> uses <code>eq?</code>.

     <pre class="example">          (memp even? '(3 1 4 1 5 9 2 6 5))
          &rArr; (4 1 5 9 2 6 5)
          
          (memq 'a '(a b c))
          &rArr; (a b c)
          
          (memq 'b '(a b c))
          &rArr; (b c)
          
          (memq 'a '(b c d))
          &rArr; #f
          
          (memq (list 'a) '(b (a) c))
          &rArr; #f
          
          (member (list 'a) '(b (a) c))
          &rArr; ((a) c)
          
          (memq 101 '(100 101 102))
          &rArr; unspecified
          
          (memv 101 '(100 101 102))
          &rArr; (101 102)
</pre>
        <p><strong>Implementation responsibilities:</strong> The implementation must check
that <var>list</var> is a chain of pairs up to the found element, or that it
is indeed a list if no element is found.  It should not check that it is
a chain of pairs beyond the found element.  The implementation must
check the restrictions on <var>proc</var> to the extent performed by applying
it as described.  An implementation may check whether <var>proc</var> is an
appropriate argument before applying it. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>assp</b><var> proc alist<a name="index-assp-355"></a></var><br>
&mdash; Procedure: <b>assoc</b><var> obj alist<a name="index-assoc-356"></a></var><br>
&mdash; Procedure: <b>assv</b><var> obj alist<a name="index-assv-357"></a></var><br>
&mdash; Procedure: <b>assq</b><var> obj alist<a name="index-assq-358"></a></var><br>
<blockquote><p><var>alist</var> (for &ldquo;association list&rdquo;) should be a list of pairs. 
<var>proc</var> should accept one argument and return a single value. 
<var>Proc</var> should not mutate <var>alist</var>.

        <p>These procedures find the first pair in <var>alist</var> whose car field
satisfies a given condition, and returns that pair without traversing
<var>alist</var> further.  If no pair in <var>alist</var> satisfies the condition,
then <code>#f</code> is returned.

        <p>The <code>assp</code> procedure successively applies <var>proc</var> to the car
fields of <var>alist</var> and looks for a pair for which it returns a true
value.  <var>proc</var> is always called in the same dynamic environment as
<code>assp</code> itself.

        <p>The <code>assoc</code>, <code>assv</code>, and <code>assq</code> procedures look for a
pair that has <var>obj</var> as its car.  The <code>assoc</code> procedure uses
<code>equal?</code> to compare <var>obj</var> with the car fields of the pairs in
<var>alist</var>, while <code>assv</code> uses <code>eqv?</code> and <code>assq</code> uses
<code>eq?</code>.

        <p><strong>Implementation responsibilities:</strong> The implementation must check
that <var>alist</var> is a chain of pairs containing pairs up to the found
pair, or that it is indeed a list of pairs if no element is found.  It
should not check that it is a chain of pairs beyond the found element. 
The implementation must check the restrictions on <var>proc</var> to the
extent performed by applying it as described.  An implementation may
check whether <var>proc</var> is an appropriate argument before applying it.

     <pre class="example">          (define d '((3 a) (1 b) (4 c)))
          
          (assp even? d)
          &rArr; (4 c)
          
          (assp odd? d)
          &rArr; (3 a)
          
          (define e '((a 1) (b 2) (c 3)))
          
          (assq 'a e)
          &rArr; (a 1)
          
          (assq 'b e)
          &rArr; (b 2)
          
          (assq 'd e)
          &rArr; #f
          
          (assq (list 'a) '(((a)) ((b)) ((c))))
          &rArr; #f
          
          (assoc (list 'a) '(((a)) ((b)) ((c))))
          &rArr; ((a))
          
          (assq 5 '((2 3) (5 7) (11 13)))
          &rArr; unspecified
          
          (assv 5 '((2 3) (5 7) (11 13)))
          &rArr; (5 7)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>cons*</b><var> obj1 <small class="dots">...</small> objn obj<a name="index-cons_002a-359"></a></var><br>
&mdash; Procedure: <b>cons*</b><var> obj<a name="index-cons_002a-360"></a></var><br>
<blockquote><p>If called with at least two arguments, <code>cons*</code> returns a freshly
allocated chain of pairs whose cars are <var>obj1</var>, <small class="dots">...</small>, <var>objn</var>,
and whose last cdr is <var>obj</var>.  If called with only one argument,
<code>cons*</code> returns that argument.

     <pre class="example">          (cons* 1 2 '(3 4 5))
          &rArr; (1 2 3 4 5)
          
          (cons* 1 2 3)
          &rArr; (1 2 . 3)
          
          (cons* 1)
          &rArr; 1
</pre>
        </blockquote></div>

<!-- page -->
   </body></html>

