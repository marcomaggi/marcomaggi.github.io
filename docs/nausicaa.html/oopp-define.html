<html lang="en">
<head>
<title>oopp define - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="oopp.html#oopp" title="oopp">
<link rel="prev" href="oopp-notation.html#oopp-notation" title="oopp notation">
<link rel="next" href="oopp-parent.html#oopp-parent" title="oopp parent">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d6 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="oopp-define"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="oopp-parent.html#oopp-parent">oopp parent</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="oopp-notation.html#oopp-notation">oopp notation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="oopp.html#oopp">oopp</a>
<hr>
</div>

<h3 class="section">3.3 Defining class and label types</h3>

<p><a name="index-Class-type-definition-9"></a><a name="index-Label-type-definition-10"></a><a name="index-Type_002c-class-definition-11"></a><a name="index-Type_002c-label-definition-12"></a><a name="index-Definition-of-class-types-13"></a><a name="index-Definition-of-label-types-14"></a>

   <p>In the context of the library <code>(nausicaa language oopp)</code>:

     <ul>
<li>A <dfn>class type</dfn> is a regular record type as defined by
<code>(rnrs records syntactic (6))</code>, with the constraints of being
non&ndash;generative and derived only from record types defined with the
syntax <code>define-syntax</code>.  New class types are defined by
<code>define-class</code> which generates auxiliary syntaxes to allow for
virtual fields, methods, <acronym>OOPP</acronym> notation and multiple construction
protocols.

     <li>A <dfn>label type</dfn> is a syntactic interface applicable to either a
record or non&ndash;record value; a label type can have a class type as
parent, but not vice versa.  Label types are defined by
<code>define-label</code> which generates syntaxes to allow for virtual
fields, methods, <acronym>OOPP</acronym> notation and simple construction protocol. 
</ul>

<div class="defun">
&mdash; Macro: <b>define-class</b><var> ?name ?clause ...<a name="index-define_002dclass-15"></a></var><br>
<blockquote><p>Define a new record type satisfying the constraints of a class
definition; expand to a regular record type definition using
<code>(rnrs records syntactic (6))</code> and some additional syntax definitions.

        <p>There is some compatibility between the arguments of <code>define-class</code>
and the arguments of <code>define-record-type</code> from <code>(rnrs records
syntactic (6))</code>:

          <ul>
<li>The form <var>?name</var> is defined in the same way of the first argument of
<code>define-record-type</code>, it can be one among:

          <pre class="example">               <var>?class-id</var>
               (<var>?class-id</var> <var>?constructor-id</var> <var>?predicate-id</var>)
</pre>
          <p class="noindent">where: <var>?class-id</var> is the type identifier; <var>?constructor-id</var> is
the identifier to which the public constructor function is bound;
<var>?predicate-id</var> is the identifier to which the type predicate
function is bound.

          <li>The forms <var>?clause</var> are similar to the clauses of an <acronym>R6RS</acronym> record
type definition, <code>define-class</code> accepts the following clauses:

          <pre class="example">               abstract        nongenerative           parent
               sealed          opaque
               fields          virtual-fields
               method          method-syntax           methods
               protocol        public-protocol         super-protocol
               getter          setter
               maker           satisfies
</pre>
          <p class="noindent">among these, the following clauses are basically defined in the same way
of clauses for <code>define-record-type</code>, with some extensions for
<code>fields</code>:

          <p><a name="index-g_t_0040clause_007bnongenerative_007d-clause-in-class-definitions-16"></a><a name="index-g_t_0040clause_007bparent_007d-clause-in-class-definitions-17"></a><a name="index-g_t_0040clause_007bsealed_007d-clause-in-class-definitions-18"></a><a name="index-g_t_0040clause_007bopaque_007d-clause-in-class-definitions-19"></a><a name="index-g_t_0040clause_007bfields_007d-clause-in-class-definitions-20"></a><a name="index-g_t_0040clause_007bprotocol_007d-clause-in-class-definitions-21"></a>
          <pre class="example">               nongenerative           parent
               sealed                  opaque
               fields                  protocol
</pre>
          <p class="noindent">so a <code>define-record-type</code> syntax use with only these forms can be
converted to <code>define-class</code> by just changing the syntax keyword;
notice that there is no <code>parent-rtd</code> clause. 
</ul>

        <p>Class types are always non&ndash;generative; when the <code>nongenerative</code>
clause is not explicitly used, the <code>(nongenerative)</code> clause is
implicitly added to the definition and a unique type identifier is
automatically generated; however it is safer to explicitly specify the
<acronym>UID</acronym>.

        <p>When the <code>(abstract)</code> clause is present: the class type cannot be
instantiated.

        <p>If the <code>parent</code> clause is not explicitly present: the clause
<code>(parent &lt;top&gt;)</code> is implicitly added to the class definition, all
the classes are derived from <code>&lt;top&gt;</code>.  Notice that the constructor
of <code>&lt;top&gt;</code> accepts no arguments, so the protocol for a class derived
from <code>&lt;top&gt;</code> should be something like:

     <pre class="example">          (protocol (lambda (make-top)
                      (lambda (field ...)
                        ((make-top) field ...))))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Macro: <b>define-label</b><var> ?name ?clause ...<a name="index-define_002dlabel-22"></a></var><br>
<blockquote><p>Define a new label type; expand to a set of syntax definitions and some
functions for constructors and predicates.

        <p>There is some similarity between the arguments of <code>define-label</code>
and the arguments of <code>define-class</code>:

          <ul>
<li>The form <var>?name</var> is defined in the same way of the first argument of
<code>define-class</code>, it can be one among:

          <pre class="example">               <var>?label-id</var>
               (<var>?label-id</var> <var>?constructor-id</var> <var>?predicate-id</var>)
</pre>
          <p class="noindent">where: <var>?label-id</var> is the type identifier; <var>?constructor-id</var> is
the identifier to which the public constructor function is bound;
<var>?predicate-id</var> is the identifier to which the type predicate
function is bound.

          <p>Label constructors are used to build Scheme values with the same syntax
used to build class instances.  Predicates are used to check values
using a custom function specified in the label definition.

          <li>The forms <var>?clause</var> are similar to the clauses of a
<code>define-class</code> definition, <code>define-label</code> accepts the
following clauses:

          <pre class="example">               parent                  nongenerative
               predicate
               protocol                maker
               method                  method-syntax
               methods                 virtual-fields
               getter                  setter
               satisfies               shadows
</pre>
          </ul>

        <p>Label types are always associated to a unique identifier; such
identifier has nothing to do with generative or non&ndash;generative record
types, because a label is not a record type.  When the
<code>nongenerative</code> clause is not explicitly used, the
<code>(nongenerative)</code> clause is implicitly added to the definition and
a unique type identifier is automatically generated; however it is safer
to explicitly specify the <acronym>UID</acronym>.

        <p>If the <code>parent</code> clause is not explicitly present: the clause
<code>(parent &lt;top&gt;)</code> is implicitly added to the label definition, all
the labels are derived from <code>&lt;top&gt;</code>.  Notice that the semantics of
label constructor protocols is <strong>not</strong> the same as the semantics of
class constructor protocols; a label protocol function does <strong>not</strong>
accept the parent's constructor function as argument. 
</p></blockquote></div>

<!-- page -->
   </body></html>

