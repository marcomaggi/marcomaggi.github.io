<html lang="en">
<head>
<title>stdlib arithmetics flonum - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="stdlib-arithmetics.html#stdlib-arithmetics" title="stdlib arithmetics">
<link rel="prev" href="stdlib-arithmetics-fixnum.html#stdlib-arithmetics-fixnum" title="stdlib arithmetics fixnum">
<link rel="next" href="stdlib-arithmetics-exact-bitwise.html#stdlib-arithmetics-exact-bitwise" title="stdlib arithmetics exact bitwise">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d4 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="stdlib-arithmetics-flonum"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="stdlib-arithmetics-exact-bitwise.html#stdlib-arithmetics-exact-bitwise">stdlib arithmetics exact bitwise</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="stdlib-arithmetics-fixnum.html#stdlib-arithmetics-fixnum">stdlib arithmetics fixnum</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="stdlib-arithmetics.html#stdlib-arithmetics">stdlib arithmetics</a>
<hr>
</div>

<h4 class="subsection">4.11.3 Flonums</h4>

<p><a name="index-g_t_0040rsixlibrary_007barithmetic-flonums_007d_002c-library-721"></a><a name="index-Library_002c-_0040rsixlibrary_007barithmetic-flonums_007d-722"></a>

   <p>This section describes the <code>(rnrs arithmetic flonums (6))</code> library.

   <p>This section uses <var>fl</var>, <var>fl1</var>, <var>fl2</var>, etc., as parameter
names for arguments that must be flonums, and <var>ifl</var> as a name for
arguments that must be integer&ndash;valued flonums, i.e., flonums for which
the <code>integer-valued?</code> predicate returns true.

<div class="defun">
&mdash; Procedure: <b>flonum?</b><var> obj<a name="index-flonum_003f-723"></a></var><br>
<blockquote><p>Return <code>#t</code> if <var>obj</var> is a flonum, <code>#f</code> otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>real-&gt;flonum</b><var> x<a name="index-real_002d_003eflonum-724"></a></var><br>
<blockquote><p>Return the best flonum representation of <var>x</var>.

        <p>The value returned is a flonum that is numerically closest to the
argument.

        <blockquote>
<strong>NOTE</strong> If flonums are represented in binary floating point, then
implementations should break ties by preferring the floating&ndash;point
representation whose least significant bit is zero. 
</blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fl=?</b><var> fl1 fl2 fl3 <small class="dots">...</small><a name="index-fl_003d_003f-725"></a></var><br>
&mdash; Procedure: <b>fl&lt;?</b><var> fl1 fl2 fl3 <small class="dots">...</small><a name="index-fl_003c_003f-726"></a></var><br>
&mdash; Procedure: <b>fl&lt;=?</b><var> fl1 fl2 fl3 <small class="dots">...</small><a name="index-fl_003c_003d_003f-727"></a></var><br>
&mdash; Procedure: <b>fl&gt;?</b><var> fl1 fl2 fl3 <small class="dots">...</small><a name="index-fl_003e_003f-728"></a></var><br>
&mdash; Procedure: <b>fl&gt;=?</b><var> fl1 fl2 fl3 <small class="dots">...</small><a name="index-fl_003e_003d_003f-729"></a></var><br>
<blockquote><p>These procedures return <code>#t</code> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing, <code>#f</code> otherwise. 
These predicates must be transitive.

     <pre class="example">          (fl=? +inf.0 +inf.0)            &rArr; #t
          (fl=? -inf.0 +inf.0)            &rArr; #f
          (fl=? -inf.0 -inf.0)            &rArr; #t
          (fl=? 0.0 -0.0)                 &rArr; #t
          (fl&lt;? 0.0 -0.0)                 &rArr; #f
          (fl=? +nan.0 fl)                &rArr; #f
          (fl&lt;? +nan.0 fl)                &rArr; #f
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flinteger?</b><var> fl<a name="index-flinteger_003f-730"></a></var><br>
&mdash; Procedure: <b>flzero?</b><var> fl<a name="index-flzero_003f-731"></a></var><br>
&mdash; Procedure: <b>flpositive?</b><var> fl<a name="index-flpositive_003f-732"></a></var><br>
&mdash; Procedure: <b>flnegative?</b><var> fl<a name="index-flnegative_003f-733"></a></var><br>
&mdash; Procedure: <b>flodd?</b><var> ifl<a name="index-flodd_003f-734"></a></var><br>
&mdash; Procedure: <b>fleven?</b><var> ifl<a name="index-fleven_003f-735"></a></var><br>
&mdash; Procedure: <b>flfinite?</b><var> fl<a name="index-flfinite_003f-736"></a></var><br>
&mdash; Procedure: <b>flinfinite?</b><var> fl<a name="index-flinfinite_003f-737"></a></var><br>
&mdash; Procedure: <b>flnan?</b><var> fl<a name="index-flnan_003f-738"></a></var><br>
<blockquote><p>These numerical predicates test a flonum for a particular property,
returning <code>#t</code> or <code>#f</code>:

          <dl>
<dt><code>flinteger?</code><dd>procedure tests whether the number object is an integer,

          <br><dt><code>flzero?</code><dd>tests whether it is <code>fl=?</code> to zero,

          <br><dt><code>flpositive?</code><dd>tests whether it is greater than zero,

          <br><dt><code>flnegative?</code><dd>tests whether it is less than zero,

          <br><dt><code>flodd?</code><dd>tests whether it is odd,

          <br><dt><code>fleven?</code><dd>tests whether it is even,

          <br><dt><code>flfinite?</code><dd>tests whether it is not an infinity and not a NaN,

          <br><dt><code>flinfinite?</code><dd>tests whether it is an infinity,

          <br><dt><code>flnan?</code><dd>tests whether it is a NaN. 
</dl>

     <pre class="example">          (flnegative? -0.0)              &rArr; #f
          (flfinite?   +inf.0)            &rArr; #f
          (flfinite?   5.0)               &rArr; #t
          (flinfinite? 5.0)               &rArr; #f
          (flinfinite? +inf.0)            &rArr; #t
</pre>
        <blockquote>
<strong>NOTE</strong> <code>(flnegative? -0.0)</code> must return <code>#f</code>, else it
would lose the correspondence with <code>(fl&lt; -0.0 0.0)</code>, which is
<code>#f</code> according to <acronym>IEEE</acronym> 754. 
</blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flmax</b><var> fl1 fl2 <small class="dots">...</small><a name="index-flmax-739"></a></var><br>
&mdash; Procedure: <b>flmin</b><var> fl1 fl2 <small class="dots">...</small><a name="index-flmin-740"></a></var><br>
<blockquote><p>These procedures return the maximum or minimum of their arguments.  They
always return a NaN when one or more of the arguments is a NaN. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fl+</b><var> fl1 <small class="dots">...</small><a name="index-fl_002b-741"></a></var><br>
&mdash; Procedure: <b>fl*</b><var> fl1 <small class="dots">...</small><a name="index-fl_002a-742"></a></var><br>
<blockquote><p>These procedures return the flonum sum or product of their flonum
arguments.  In general, they should return the flonum that best
approximates the mathematical sum or product.  (For implementations that
represent flonums using <acronym>IEEE</acronym> binary floating point, the meaning of
&ldquo;best&rdquo; is defined by the <acronym>IEEE</acronym> standards.)

     <pre class="example">          (fl+ +inf.0 -inf.0)             &rArr;  +nan.0
          (fl+ +nan.0 <var>fl</var>)           &rArr;  +nan.0
          (fl* +nan.0 <var>fl</var>)           &rArr;  +nan.0
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fl-</b><var> fl1 fl2 <small class="dots">...</small><a name="index-fl_002d-743"></a></var><br>
&mdash; Procedure: <b>fl-</b><var> fl<a name="index-fl_002d-744"></a></var><br>
&mdash; Procedure: <b>fl/</b><var> fl1 fl2 <small class="dots">...</small><a name="index-fl_002f-745"></a></var><br>
&mdash; Procedure: <b>fl/</b><var> fl<a name="index-fl_002f-746"></a></var><br>
<blockquote><p>With two or more arguments, these procedures return the flonum
difference or quotient of their flonum arguments, associating to the
left.

        <p>With one argument, however, they return the additive or multiplicative
flonum inverse of their argument.

        <p>In general, they should return the flonum that best approximates the
mathematical difference or quotient.  (For implementations that
represent flonums using <acronym>IEEE</acronym> binary floating point, the meaning of
&ldquo;best&rdquo; is reasonably well&ndash;defined by the <acronym>IEEE</acronym> standards.)

     <pre class="example">          (fl- +inf.0 +inf.0)             &rArr;  +nan.0
</pre>
        <p>For undefined quotients, <code>fl/</code> behaves as specified by the <acronym>IEEE</acronym>
standards:

     <pre class="example">          (fl/ 1.0 0.0)                   &rArr; +inf.0
          (fl/ -1.0 0.0)                  &rArr; -inf.0
          (fl/ 0.0 0.0)                   &rArr; +nan.0
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flabs</b><var> fl<a name="index-flabs-747"></a></var><br>
<blockquote><p>Return the absolute value of <var>fl</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fldiv-and-mod</b><var> fl1 fl2<a name="index-fldiv_002dand_002dmod-748"></a></var><br>
&mdash; Procedure: <b>fldiv</b><var> fl1 fl2<a name="index-fldiv-749"></a></var><br>
&mdash; Procedure: <b>flmod</b><var> fl1 fl2<a name="index-flmod-750"></a></var><br>
&mdash; Procedure: <b>fldiv0-and-mod0</b><var> fl1 fl2<a name="index-fldiv0_002dand_002dmod0-751"></a></var><br>
&mdash; Procedure: <b>fldiv0</b><var> fl1 fl2<a name="index-fldiv0-752"></a></var><br>
&mdash; Procedure: <b>flmod0</b><var> fl1 fl2<a name="index-flmod0-753"></a></var><br>
<blockquote><p>These procedures implement number&ndash;theoretic integer division and return
the results of the corresponding mathematical operations specified in
report section <a href="baselib-math-semantics-integer.html#baselib-math-semantics-integer">baselib math semantics integer</a>.

        <p>In the cases where the mathematical requirements in <a href="baselib-math-semantics.html#baselib-math-semantics">baselib math semantics</a> cannot be satisfied by any number object, either an exception
is raised with condition type <code>&amp;implementation-restriction</code>, or
unspecified flonums (one for <code>fldiv</code>, <code>flmod</code>, <code>fldiv0</code>
and <code>flmod0</code>, two for <code>fldiv-and-mod</code> and
<code>fldiv0-and-mod0</code>) are returned.

     <pre class="example">          (fldiv <var>fl1</var> <var>fl2</var>)         &rArr; <var>fl1</var> div <var>fl2</var>
          (flmod <var>fl1</var> <var>fl2</var>)         &rArr; <var>fl1</var> mod <var>fl2</var>
          (fldiv-and-mod <var>fl1</var> <var>fl2</var>) &rArr; <var>fl1</var> div <var>fl2</var>, <var>fl1</var> mod <var>fl2</var>
                                                  ; two return values
          (fldiv0 <var>fl1</var> <var>fl2</var>)        &rArr; <var>fl1</var> div_0 <var>fl2</var>
          (flmod0 <var>fl1</var> <var>fl2</var>)        &rArr; <var>fl1</var> mod_0 <var>fl2</var>
          (fldiv0-and-mod0 <var>fl1</var> <var>fl2</var>)
          &rArr; <var>fl1</var> div_0 <var>fl2</var>, <var>fl1</var> mod_0 <var>fl2</var>
             ; two return values
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flnumerator</b><var> fl<a name="index-flnumerator-754"></a></var><br>
&mdash; Procedure: <b>fldenominator</b><var> fl<a name="index-fldenominator-755"></a></var><br>
<blockquote><p>These procedures return the numerator or denominator of <var>fl</var> as a
flonum; the result is computed as if <var>fl</var> was represented as a
fraction in lowest terms.  The denominator is always positive.  The
denominator of 0.0 is defined to be 1.0.

     <pre class="example">          (flnumerator +inf.0)           &rArr; +inf.0
          (flnumerator -inf.0)           &rArr; -inf.0
          (fldenominator +inf.0)         &rArr; 1.0
          (fldenominator -inf.0)         &rArr; 1.0
          (flnumerator 0.75)             &rArr; 3.0 ; probably
          (fldenominator 0.75)           &rArr; 4.0 ; probably
</pre>
        <p>Implementations should implement following behavior:

     <pre class="example">          (flnumerator -0.0)             &rArr; -0.0
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flfloor</b><var> fl<a name="index-flfloor-756"></a></var><br>
&mdash; Procedure: <b>flceiling</b><var> fl<a name="index-flceiling-757"></a></var><br>
&mdash; Procedure: <b>fltruncate</b><var> fl<a name="index-fltruncate-758"></a></var><br>
&mdash; Procedure: <b>flround</b><var> fl<a name="index-flround-759"></a></var><br>
<blockquote><p>These procedures return integral flonums for flonum arguments that are
not infinities or NaNs.

          <dl>
<dt><code>flfloor</code><dd>Returns the largest integral flonum not larger than <var>fl</var>.

          <br><dt><code>flceiling</code><dd>Returns the smallest integral flonum not smaller than <var>fl</var>.

          <br><dt><code>fltruncate</code><dd>Returns the integral flonum closest to <var>fl</var> whose absolute value is
not larger than the absolute value of <var>fl</var>.

          <br><dt><code>flround</code><dd>Returns the closest integral flonum to <var>fl</var>, rounding to even when
<var>fl</var> represents a number halfway between two integers. 
</dl>

        <p>Although infinities and NaNs are not integer objects, these procedures
return an infinity when given an infinity as an argument, and a NaN when
given a NaN:

     <pre class="example">          (flfloor +inf.0)                &rArr; +inf.0
          (flceiling -inf.0)              &rArr; -inf.0
          (fltruncate +nan.0)             &rArr; +nan.0
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flexp</b><var> fl<a name="index-flexp-760"></a></var><br>
&mdash; Procedure: <b>fllog</b><var> fl<a name="index-fllog-761"></a></var><br>
&mdash; Procedure: <b>fllog</b><var> fl1 fl2<a name="index-fllog-762"></a></var><br>
&mdash; Procedure: <b>flsin</b><var> fl<a name="index-flsin-763"></a></var><br>
&mdash; Procedure: <b>flcos</b><var> fl<a name="index-flcos-764"></a></var><br>
&mdash; Procedure: <b>fltan</b><var> fl<a name="index-fltan-765"></a></var><br>
&mdash; Procedure: <b>flasin</b><var> fl<a name="index-flasin-766"></a></var><br>
&mdash; Procedure: <b>flacos</b><var> fl<a name="index-flacos-767"></a></var><br>
&mdash; Procedure: <b>flatan</b><var> fl<a name="index-flatan-768"></a></var><br>
&mdash; Procedure: <b>flatan</b><var> fl1 fl2<a name="index-flatan-769"></a></var><br>
<blockquote><p>These procedures compute the usual transcendental functions.

          <dl>
<dt><code>flexp</code><dd>Computes the base-E exponential of <var>fl</var>.

          <br><dt><code>fllog</code><dd>With a single argument computes the natural logarithm of <var>fl</var> (not
the base ten logarithm); <code>(fllog </code><var>fl1</var> <var>fl2</var><code>)</code> computes
the base&ndash;<var>fl2</var> logarithm of <var>fl1</var>.

          <br><dt><code>flasin</code><dt><code>flacos</code><br><dt><code>flatan</code><dd>Compute arcsine, arccosine, and arctangent, respectively.  <code>(flatan
</code><var>fl1</var> <var>fl2</var><code>)</code> computes the arc tangent of <var>fl1</var>/<var>fl2</var>. 
</dl>

        <p><a href="baselib-math-ops-trascend.html#baselib-math-ops-trascend">baselib math ops trascend</a> for the underlying mathematical
operations.  In the event that these operations do not yield a real
result for the given arguments, the result may be a NaN, or may be some
unspecified flonum.

        <p>Implementations that use <acronym>IEEE</acronym> binary floating&ndash;point arithmetic
should follow the relevant standards for these procedures.

     <pre class="example">          (flexp +inf.0)          &rArr; +inf.0
          (flexp -inf.0)          &rArr; 0.0
          (fllog +inf.0)          &rArr; +inf.0
          (fllog 0.0)             &rArr; -inf.0
          (fllog -0.0)            &rArr; unspecified ; if -0.0 is distinguished
          (fllog -inf.0)          &rArr; +nan.0
          (flatan -inf.0)         &rArr; -1.5707963267948965  ; approximately
          (flatan +inf.0)         &rArr; 1.5707963267948965   ; approximately
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flsqrt</b><var> fl<a name="index-flsqrt-770"></a></var><br>
<blockquote><p>Returns the principal square root of <var>fl</var>.  For -0.0,
<code>flsqrt</code> should return -0.0; for other negative arguments,
the result may be a NaN or some unspecified flonum.

     <pre class="example">          (flsqrt +inf.0)         &rArr; +inf.0
          (flsqrt -0.0)           &rArr; -0.0
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>flexpt</b><var> fl1 fl2<a name="index-flexpt-771"></a></var><br>
<blockquote><p>Either <var>fl1</var> should be non&ndash;negative, or, if <var>fl1</var> is negative,
<var>fl2</var> should be an integer object.

        <p>The <code>flexpt</code> procedure returns <var>fl1</var> raised to the power
<var>fl2</var>.  If <var>fl1</var> is negative and <var>fl2</var> is not an integer
object, the result may be a NaN, or may be some unspecified flonum.

        <p>If <var>fl1</var> and <var>fl2</var> are both zero, the result is 1.0.  If
<var>fl1</var> is zero and <var>fl2</var> is positive, the result is zero.  If
<var>fl1</var> is negative, the result may be a NaN, or may be some
unspecified flonum. 
</p></blockquote></div>

   <p><a name="index-g_t_0026no_002dinfinities-772"></a>

<div class="defun">
&mdash; Condition Type: <b>&amp;no-infinities</b><var><a name="index-g_t_0026no_002dinfinities-773"></a></var><br>
&mdash; Procedure: <b>make-no-infinities-violation</b><var><a name="index-make_002dno_002dinfinities_002dviolation-774"></a></var><br>
&mdash; Procedure: <b>no-infinities-violation?</b><var> obj<a name="index-no_002dinfinities_002dviolation_003f-775"></a></var><br>
&mdash; Condition Type: <b>&amp;no-nans</b><var><a name="index-g_t_0026no_002dnans-776"></a></var><br>
&mdash; Procedure: <b>make-no-nans-violation</b><var><a name="index-make_002dno_002dnans_002dviolation-777"></a></var><br>
&mdash; Procedure: <b>no-nans-violation?</b><var> obj<a name="index-no_002dnans_002dviolation_003f-778"></a></var><br>
<blockquote><p>These condition types could be defined by the following code:

     <pre class="example">          (define-condition-type &amp;no-infinities
              &amp;implementation-restriction
            make-no-infinities-violation
            no-infinities-violation?)
          
          (define-condition-type &amp;no-nans
              &amp;implementation-restriction
            make-no-nans-violation no-nans-violation?)
</pre>
        <p>These types describe that a program has executed an arithmetic
operations that is specified to return an infinity or a NaN,
respectively, on a Scheme implementation that is not able to represent
the infinity or NaN.  <a href="baselib-math-infinities.html#baselib-math-infinities">baselib math infinities</a>. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fixnum-&gt;flonum</b><var> fx<a name="index-fixnum_002d_003eflonum-779"></a></var><br>
<blockquote><p>Return a flonum that is numerically closest to <var>fx</var>.

        <blockquote>
<strong>NOTE</strong> The result of this procedure may not be numerically equal
to <var>fx</var>, because the fixnum precision may be greater than the flonum
precision. 
</blockquote>
        </p></blockquote></div>

<!-- page -->
   </body></html>

