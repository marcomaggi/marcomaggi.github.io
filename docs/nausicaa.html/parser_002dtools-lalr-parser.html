<html lang="en">
<head>
<title>parser-tools lalr parser - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="parser_002dtools-lalr.html#parser_002dtools-lalr" title="parser-tools lalr">
<link rel="prev" href="parser_002dtools-lalr-lexer.html#parser_002dtools-lalr-lexer" title="parser-tools lalr lexer">
<link rel="next" href="parser_002dtools-lalr-grammar.html#parser_002dtools-lalr-grammar" title="parser-tools lalr grammar">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d6 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="parser-tools-lalr-parser"></a>
<a name="parser_002dtools-lalr-parser"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="parser_002dtools-lalr-grammar.html#parser_002dtools-lalr-grammar">parser-tools lalr grammar</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="parser_002dtools-lalr-lexer.html#parser_002dtools-lalr-lexer">parser-tools lalr lexer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="parser_002dtools-lalr.html#parser_002dtools-lalr">parser-tools lalr</a>
<hr>
</div>

<h4 class="subsection">11.3.4 Running the parser</h4>

<p>Here we suppose to have used <code>lalr-parser</code> to generate a proper
Scheme library exporting a binding to the parser maker.  Let
<code>(calc-parser)</code> be the library specification and
<code>make-calc-parser</code> the name of the binding to the parser maker.

   <p>The parser maker is invoked with no arguments and returns a new parser
closure, which represents an instance of the parser.  To create a parser
closure we do:

<pre class="example">     (import (nausicaa)
       (calc-parser))
     
     (define parser (make-calc-parser))
</pre>
   <p>The <code>parser</code> function accepts two or three arguments: the lexer
closure, an error handler procedure, a custom value.  When invoked, it
consumes tokens from the lexer until the end of input is found or an
unrecoverable error occurs.

   <p>To invoke <code>parser</code> with a lexer generated by the library
<code>(nausicaa parser-tools silex)</code>, using a table in
&lsquo;<samp><span class="samp">calc-lexer-table</span></samp>&rsquo; to parse <var>input-string</var>, we do:

<pre class="example">     (import (prefix (nausicaa parser-tools silex lexer) lex.))
     
     (let* ((IS        (lex.make-IS (lex.string: <var>input-string</var>)))
            (lexer     (lex.make-lexer calc-lexer-table IS))
            (error-hnd (lambda (message token) ---))
            (yycustom  #f))
       (parser lexer error-hnd yycustom))
</pre>
   <p>The parser closure will return the value computed by the semantic clause
of the outer non&ndash;terminal, the <dfn>start symbol</dfn>.

<!--  -->
<h5 class="subsubheading">The lexical analyser</h5>

<p>The lexer closure must be a thunk invoked each time the parser needs to
lookahead in the token stream; its return value must be an object of
type <code>&lt;lexical-token&gt;</code>.

   <p>Once the lexer closure finds the end of input, it must return a token
with category &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo;; it must continue to return such a token if
invoked multiple times.

   <p>If the lexer closure finds a lexer error in the input, it must return a
token with category &lsquo;<samp><span class="samp">*lexer-error*</span></samp>&rsquo;; lexer errors are
unrecoverable.

   <p>If the lexer raises an exception, it will go through the parser closure
with no obstacles.

<!--  -->
<h5 class="subsubheading">The error procedure</h5>

<p>It must be a function accepting two arguments: an error message as
Scheme string, the lexical token that caused the error.  Its return
value does not matter for the parser itself.

   <p>If the error procedure returns, the parser closure attempts to recover
from the error and to resume parsing.  If it raises an exception parsing
may stop, depending on how the program deals with it.

   <p>A simple error procedure raising an exception looks like this:

<pre class="example">     (define (error-handler message token)
       (error #f
         (if (not (is-a? token &lt;lexical-token&gt;))
             message
           (let (((T &lt;lexical-token&gt;) token))
             (if (T location unspecified?)
                 message
               (let (((P &lt;source-location&gt;) (T location)))
                 (string-append
                   message
                   " line "   (if (P line)
                                  (P line string)
                                "?")
                   " column " (if (P column)
                                  (P column string)
                                "?"))))))
         token))
</pre>
   <p>The error procedure is invoked:

     <ul>
<li>When an invalid value is returned by the lexer.  If the value is not a
<code>&lt;lexical-token&gt;</code> record, the error procedure is invoked with the
offending value as second argument.

     <p>Parsing stops and the return value of the parser closure is the return
value of the error procedure, if any.

     <li>When the stream of tokens returned by the lexer violates parser's
grammar.

          <ul>
<li>If the error is an unexpected end&ndash;of&ndash;input, the second argument is a
<code>&lt;lexical-token&gt;</code> record with &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; in the category field.

          <p>Parsing stops and the return value of the parser closure is the return
value of the error procedure, if any.

          <li>If the error is another grammar violation, the error procedure is
invoked with the offending value as second argument; its return value,
if any, is discarded.

          <p>If the error procedure returns, the parser will try to recover from the
error and resume parsing; if error recovery fails, the parser behaves as
if the end&ndash;of&ndash;input is found. 
</ul>
     </ul>

<!-- page -->
   </body></html>

