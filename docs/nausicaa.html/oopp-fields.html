<html lang="en">
<head>
<title>oopp fields - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="oopp.html#oopp" title="oopp">
<link rel="prev" href="oopp-predicate.html#oopp-predicate" title="oopp predicate">
<link rel="next" href="oopp-method.html#oopp-method" title="oopp method">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d7 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="oopp-fields"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="oopp-method.html#oopp-method">oopp method</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="oopp-predicate.html#oopp-predicate">oopp predicate</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="oopp.html#oopp">oopp</a>
<hr>
</div>

<h3 class="section">3.10 Defining concrete and virtual fields</h3>

<div class="defun">
&mdash; Auxiliary Syntax: <b>fields</b><var> ?field-spec <small class="dots">...</small><a name="index-fields-40"></a></var><br>
<blockquote><p>Add concrete fields to the enclosing class or mixin definition; labels
cannot have concrete fields.  This clause can be used multiple times in
the same type definition.  We note explicitly that: for concrete fields
the accessor and mutator are automatically generated, and we optionally
have to select their names.

        <p><code>fields</code> is the binding exported by the library
<code>(rnrs records syntactic (6))</code> and reexported by the libraries
<code>(nausicaa language auxiliary-syntaxes)</code> and <code>(nausicaa
language oopp)</code>.

        <p>The format of the <var>?field-spec</var> arguments is equal to the one
defined by <acronym>R6RS</acronym> in the syntactic records layer, extended with type
tags.  Each <var>?field-spec</var> argument can have one of the formats as
specified by <acronym>R6RS</acronym>:

     <pre class="example">          <var>?name</var>
          (immutable <var>?name</var>)
          (immutable <var>?name</var> <var>?accessor</var>)
          (mutable <var>?name</var>)
          (mutable <var>?name</var> <var>?accessor</var> <var>?mutator</var>)
</pre>
        <p class="noindent">where:

          <dl>
<dt><var>?name</var><dd>Is an identifier representing the name of the field.

          <br><dt><var>?accessor</var><dd>Is an identifier representing the name of the accessor.

          <br><dt><var>?mutator</var><dd>Is an identifier representing the name of the mutator. 
</dl>

     <p class="noindent">when the names of the accessor and mutator are omitted: default names
are build as specified by <acronym>R6RS</acronym>.

        <p>In addition the following formats are supported:

     <pre class="example">          (<var>?name</var> <var>?tag</var>)
          (immutable (<var>?name</var> <var>?tag</var>))
          (immutable (<var>?name</var> <var>?tag</var>) <var>?accessor</var>)
          (mutable (<var>?name</var> <var>?tag</var>))
          (mutable (<var>?name</var> <var>?tag</var>) <var>?accessor</var> <var>?mutator</var>)
</pre>
        <p class="noindent">where <var>?tag</var> is a bound identifier representing a class or label
name. 
</p></blockquote></div>

<div class="defun">
&mdash; Auxiliary Syntax: <b>virtual-fields</b><var> ?field-spec <small class="dots">...</small><a name="index-virtual_002dfields-41"></a></var><br>
<blockquote><p>Add virtual fields to the enclosing class, label or mixin definition. 
This clause can be used multiple times in the same type definition.  We
note explicitly that: for virtual fields the accessor and mutator must
be explicitly defined as functions or syntaxes, and we optionally have
to select their names.

        <p><code>virtual-fields</code> is the binding exported by the library
<code>(nausicaa language auxiliary-syntaxes)</code> and reexported by the
library <code>(nausicaa language oopp)</code>.

        <p>The <var>?field-spec</var> arguments have syntax similar to <code>fields</code>
ones, but with different semantics:

          <ul>
<li>An immutable virtual field is defined by a field name and a field
accessor which can be applied to a class instance to compute a value.

          <li>A mutable virtual field is defined by a field name, a field accessor
which can be applied to a class instance to compute a value, a field
mutator which can be applied to a class instance to mutate its fields. 
</ul>

        <p>The format of the <var>?field-spec</var> arguments must be one among:

     <pre class="example">          <var>?name</var>
          (immutable <var>?name</var>)
          (immutable <var>?name</var> <var>?accessor</var>)
          (mutable <var>?name</var>)
          (mutable <var>?name</var> <var>?accessor</var> <var>?mutator</var>)
          (<var>?name</var> <var>?tag</var>)
          (immutable (<var>?name</var> <var>?tag</var>))
          (immutable (<var>?name</var> <var>?tag</var>) <var>?accessor</var>)
          (mutable (<var>?name</var> <var>?tag</var>))
          (mutable (<var>?name</var> <var>?tag</var>) <var>?accessor</var> <var>?mutator</var>)
</pre>
        <p class="noindent">where:

          <dl>
<dt><var>?name</var><dd>Is an identifier representing the name of the field;

          <br><dt><var>?tag</var><dd>Is a bound identifier representing a class or label name.

          <br><dt><var>?accessor</var><dd>Is either an identifier representing the name of the accessor or an
expression evaluating to the accessor function.  When <var>?accessor</var> is
an identifier: it can be bound either to a function or to a syntax; in
both cases, <var>?accessor</var> is used as follows to extract the value of
the virtual field:

          <pre class="example">               (<var>?accessor</var> <var>instance</var>)
</pre>
          <br><dt><var>?mutator</var><dd>Is either an identifier representing the name of the mutator or an
expression evaluating to the mutator function.  When <var>?mutator</var> is
an identifier: it can be bound either to a function or to a syntax; in
both cases, <var>?mutator</var> is used as follows to set the new value of
the virtual field:

          <pre class="example">               (<var>?mutator</var> <var>instance</var> <var>new-value</var>)
</pre>
          </dl>

        <p>When <var>?accessor</var> or <var>?mutator</var> are <strong>not</strong> present: an
identifier is automatically generated for them following the same rules
established by <acronym>R6RS</acronym> for the concrete fields of a record type.  It is
our responsibility to define a function or syntax bound to such
identifiers and suitable to be used as accessor or mutator. 
</p></blockquote></div>

   <p>The following is an example of class virtual fields usage in which the
accessor and mutator are defined as expressions inlined in the class
definition:

<pre class="example">     (import (vicare numerics constants))
     
     (define-class &lt;angle&gt;
       (fields (mutable (radians &lt;real&gt;)))
       (virtual-fields
         (mutable (degrees &lt;real&gt;)
                  (lambda/tags ((A &lt;angle&gt;))
                    (* (/ 180.0 greek-pi) (A radians)))
                  (lambda/tags ((A &lt;angle&gt;) (deg &lt;real&gt;))
                    (set! (A radians) (* (/ greek-pi 180.0) deg))))))
     
     (&lt;angle&gt; A (&lt;&gt; (greek-pi)))
     (A radians)             &rArr; greek-pi
     (A degrees)             &rArr; 180.0
     (set! (A degrees) 90.0)
     (A radians)             &rArr; greek-pi/2
</pre>
   <p class="noindent">here is the same definition with accessor and mutator defined as
functions and the default names:

<pre class="example">     (import (vicare numerics constants))
     
     (define-class &lt;angle&gt;
       (fields (mutable (radians &lt;real&gt;)))
       (virtual-fields (mutable (degrees &lt;real&gt;))))
     
     (define (&lt;angle&gt;-degrees (A &lt;angle&gt;))
       (* (/ 180.0 greek-pi) (A radians)))
     
     (define (&lt;angle&gt;-degrees-set! (A &lt;angle&gt;) (deg &lt;real&gt;))
       (set! (A radians) (* (/ greek-pi 180.0) deg)))
</pre>
   <p class="noindent">and here is again the same definition with accessor and mutator defined
as syntaxes:

<pre class="example">     (import (vicare numerics constants))
     
     (define-class &lt;angle&gt;
       (fields (mutable (radians &lt;real&gt;)))
       (virtual-fields (mutable (degrees &lt;real&gt;))))
     
     (define-inline (&lt;angle&gt;-degrees A)
       (let (((A &lt;angle&gt;) A))
         (* (/ 180.0 greek-pi) (A radians))))
     
     (define-inline (&lt;angle&gt;-degrees-set! A deg)
       (let (((A &lt;angle&gt;)  A)
             ((deg &lt;real&gt;) deg))
         (set! (A radians) (* (/ greek-pi 180.0) deg))))
</pre>
   <!-- page -->
   </body></html>

