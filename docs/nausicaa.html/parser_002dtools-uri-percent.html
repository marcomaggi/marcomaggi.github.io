<html lang="en">
<head>
<title>parser-tools uri percent - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="parser_002dtools-uri.html#parser_002dtools-uri" title="parser-tools uri">
<link rel="prev" href="parser_002dtools-uri-conditions.html#parser_002dtools-uri-conditions" title="parser-tools uri conditions">
<link rel="next" href="parser_002dtools-uri-parser.html#parser_002dtools-uri-parser" title="parser-tools uri parser">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d7 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="parser-tools-uri-percent"></a>
<a name="parser_002dtools-uri-percent"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="parser_002dtools-uri-parser.html#parser_002dtools-uri-parser">parser-tools uri parser</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="parser_002dtools-uri-conditions.html#parser_002dtools-uri-conditions">parser-tools uri conditions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="parser_002dtools-uri.html#parser_002dtools-uri">parser-tools uri</a>
<hr>
</div>

<h4 class="subsection">12.5.3 Percent encoding of characters</h4>

<p>A bytevector, whose bytes are interpreted as <acronym>ASCII</acronym> characters, is
valid as <acronym>URI</acronym> component only if its characters match the following
<code>(vicare parser-tools silex)</code> specification (<a href="../vicare-libs/silex-syntax.html#silex-syntax">Syntax of the specification</a>):

<pre class="example">     ALPHA           [a-zA-Z]
     DIGIT           [0-9]
     HEXDIG          [0-9a-fA-F]
     
     pct-encoded     %{HEXDIG}{HEXDIG}
     
     gen-delims      [:/\?#\[\]@]
     sub-delims      [\!\$&amp;\'()\*\+,\;=]
     
     reserved        {gen-delims}|{sub-delims}
     unreserved      {ALPHA}|{DIGIT}|[\-\._~]
</pre>
   <p class="noindent">all the characters which are not unreserved are meant to be
percent&ndash;encoded in a <acronym>URI</acronym> string; in particular the following must be
encoded:

<pre class="example">     : / ? # [ ]  \ ! $ &amp; ' ( ) * + , ; =
</pre>
   <p class="noindent">the characters in the unreserved set can, but should not, be encoded.

   <p>The following bindings are exported by the library <code>(nausicaa
parser-tools uri)</code>.

<div class="defun">
&mdash; Function: <b>unreserved-char?</b><var> obj<a name="index-unreserved_002dchar_003f-1948"></a></var><br>
&mdash; Function: <b>not-unreserved-char?</b><var> obj<a name="index-not_002dunreserved_002dchar_003f-1949"></a></var><br>
<blockquote><p>The argument <var>obj</var> must be a character or fixnum representing a
character according to <code>char-&gt;integer</code>.  <code>unreserved-char?</code>
returns <code>#t</code> if <var>obj</var> represents an unreserved character
according to <acronym>RFC</acronym> 3986, otherwise return <code>#f</code>. 
<code>not-unreserved-char?</code> returns the negation of
<code>unreserved-char?</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Syntax: <b>percent-encode</b><var> ?obj ?clause <small class="dots">...</small><a name="index-percent_002dencode-1950"></a></var><br>
&mdash; Auxiliary Syntax: <b>char-selector</b><var> ?pred<a name="index-char_002dselector-1951"></a></var><br>
&mdash; Auxiliary Syntax: <b>string-result?</b><var> ?bool<a name="index-string_002dresult_003f-1952"></a></var><br>
<blockquote><p>Percent&ndash;encode the given object, return the result; characters outside
a selected range are percent&ndash;encoded.

        <p><var>?obj</var> must be an expression evaluating to any character, string or
bytevector; the character is converted to a string and the string is
converted to a bytevector with <code>string-&gt;utf8</code>.

        <p>The following clauses are supported:

          <dl>
<dt><code>char-selector </code><var>?pred</var><dd><var>?pred</var> must be an expression evaluating to a predicate function
which, applied to an integer representing a character according to
<code>char-&gt;integer</code>, returns true if the character must be percent
encoded, <code>#f</code> otherwise.  The default is to encode all the not
unreserved characters.

          <br><dt><code>string-result? </code><var>?bool</var><dd>If <var>?bool</var> evaluates to is true: return a string, else return a
bytevector; the default is to return a bytevector. 
</dl>

        <p>Examples:

     <pre class="example">          (import (nausicaa)
            (prefix (nausicaa parser-tools uri) uri.))
          
          (uri.percent-encode #\.)        &rArr; "."
          (uri.percent-encode #\-)        &rArr; "-"
          (uri.percent-encode #\_)        &rArr; "_"
          (uri.percent-encode #\~)        &rArr; "~"
          (uri.percent-encode #\%)        &rArr; "%25"
          (uri.percent-encode #\?)        &rArr; "%3F"
          (uri.percent-encode #\=)        &rArr; "%3D"
          (uri.percent-encode #\#)        &rArr; "%23"
          
          (uri.percent-encode "")         &rArr; ""
          (uri.percent-encode "ciao")     &rArr; "ciao"
          (uri.percent-encode "cia=o")    &rArr; "cia%3Do"
          (uri.percent-encode "ci?a=o")   &rArr; "ci%3Fa%3Do"
</pre>
        <p>Notice that this function is different form <code>uri-encode</code> as defined
by <code>(vicare)</code>: it accepts a variety of argument types and it
allows the selection of the characters to encode. 
</p></blockquote></div>

<div class="defun">
&mdash; Syntax: <b>percent-decode</b><var> ?obj ?clause <small class="dots">...</small><a name="index-percent_002ddecode-1953"></a></var><br>
&mdash; Auxiliary Syntax: <b>string-result?</b><var> ?bool<a name="index-string_002dresult_003f-1954"></a></var><br>
<blockquote><p>Percent&ndash;decode the given <var>?obj</var>, return the result.

        <p><var>?obj</var> must be an expression evaluating to any string or bytevector;
the string is converted to a bytevector with <code>string-&gt;utf8</code>.

        <p>The following clauses are supported:

          <dl>
<dt><code>string-result? </code><var>?bool</var><dd>If <var>?bool</var> evaluates to true: return a string, else return a
bytevector; the default is to return a bytevector. 
</dl>

        <p>Examples:

     <pre class="example">          (import (nausicaa)
            (prefix (nausicaa parser-tools uri) uri.))
          
          (define (doit obj)
            (uri.percent-decode obj (uri.string-result? #t)))
          
          (doit ".")      &rArr; "."
          (doit "-")      &rArr; "-"
          (doit "_")      &rArr; "_"
          (doit "~")      &rArr; "~"
          (doit "%25")    &rArr; "%"
          (doit "%3F")    &rArr; "?"
          (doit "%3D")    &rArr; "="
          (doit "%23")    &rArr; "#"
          
          (doit "")               &rArr; ""
          (doit "ciao")           &rArr; "ciao"
          (doit "cia%3Do")        &rArr; "cia=o"
          (doit "ci%3Fa%3Do")     &rArr; "ci?a=o"
</pre>
        <p>Notice that this function is different form <code>uri-decode</code> as defined
by <code>(vicare)</code>: it accepts a variety of argument types. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>normalise-percent-encoded-bytevector</b><var> bv<a name="index-normalise_002dpercent_002dencoded_002dbytevector-1955"></a></var><br>
<blockquote><p>Normalise the given percent&ndash;encoded bytevector; bytes that are encoded
but should not are decoded; return the normalised bytevector, in which
percent&ndash;encoded characters are displayed in upper case.  Assume that
<var>bv</var> is composed by bytes in the valid range for <acronym>URI</acronym>s.

        <p>Notice that this function does <strong>not</strong> percent&ndash;encode bytes which
are already not so. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>normalise-percent-encoded-string</b><var> str<a name="index-normalise_002dpercent_002dencoded_002dstring-1956"></a></var><br>
<blockquote><p>Normalise the given percent&ndash;encoded string; characters that are encoded
but should not are decoded; return the normalised string, in which
percent&ndash;encoded characters are displayed in upper case.  Assume that
<var>str</var> is composed by characters in the valid range for <acronym>URI</acronym>s.

        <p>Notice that this function does <strong>not</strong> percent&ndash;encode characters
which are already not so.

     <pre class="example">          (import (nausicaa)
            (prefix (nausicaa parser-tools uri) uri.))
          
          (uri.normalise-percent-encoded-string "ci%3Fa%3Do")
          &rArr; "ci%3Fa%3Do"
          
          (uri.normalise-percent-encoded-string "%7Eciao")
          &rArr; "~ciao"
          
          (uri.normalise-percent-encoded-string "ci%5Fao")
          &rArr; "ci_ao"
</pre>
        </blockquote></div>

<!-- page -->
   </body></html>

