<html lang="en">
<head>
<title>stdlib exceptions conditions objects - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="stdlib-exceptions-conditions.html#stdlib-exceptions-conditions" title="stdlib exceptions conditions">
<link rel="next" href="stdlib-exceptions-conditions-types.html#stdlib-exceptions-conditions-types" title="stdlib exceptions conditions types">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d11 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008-2011 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="stdlib-exceptions-conditions-objects"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="stdlib-exceptions-conditions-types.html#stdlib-exceptions-conditions-types">stdlib exceptions conditions types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="stdlib-exceptions-conditions.html#stdlib-exceptions-conditions">stdlib exceptions conditions</a>
<hr>
</div>

<h5 class="subsubsection">4.7.2.1 Condition objects</h5>

<p>Conceptually, there are two different kinds of condition objects:
<em>simple conditions</em> and <em>compound conditions</em>.  An object that
is either a simple condition or a compound condition is simply a
<em>condition</em>.  Compound conditions form a type disjoint from the
base types described in report section <a href="baselib-types.html#baselib-types">baselib types</a>.  A simple
condition describes a single aspect of an exceptional situation.  A
compound condition represents multiple aspects of an exceptional
situation as a list of simple conditions, its <em>components</em>.  Most
of the operations described in this section treat a simple condition
identically to a compound condition with itself as its own sole
component.  For a subtype <var>t</var> of <code>&amp;condition</code>, a
<em>condition of type </em><var>t</var> is either a record of type <var>t</var> or a
compound condition containing a component of type <var>t</var>.

   <p><a name="index-g_t_0026condition-419"></a>

<div class="defun">
&mdash; Condition Type: <b>&amp;condition</b><var><a name="index-g_t_0026condition-420"></a></var><br>
<blockquote><p>Simple conditions are records of subtypes of the <code>&amp;condition</code>
record type.  The <code>&amp;condition</code> type has no fields and is neither
sealed nor opaque. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>condition</b><var> condition1 <small class="dots">...</small><a name="index-condition-421"></a></var><br>
<blockquote><p>The <code>condition</code> procedure returns a condition object with the
components of the <var>condition</var>s as its components, in the same order,
i.e., with the components of <var>condition1</var> appearing first in the
same order as in <var>condition1</var>, then with the components of
<var>condition2</var>, and so on.  The returned condition is compound if the
total number of components is zero or greater than one.  Otherwise, it
may be compound or simple. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>simple-conditions</b><var> condition<a name="index-simple_002dconditions-422"></a></var><br>
<blockquote><p>The <code>simple-conditions</code> procedure returns a list of the components
of <var>condition</var>, in the same order as they appeared in the
construction of <var>condition</var>.  The returned list is immutable.  If
the returned list is modified, the effect on <var>condition</var> is
unspecified.

        <blockquote>
<strong>NOTE</strong> Because <code>condition</code> decomposes its arguments into
simple conditions, <code>simple-conditions</code> always returns a
&ldquo;flattened&rdquo; list of simple conditions. 
</blockquote>
        </p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>condition?</b><var> obj<a name="index-condition_003f-423"></a></var><br>
<blockquote><p>Return <code>#t</code> if <var>obj</var> is a (simple or compound) condition,
otherwise returns <code>#f</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>condition-predicate</b><var> rtd<a name="index-condition_002dpredicate-424"></a></var><br>
<blockquote><p><var>rtd</var> must be a record&ndash;type descriptor of a subtype of
<code>&amp;condition</code>.  The <code>condition-predicate</code> procedure returns a
procedure that takes one argument.  This procedure returns <code>#t</code> if
its argument is a condition of the condition type represented by
<var>rtd</var>, i.e., if it is either a simple condition of that record type
(or one of its subtypes) or a compound conditition with such a simple
condition as one of its components, and <code>#f</code> otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>condition-accessor</b><var> rtd proc<a name="index-condition_002daccessor-425"></a></var><br>
<blockquote><p><var>rtd</var> must be a record&ndash;type descriptor of a subtype of
<code>&amp;condition</code>.  <var>proc</var> should accept one argument, a record of
the record type of <var>rtd</var>.  The <code>condition-accessor</code> procedure
returns a procedure that accepts a single argument, which must be a
condition of the type represented by <var>rtd</var>.  This procedure extracts
the first component of the condition of the type represented by
<var>rtd</var>, and returns the result of applying <var>proc</var> to that
component. 
</p></blockquote></div>

<pre class="example">     (define-record-type (&amp;cond1 make-cond1 real-cond1?)
       (parent &amp;condition)
       (fields
        (immutable x real-cond1-x)))
     
     (define cond1?
       (condition-predicate
         (record-type-descriptor &amp;cond1)))
     (define cond1-x
       (condition-accessor
         (record-type-descriptor &amp;cond1)
         real-cond1-x))
     
     (define foo (make-cond1 'foo))
     
     (condition? foo)                        &rArr; #t
     (cond1? foo)                            &rArr; #t
     (cond1-x foo)                           &rArr; foo
     
     (define-record-type (&amp;cond2 make-cond2 real-cond2?)
       (parent &amp;condition)
       (fields
        (immutable y real-cond2-y)))
     
     (define cond2?
       (condition-predicate
         (record-type-descriptor &amp;cond2)))
     (define cond2-y
       (condition-accessor
          (record-type-descriptor &amp;cond2)
          real-cond2-y))
     
     (define bar (make-cond2 'bar))
     
     (condition? (condition foo bar))        &rArr; #t
     (cond1? (condition foo bar))            &rArr; #t
     (cond2? (condition foo bar))            &rArr; #t
     (cond1? (condition foo))                &rArr; #t
     (real-cond1? (condition foo))           &rArr; unspecified
     (real-cond1? (condition foo bar))       &rArr; #f
     (cond1-x (condition foo bar))           &rArr; foo
     (cond2-y (condition foo bar))           &rArr; bar
     
     (equal? (simple-conditions (condition foo bar))
             (list foo bar))                 &rArr; #t
     
     (equal? (simple-conditions
               (condition foo (condition bar)))
             (list foo bar))                 &rArr; #t
</pre>
   <div class="defun">
&mdash; Syntax: <b>define-condition-type</b><var> &lt;condition-type&gt; &lt;supertype&gt; &lt;constructor&gt; &lt;predicate&gt; &lt;field-spec1&gt; <small class="dots">...</small><a name="index-define_002dcondition_002dtype-426"></a></var><br>
<blockquote><p><var>&lt;condition-type&gt;</var>, <var>&lt;supertypes&gt;</var>, <var>&lt;constructor&gt;</var>, and
<var>&lt;predicate&gt;</var> must all be identifiers.  Each <var>&lt;field-spec&gt;</var> must
be of the form

     <pre class="example">          (<var>&lt;field&gt;</var> <var>&lt;accessor&gt;</var>)
</pre>
        <p class="noindent">where both <var>&lt;field&gt;</var> and <var>&lt;accessor&gt;</var> must be identifiers.

        <p>The <code>define-condition-type</code> form expands into a record&ndash;type
definition for a record type <var>&lt;condition-type&gt;</var>.  The record type
will be non&ndash;opaque, non&ndash;sealed, and its fields will be immutable.  It
will have <var>&lt;supertype&gt;</var> has its parent type.  The remaining
identifiers will be bound as follows:

          <ul>
<li><var>&lt;constructor&gt;</var> is bound to a default constructor for the type: It
accepts one argument for each of the record type's complete set of
fields (including parent types, with the fields of the parent coming
before those of the extension in the arguments) and returns a condition
object initialized to those arguments.

          <li><var>&lt;predicate&gt;</var> is bound to a predicate that identifies conditions of
type <var>&lt;condition-type&gt;</var> or any of its subtypes.

          <li>Each <var>&lt;accessor&gt;</var> is bound to a procedure that extracts the
corresponding field from a condition of type <var>&lt;condition-type&gt;</var>. 
</ul>
        </p></blockquote></div>

<pre class="example">     (define-condition-type &amp;c &amp;condition
       make-c c?
       (x c-x))
     
     (define-condition-type &amp;c1 &amp;c
       make-c1 c1?
       (a c1-a))
     
     (define-condition-type &amp;c2 &amp;c
       make-c2 c2?
       (b c2-b))
</pre>
   <pre class="example">     (define v1 (make-c1 "V1" "a1"))
     
     (c? v1)        &rArr; #t
     (c1? v1)       &rArr; #t
     (c2? v1)       &rArr; #f
     (c-x v1)       &rArr; "V1"
     (c1-a v1)      &rArr; "a1"
</pre>
   <pre class="example">     (define v2 (make-c2 "V2" "b2"))
     
     (c? v2)        &rArr; #t
     (c1? v2)       &rArr; #f
     (c2? v2)       &rArr; #t
     (c-x v2)       &rArr; "V2"
     (c2-b v2)      &rArr; "b2"
</pre>
   <pre class="example">     (define v3 (condition
                  (make-c1 "V3/1" "a3")
                  (make-c2 "V3/2" "b3")))
     
     (c? v3)        &rArr; #t
     (c1? v3)       &rArr; #t
     (c2? v3)       &rArr; #t
     (c-x v3)       &rArr; "V3/1"
     (c1-a v3)      &rArr; "a3"
     (c2-b v3)      &rArr; "b3"
</pre>
   <pre class="example">     (define v4 (condition v1 v2))
     
     (c? v4)        &rArr; #t
     (c1? v4)       &rArr; #t
     (c2? v4)       &rArr; #t
     (c-x v4)       &rArr; "V1"
     (c1-a v4)      &rArr; "a1"
     (c2-b v4)      &rArr; "b2"
</pre>
   <pre class="example">     (define v5 (condition v2 v3))
     
     (c? v5)        &rArr; #t
     (c1? v5)       &rArr; #t
     (c2? v5)       &rArr; #t
     (c-x v5)       &rArr; "V2"
     (c1-a v5)      &rArr; "a3"
     (c2-b v5)      &rArr; "b2"
</pre>
   <!-- page -->
   </body></html>

