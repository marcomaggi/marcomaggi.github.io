<html lang="en">
<head>
<title>pathnames unix low - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="pathnames-unix.html#pathnames-unix" title="pathnames unix">
<link rel="prev" href="pathnames-unix-intro.html#pathnames-unix-intro" title="pathnames unix intro">
<link rel="next" href="pathnames-unix-class.html#pathnames-unix-class" title="pathnames unix class">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d8 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008-2011 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="pathnames-unix-low"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="pathnames-unix-class.html#pathnames-unix-class">pathnames unix class</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="pathnames-unix-intro.html#pathnames-unix-intro">pathnames unix intro</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="pathnames-unix.html#pathnames-unix">pathnames unix</a>
<hr>
</div>

<h4 class="subsection">40.3.2 Low level functions</h4>

<p><a name="index-g_t_0040library_007bnausicaa-pathnames-unix-low_007d_002c-library-3809"></a><a name="index-Library-_0040library_007bnausicaa-pathnames-unix-low_007d-3810"></a>

   <p>The following bindings are exported by the <code>(nausicaa pathnames
unix low)</code> library; it is suggested to use a prefix when importing the
library.

<div class="defun">
&mdash; Function: <b>to-bytevector</b><var> obj<a name="index-to_002dbytevector-3811"></a></var><br>
<blockquote><p>Convert the string <var>obj</var> to a bytevector representation; characters
are taken from <var>obj</var> and inserted into the resulting bytevector
after decoding them, char to byte, as <acronym>ASCII</acronym>.  If OBJ is already a
bytevector: <var>obj</var> itself is returned.

        <p>If a character or byte from the input is invalid for a Unix pathname:
raise an exception using <code>raise-byte-error</code> from <code>(nausicaa
pathnames conditions)</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>to-string</b><var> obj<a name="index-to_002dstring-3812"></a></var><br>
<blockquote><p>Convert the bytevector <var>obj</var> to a string representation; bytes are
taken from <var>obj</var> and inserted into the resulting string after
encoding them, byte to char, as <acronym>ASCII</acronym>.  If <var>obj</var> is already a
string: <var>obj</var> itself is returned.

        <p>If a byte or character from the input is invalid for a Unix pathname:
raise an exception using <code>raise-byte-error</code> from <code>(nausicaa
pathnames conditions)</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>parse-segment</b><var> port<a name="index-parse_002dsegment-3813"></a></var><br>
<blockquote><p>Accumulate bytes from <var>port</var> while they are valid for a
<code>segment</code> component; notice that an empty <code>segment</code> is valid.

        <p>If <acronym>EOF</acronym> or a slash character in <acronym>ASCII</acronym> coding is read: return a
possibly empty bytevector holding the bytes accumulated so far; the port
position is left pointing to the byte after the last accumulated one.

        <p>If an invalid byte is read: an exception is raised using
<code>raise-parser-error</code> from <code>(nausicaa pathnames conditions)</code>;
the port position is rewind to the one before this function call. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>parse-segment-nz</b><var> port<a name="index-parse_002dsegment_002dnz-3814"></a></var><br>
<blockquote><p>Accumulate bytes from <var>port</var> while they are valid for a
<code>segment-nz</code> component; notice that an empty <code>segment-nz</code> is
not valid.

        <p>If the first read operation returns <acronym>EOF</acronym> or a slash character in
<acronym>ASCII</acronym> coding: the port position is restored to the one before this
function call and the return value is false.

        <p>If, after at least one valid byte is read, <acronym>EOF</acronym> or a slash is read:
return a bytevector holding the bytes accumulated so far; the port
position is left pointing to the byte after the last accumulated one.

        <p>If an invalid byte is read: an exception is raised using
<code>raise-parser-error</code> from <code>(nausicaa pathnames conditions)</code>;
the port position is rewind to the one before this function call. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>parse-slash-and-segment</b><var> port<a name="index-parse_002dslash_002dand_002dsegment-3815"></a></var><br>
<blockquote><p>Attempt to read from <var>port</var> the sequence slash character plus
<code>segment</code> component; notice that an empty <code>segment</code> is valid.

        <p>If these components are successfully read: return a bytevector holding
the accumulated <code>segment</code> bytes; if the <code>segment</code> component is
empty: the returned bytevector is normalised to hold a single byte
representing a dot in <acronym>ASCII</acronym> coding.  The port position is left
pointing to the byte after the last accumulated byte from the
<code>segment</code>.

        <p>If <acronym>EOF</acronym> or a valid byte different from slash is read as first byte:
return false; the port position is rewind to the one before this
function call.

        <p>If an invalid byte is read: an exception is raised using
<code>raise-parser-error</code> from <code>(nausicaa pathnames conditions)</code>;
the port position is rewind to the one before this function call. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>parse-pathname</b><var> port<a name="index-parse_002dpathname-3816"></a></var><br>
<blockquote><p>Parse from <var>port</var> an absolute or relative pathname until <acronym>EOF</acronym> is
found; return two values: a boolean, true if the pathname is absolute;
false if <acronym>EOF</acronym> is the first byte read or a, possibly empty, list of
bytevectors representing the segments.  Empty <code>segment</code> components
are represented by bytevectors holding a single byte representing a dot
in <acronym>ASCII</acronym> coding.

        <p>If an invalid byte is read: an exception is raised using
<code>raise-parser-error</code> from <code>(nausicaa pathnames conditions)</code>;
the port position is rewind to the one before this function call. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>normalise-pathname</b><var> absolute? segments<a name="index-normalise_002dpathname-3817"></a></var><br>
<blockquote><p>Given a list of bytevectors representing segments: normalise them, as
much as possible, removing segments representing single&ndash;dot and
double&ndash;dot directory entries; if <var>absolute?</var> is true: normalise
<var>segments</var> as an absolute pathname, else normalise it as a relative
pathname.  Return two values:

          <ol type=1 start=1>
<li>A boolean, true if some change was made from <var>segments</var> to the
second returned value; this allows us to detect if a normalised list of
segments when serialised into a bytevector becomes different from the
original bytevector.

          <li>When the normalisation succeeds: a new, possibly empty, list of
bytevectors representing the normalisation of <var>segments</var>.  Absolute
pathname segments can hold neither single&ndash;dot nor double&ndash;dot segments:
if a double&ndash;dot segment cannot be removed, this value is false (and the
first too).

          <p>Segments from the original <var>segments</var> argument are shared with this
returned value.
             </ol>

        <p>Notice that empty input bytevectors are not handled specially: they
should be avoided, but no error is raised and they are <strong>not</strong>
interpreted as equivalent to bytevectors holding a single byte
representing a dot in <acronym>ASCII</acronym> coding. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>serialise-segments</b><var> absolute? segments<a name="index-serialise_002dsegments-3818"></a></var><br>
<blockquote><p>Given a possibly empty list of bytevectors representing pathname
segments build and return a new bytevector representing the full
pathname; if <var>absolute?</var> is true: the first byte of the result
represents a slash in <acronym>ASCII</acronym> coding.

        <p>If <var>segments</var> is empty and <var>absolute?</var> is true: the returned
value is a bytevector holding a single byte representing a slash in
<acronym>ASCII</acronym> coding.

        <p>If <var>segments</var> is empty and <var>absolute?</var> is false: the returned
value is a bytevector holding a single byte representing a dot in
<acronym>ASCII</acronym> coding. 
</p></blockquote></div>

<!-- page -->
   </body></html>

