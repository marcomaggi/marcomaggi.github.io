<html lang="en">
<head>
<title>parser-tools lalr intro want - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="parser_002dtools-lalr-intro.html#parser_002dtools-lalr-intro" title="parser-tools lalr intro">
<link rel="prev" href="parser_002dtools-lalr-intro-tokens.html#parser_002dtools-lalr-intro-tokens" title="parser-tools lalr intro tokens">
<link rel="next" href="parser_002dtools-lalr-intro-simple.html#parser_002dtools-lalr-intro-simple" title="parser-tools lalr intro simple">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d7 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="parser-tools-lalr-intro-want"></a>
<a name="parser_002dtools-lalr-intro-want"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="parser_002dtools-lalr-intro-simple.html#parser_002dtools-lalr-intro-simple">parser-tools lalr intro simple</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="parser_002dtools-lalr-intro-tokens.html#parser_002dtools-lalr-intro-tokens">parser-tools lalr intro tokens</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="parser_002dtools-lalr-intro.html#parser_002dtools-lalr-intro">parser-tools lalr intro</a>
<hr>
</div>

<h5 class="subsubsection">12.3.1.2 What we want</h5>

<p>Let's take the simple expression &lsquo;<samp><span class="samp">1 + 2 * 3</span></samp>&rsquo;; its tokenisation is:

<pre class="example">     [N, 1] [A, +] [N, 2] [M, *] [N, 3] [*eoi*, #&lt;eof&gt;]
</pre>
   <p class="noindent">and we can imagine values and category symbols to be available in Scheme
vectors:

<pre class="example">     #(1  +  2  *  3  #&lt;eof&gt;)
     #(N  A  N  M  N   *eoi*)
</pre>
   <p class="noindent">experience shows that it is useful to consider a fake first element in
both vectors; we assign this element to an additional terminal category
whose symbol is &lsquo;<samp><span class="samp">S</span></samp>&rsquo; as in start, its value is not important so we
select <code>#f</code>:

<pre class="example">     #(#f  1  +  2  *  3  #&lt;eof&gt;)
     #( S  N  A  N  M  N   *eoi*)
</pre>
   <p>Basically, we want the following:

     <ol type=1 start=1>
<li>The parser has to recognise the subvectors &lsquo;<samp><span class="samp">N A N</span></samp>&rsquo; and &lsquo;<samp><span class="samp">N M N</span></samp>&rsquo;
as representing expressions it can compute.

     <li>The parser must recognise that &lsquo;<samp><span class="samp">N M N</span></samp>&rsquo; has precedence above &lsquo;<samp><span class="samp">N
A N</span></samp>&rsquo;.  &lsquo;<samp><span class="samp">N M N</span></samp>&rsquo; has to be computed first.

     <li>The values &lsquo;<samp><span class="samp">2 * 3</span></samp>&rsquo; have to be fed to a <dfn>semantic clause</dfn> of our
choice to compute a result; the semantic clause is just a Scheme form in
which we do whatever we want with the three operands &lsquo;<samp><span class="samp">2</span></samp>&rsquo;, &lsquo;<samp><span class="samp">*</span></samp>&rsquo;
and &lsquo;<samp><span class="samp">3</span></samp>&rsquo;.  For example, we can compute the result 2 * 3 = 6.

     <p>The parser generator should create Scheme equivalent to:

     <pre class="example">          (let (($3   2)   ;
                ($2   *)   ; Automatically generated preamble
                ($1   3))  ;
          
            ($2 $3 $1))    ; Client-supplied semantic clause
</pre>
     <p>So we want the parser to mutate the vectors as follows:

     <pre class="example">          #(#f  1  +  6  #&lt;eof&gt;  #f #f)
          #( S  N  A  N   *eoi*  #f #f)
</pre>
     <li>The parser has to recognise the subvector &lsquo;<samp><span class="samp">N A N</span></samp>&rsquo; has representing
a sequence it can compute; the values have to be fed to a semantic
clause; let's say it computes the result 1 + 6 = 7.

     <p>So we want the parser to mutate the vectors as follows:

     <pre class="example">          #(#f  7  #&lt;eof&gt;  #f #f #f #f)
          #( S  N   *eoi*  #f #f #f #f)
</pre>
     <li>Finally we want the parser to recognise &lsquo;<samp><span class="samp">*eoi*</span></samp>&rsquo; as the
end&ndash;of&ndash;input terminal, and to finish the parsing operation returning
the value &lsquo;<samp><span class="samp">7</span></samp>&rsquo; it left in the vector before.
        </ol>

<!-- page -->
   </body></html>

