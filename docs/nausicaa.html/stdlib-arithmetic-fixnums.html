<html lang="en">
<head>
<title>stdlib arithmetic fixnums - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="stdlib-arithmetic.html#stdlib-arithmetic" title="stdlib arithmetic">
<link rel="prev" href="stdlib-arithmetic-bitwise.html#stdlib-arithmetic-bitwise" title="stdlib arithmetic bitwise">
<link rel="next" href="stdlib-arithmetic-flonums.html#stdlib-arithmetic-flonums" title="stdlib arithmetic flonums">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d11 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008-2011 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="stdlib-arithmetic-fixnums"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="stdlib-arithmetic-flonums.html#stdlib-arithmetic-flonums">stdlib arithmetic flonums</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="stdlib-arithmetic-bitwise.html#stdlib-arithmetic-bitwise">stdlib arithmetic bitwise</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="stdlib-arithmetic.html#stdlib-arithmetic">stdlib arithmetic</a>
<hr>
</div>

<h4 class="subsection">4.11.2 Fixnums</h4>

<p><a name="index-g_t_0040rsixlibrary_007barithmetic-fixnums_007d_002c-library-673"></a><a name="index-Library_002c-_0040rsixlibrary_007barithmetic-fixnums_007d-674"></a>

   <p>Every implementation must define its fixnum range as a closed interval:
[-2^(w-1), 2^(w-1)-1] such that <em>w</em> is a (mathematical)
integer w &gt;= 24.  Every mathematical integer within an
implementation's fixnum range must correspond to an exact integer object
that is representable within the implementation.  A fixnum is an exact
integer object whose value lies within this fixnum range.

   <p>This section describes the <code>(rnrs arithmetic fixnums (6))</code> library,
which defines various operations on fixnums.  Fixnum operations perform
integer arithmetic on their fixnum arguments, but raise an exception
with condition type <code>&amp;implementation-restriction</code> if the result is
not a fixnum.

   <p>This section uses <var>fx</var>, <var>fx1</var>, <var>fx2</var>, etc., as names for
arguments that must be fixnums.

<div class="defun">
&mdash; Procedure: <b>fixnum?</b><var> obj<a name="index-fixnum_003f-675"></a></var><br>
<blockquote><p>Return <code>#t</code> if <var>obj</var> is an exact integer object within the fixnum
range, <code>#f</code> otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fixnum-width</b><var><a name="index-fixnum_002dwidth-676"></a></var><br>
&mdash; Procedure: <b>least-fixnum</b><var><a name="index-least_002dfixnum-677"></a></var><br>
&mdash; Procedure: <b>greatest-fixnum</b><var><a name="index-greatest_002dfixnum-678"></a></var><br>
<blockquote><p>These procedures return w, -2^(w-1) and 2^(w-1)
- 1: the width, minimum and the maximum value of the fixnum range,
respectively. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fx=?</b><var> fx1 fx2 fx3 <small class="dots">...</small><a name="index-fx_003d_003f-679"></a></var><br>
&mdash; Procedure: <b>fx&gt;?</b><var> fx1 fx2 fx3 <small class="dots">...</small><a name="index-fx_003e_003f-680"></a></var><br>
&mdash; Procedure: <b>fx&lt;?</b><var> fx1 fx2 fx3 <small class="dots">...</small><a name="index-fx_003c_003f-681"></a></var><br>
&mdash; Procedure: <b>fx&gt;=?</b><var> fx1 fx2 fx3 <small class="dots">...</small><a name="index-fx_003e_003d_003f-682"></a></var><br>
&mdash; Procedure: <b>fx&lt;=?</b><var> fx1 fx2 fx3 <small class="dots">...</small><a name="index-fx_003c_003d_003f-683"></a></var><br>
<blockquote><p>These procedures return <code>#t</code> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing, <code>#f</code> otherwise. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxzero?</b><var> fx<a name="index-fxzero_003f-684"></a></var><br>
&mdash; Procedure: <b>fxpositive?</b><var> fx<a name="index-fxpositive_003f-685"></a></var><br>
&mdash; Procedure: <b>fxnegative?</b><var> fx<a name="index-fxnegative_003f-686"></a></var><br>
&mdash; Procedure: <b>fxodd?</b><var> fx<a name="index-fxodd_003f-687"></a></var><br>
&mdash; Procedure: <b>fxeven?</b><var> fx<a name="index-fxeven_003f-688"></a></var><br>
<blockquote><p>These numerical predicates test a fixnum for a particular property,
returning <code>#t</code> or <code>#f</code>.  The five properties tested by these
procedures are: whether the number object is zero, greater than zero,
less than zero, odd, or even. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxmax</b><var> fx1 fx2 <small class="dots">...</small><a name="index-fxmax-689"></a></var><br>
&mdash; Procedure: <b>fxmin</b><var> fx1 fx2 <small class="dots">...</small><a name="index-fxmin-690"></a></var><br>
<blockquote><p>These procedures return the maximum or minimum of their arguments. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fx+</b><var> fx1 fx2<a name="index-fx_002b-691"></a></var><br>
&mdash; Procedure: <b>fx*</b><var> fx1 fx2<a name="index-fx_002a-692"></a></var><br>
<blockquote><p>These procedures return the sum or product of their arguments, provided
that sum or product is a fixnum.  An exception with condition type
<code>&amp;implementation-restriction</code> is raised if that sum or product is
not a fixnum. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fx-</b><var> fx1 fx2<a name="index-fx_002d-693"></a></var><br>
&mdash; Procedure: <b>fx-</b><var> fx<a name="index-fx_002d-694"></a></var><br>
<blockquote><p>With two arguments, this procedure returns the difference
<var>fx1</var> - <var>fx2</var>, provided that difference is a fixnum.

        <p>With one argument, this procedure returns the additive inverse of its
argument, provided that integer object is a fixnum.

        <p>An exception with condition type <code>&amp;implementation-restriction</code> is
raised if the mathematically correct result of this procedure is not a
fixnum.

     <pre class="example">          (fx- (least-fixnum))  &rArr; exception &amp;assertion
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxdiv-and-mod</b><var> fx1 fx2<a name="index-fxdiv_002dand_002dmod-695"></a></var><br>
&mdash; Procedure: <b>fxdiv</b><var> fx1 fx2<a name="index-fxdiv-696"></a></var><br>
&mdash; Procedure: <b>fxmod</b><var> fx1 fx2<a name="index-fxmod-697"></a></var><br>
&mdash; Procedure: <b>fxdiv0-and-mod0</b><var> fx1 fx2<a name="index-fxdiv0_002dand_002dmod0-698"></a></var><br>
&mdash; Procedure: <b>fxdiv0</b><var> fx1 fx2<a name="index-fxdiv0-699"></a></var><br>
&mdash; Procedure: <b>fxmod0</b><var> fx1 fx2<a name="index-fxmod0-700"></a></var><br>
<blockquote><p><var>fx2</var> must be nonzero.

        <p>These procedures implement number&ndash;theoretic integer division and return
the results of the corresponding mathematical operations specified in
<a href="baselib-math-semantics-integer.html#baselib-math-semantics-integer">Integer division</a>

     <pre class="example">          (fxdiv <var>fx1</var> <var>fx2</var>)         &rArr; <var>fx1</var> div <var>fx2</var>
          (fxmod <var>fx1</var> <var>fx2</var>)         &rArr; <var>fx1</var> mod <var>fx2</var>
          (fxdiv-and-mod <var>fx1</var> <var>fx2</var>) &rArr; <var>fx1</var> div <var>fx2</var>, <var>fx1</var> mod <var>fx2</var>
                                                  ; two return values
          (fxdiv0 <var>fx1</var> <var>fx2</var>)        &rArr; <var>fx1</var> div_0 <var>fx2</var>
          (fxmod0 <var>fx1</var> <var>fx2</var>)        &rArr; <var>fx1</var> mod_0 <var>fx2</var>
          (fxdiv0-and-mod0 <var>fx1</var> <var>fx2</var>)
          &rArr; <var>fx1</var> <var>fx1</var> div_0 <var>fx2</var>, <var>fx1</var> mod_0 <var>fx2</var>
             ; two return values
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fx+/carry</b><var> fx1 fx2 fx3<a name="index-fx_002b_002fcarry-701"></a></var><br>
<blockquote><p>Return the two fixnum results of the following computation:

     <pre class="example">          (let* ((s (+ <var>fx1</var> <var>fx2</var> <var>fx3</var>))
                 (s0 (mod0 s (expt 2 (fixnum-width))))
                 (s1 (div0 s (expt 2 (fixnum-width)))))
            (values s0 s1))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fx-/carry</b><var> fx1 fx2 fx3<a name="index-fx_002d_002fcarry-702"></a></var><br>
<blockquote><p>Return the two fixnum results of the following computation:

     <pre class="example">          (let* ((d (- <var>fx1</var> <var>fx2</var> <var>fx3</var>))
                 (d0 (mod0 d (expt 2 (fixnum-width))))
                 (d1 (div0 d (expt 2 (fixnum-width)))))
            (values d0 d1))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fx*/carry</b><var> fx1 fx2 fx3<a name="index-fx_002a_002fcarry-703"></a></var><br>
<blockquote><p>Return the two fixnum results of the following computation:

     <pre class="example">          (let* ((s (+ (* <var>fx1</var> <var>fx2</var>) <var>fx3</var>))
                 (s0 (mod0 s (expt 2 (fixnum-width))))
                 (s1 (div0 s (expt 2 (fixnum-width)))))
            (values s0 s1))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxnot</b><var> fx<a name="index-fxnot-704"></a></var><br>
<blockquote><p>Return the unique fixnum that is congruent mod <em>2^w</em> to the
one's&ndash;complement of <var>fx</var>. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxand</b><var> fx1 <small class="dots">...</small><a name="index-fxand-705"></a></var><br>
&mdash; Procedure: <b>fxior</b><var> fx1 <small class="dots">...</small><a name="index-fxior-706"></a></var><br>
&mdash; Procedure: <b>fxxor</b><var> fx1 <small class="dots">...</small><a name="index-fxxor-707"></a></var><br>
<blockquote><p>These procedures return the fixnum that is the bit&ndash;wise &ldquo;and&rdquo;,
&ldquo;inclusive or&rdquo;, or &ldquo;exclusive or&rdquo; of the two's complement
representations of their arguments.  If they are passed only one
argument, they return that argument.  If they are passed no arguments,
they return the fixnum (either <em>-1</em> or <em>0</em>) that acts as
identity for the operation. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxif</b><var> fx1 fx2 fx3<a name="index-fxif-708"></a></var><br>
<blockquote><p>Return the fixnum that is the bit&ndash;wise &ldquo;if&rdquo; of the two's complement
representations of its arguments, i.e. for each bit, if it is 1 in
<var>fx1</var>, the corresponding bit in <var>fx2</var> becomes the value of the
corresponding bit in the result, and if it is 0, the corresponding bit
in <var>fx3</var> becomes the corresponding bit in the value of the result. 
This is the fixnum result of the following computation:

     <pre class="example">          (fxior (fxand <var>fx1</var> <var>fx2</var>)
                 (fxand (fxnot <var>fx1</var>) <var>fx3</var>))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxbit-count</b><var> fx<a name="index-fxbit_002dcount-709"></a></var><br>
<blockquote><p>If <var>fx</var> is non&ndash;negative, this procedure returns the number of 1
bits in the two's complement representation of <var>fx</var>.  Otherwise it
returns the result of the following computation:

     <pre class="example">          (fxnot (fxbit-count (fxnot <var>ei</var>)))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxlength</b><var> fx<a name="index-fxlength-710"></a></var><br>
<blockquote><p>Return the number of bits needed to represent <var>fx</var> if it is
positive, and the number of bits needed to represent <code>(fxnot
</code><var>fx</var><code>)</code> if it is negative, which is the fixnum result of the
following computation:

     <pre class="example">          (do ((result 0 (+ result 1))
               (bits (if (fxnegative? <var>fx</var>)
                         (fxnot <var>fx</var>)
                         <var>fx</var>)
                     (fxarithmetic-shift-right bits 1)))
              ((fxzero? bits)
               result))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxfirst-bit-set</b><var> fx<a name="index-fxfirst_002dbit_002dset-711"></a></var><br>
<blockquote><p>Return the index of the least significant 1 bit in the two's complement
representation of <var>fx</var>.  If <var>fx</var> is 0, then -1 is returned.

     <pre class="example">          (fxfirst-bit-set 0)        &rArr;  -1
          (fxfirst-bit-set 1)        &rArr;  0
          (fxfirst-bit-set -4)       &rArr;  2
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxbit-set?</b><var> fx1 fx2<a name="index-fxbit_002dset_003f-712"></a></var><br>
<blockquote><p><var>fx2</var> must be non&ndash;negative and less than <code>(fixnum-width)</code>.

        <p>The <code>fxbit-set?</code> procedure returns <code>#t</code> if the <var>fx2</var>th bit
is 1 in the two's complement representation of <var>fx1</var>, and <code>#f</code>
otherwise.  This is the fixnum result of the following computation:

     <pre class="example">          (not
            (fxzero?
              (fxand <var>fx1</var>
                     (fxarithmetic-shift-left 1 <var>fx2</var>))))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxcopy-bit</b><var> fx1 fx2 fx3<a name="index-fxcopy_002dbit-713"></a></var><br>
<blockquote><p><var>fx2</var> must be non&ndash;negative and less than <code>(fixnum-width)</code>. 
<var>Fx3</var> must be 0 or 1.

        <p>The <code>fxcopy-bit</code> procedure returns the result of replacing the
<var>fx2</var>th bit of <var>fx1</var> by <var>fx3</var>, which is the result of the
following computation:

     <pre class="example">          (let* ((mask (fxarithmetic-shift-left 1 <var>fx2</var>)))
            (fxif mask
                  (fxarithmetic-shift-left <var>fx3</var> <var>fx2</var>)
                  <var>fx1</var>))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxbit-field</b><var> fx1 fx2 fx3<a name="index-fxbit_002dfield-714"></a></var><br>
<blockquote><p><var>fx2</var> and <var>fx3</var> must be non-negative and less than
<code>(fixnum-width)</code>.  Moreover, <var>fx2</var> must be less than or equal
to <var>fx3</var>.

        <p>The <code>fxbit-field</code> procedure returns the number represented by the
bits at the positions from <var>fx2</var> (inclusive) to <var>fx3</var>
(exclusive), which is the fixnum result of the following computation:

     <pre class="example">          (let* ((mask (fxnot
                        (fxarithmetic-shift-left -1 <var>fx3</var>))))
            (fxarithmetic-shift-right (fxand <var>fx1</var> mask)
                                      <var>fx2</var>))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxcopy-bit-field</b><var> fx1 fx2 fx3 fx4<a name="index-fxcopy_002dbit_002dfield-715"></a></var><br>
<blockquote><p><var>fx2</var> and <var>fx3</var> must be non-negative and less than
<code>(fixnum-width)</code>.  Moreover, <var>fx2</var> must be less than or equal
to <var>fx3</var>.

        <p>The <code>fxcopy-bit-field</code> procedure returns the result of replacing in
<var>fx1</var> the bits at positions from <var>fx2</var> (inclusive) to
<var>fx3</var> (exclusive) by the bits in <var>fx4</var> from position 0
(inclusive) to position <var>fx3</var>-<var>fx2</var> (exclusive), which is the
fixnum result of the following computation:

     <pre class="example">          (let* ((to    <var>fx1</var>)
                 (start <var>fx2</var>)
                 (end   <var>fx3</var>)
                 (from  <var>fx4</var>)
                 (mask1 (fxarithmetic-shift-left -1 start))
                 (mask2 (fxnot (fxarithmetic-shift-left -1 end)))
                 (mask  (fxand mask1 mask2))
                 (mask3 (fxnot (fxarithmetic-shift-left -1 (- end start)))))
            (fxif mask
                  (fxarithmetic-shift-left (fxand from mask3)
                                           start)
                  to))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxarithmetic-shift</b><var> fx1 fx2<a name="index-fxarithmetic_002dshift-716"></a></var><br>
<blockquote><p>The absolute value of <var>fx2</var> must be less than
<code>(fixnum-width)</code>.

        <p>If:

     <pre class="example">          (floor (* <var>fx1</var> (expt 2 <var>fx2</var>)))
</pre>
        <p class="noindent">is a fixnum, then that fixnum is returned.  Otherwise an exception with
condition type <code>&amp;implementation-restriction</code> is raised. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxarithmetic-shift-left</b><var> fx1 fx2<a name="index-fxarithmetic_002dshift_002dleft-717"></a></var><br>
&mdash; Procedure: <b>fxarithmetic-shift-right</b><var> fx1 fx2<a name="index-fxarithmetic_002dshift_002dright-718"></a></var><br>
<blockquote><p><var>fx2</var> must be non&ndash;negative, and less than <code>(fixnum-width)</code>.

        <p>The <code>fxarithmetic-shift-left</code> procedure behaves the same as
<code>fxarithmetic-shift</code>, and <code>(fxarithmetic-shift-right </code><var>fx1</var>
<var>fx2</var><code>)</code> behaves the same as <code>(fxarithmetic-shift </code><var>fx1</var><code>
(fx- </code><var>fx2</var><code>))</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxrotate-bit-field</b><var> fx1 fx2 fx3 fx4<a name="index-fxrotate_002dbit_002dfield-719"></a></var><br>
<blockquote><p><var>fx2</var>, <var>fx3</var>, and <var>fx4</var> must be non&ndash;negative and less
than <code>(fixnum-width)</code>.  <var>fx2</var> must be less than or equal to
<var>fx3</var>.  <var>fx4</var> must be less than the difference between
<var>fx3</var> and <var>fx2</var>.

        <p>The <code>fxrotate-bit-field</code> procedure returns the result of cyclically
permuting in <var>fx1</var> the bits at positions from <var>fx2</var> (inclusive)
to <var>fx3</var> (exclusive) by <var>fx4</var> bits towards the more
significant bits, which is the result of the following computation:

     <pre class="example">          (let* ((n     <var>fx1</var>)
                 (start <var>fx2</var>)
                 (end   <var>fx3</var>)
                 (count <var>fx4</var>)
                 (width (fx- end start)))
            (if (fxpositive? width)
                (let* ((count (fxmod count width))
                       (field0
                         (fxbit-field n start end))
                       (field1
                         (fxarithmetic-shift-left
                           field0 count))
                       (field2
                         (fxarithmetic-shift-right
                           field0 (fx- width count)))
                       (field (fxior field1 field2)))
                  (fxcopy-bit-field n start end field))
                n))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Procedure: <b>fxreverse-bit-field</b><var> fx1 fx2 fx3<a name="index-fxreverse_002dbit_002dfield-720"></a></var><br>
<blockquote><p><var>fx2</var> and <var>fx3</var> must be non-negative and less than
<code>(fixnum-width)</code>.  Moreover, <var>fx2</var> must be less than or equal
to <var>fx3</var>.

        <p>The <code>fxreverse-bit-field</code> procedure returns the fixnum obtained
from <var>fx1</var> by reversing the order of the bits at positions from
<var>fx2</var> (inclusive) to <var>fx3</var> (exclusive).

     <pre class="example">          (fxreverse-bit-field #b1010010 1 4)       &rArr;  88 ; #b1011000
</pre>
        </blockquote></div>

<!-- page -->
   </body></html>

