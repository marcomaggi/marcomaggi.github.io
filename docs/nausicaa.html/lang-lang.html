<html lang="en">
<head>
<title>lang lang - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="lang.html#lang" title="lang">
<link rel="next" href="lang-let.html#lang-let" title="lang let">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d7 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008, 2009, 2010 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="lang-lang"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="lang-let.html#lang-let">lang let</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="lang.html#lang">lang</a>
<hr>
</div>

<h3 class="section">11.1 Language constructs</h3>

<div class="defun">
&mdash; Syntax: <b>begin0</b><var> form0 form ...<a name="index-begin0-961"></a></var><br>
<blockquote><p>Evaluate all the <var>form</var>s like the standard <code>begin</code>, but return
the value of <var>form0</var>.  The implementation comes from the <acronym>R6RS</acronym>
original document, Appendix A &ldquo;Formal semantics&rdquo;.

     <pre class="example">          (define-syntax begin0
            (syntax-rules ()
              ((_ ?form0 ?form ...)
               (call-with-values
                   (lambda () ?form0)
                 (lambda x
                   ?form ...
                   (apply values x))))))
</pre>
        <p>This syntax is called <code>prog1</code> in Common Lisp and Emacs Lisp. 
</p></blockquote></div>

<div class="defun">
&mdash; Syntax: <b>cut</b><var> slot-or-expr ...<a name="index-cut-962"></a></var><br>
&mdash; Syntax: <b>cute</b><var> slot-or-expr ...<a name="index-cute-963"></a></var><br>
&mdash; Auxiliary Syntax: <b>&lt;&gt;</b><var><a name="index-g_t_003c_003e-964"></a></var><br>
&mdash; Auxiliary Syntax: <b>&lt;...&gt;</b><var><a name="index-g_t_003c_002e_002e_002e_003e-965"></a></var><br>
<blockquote><p>When programming in functional style, it is frequently necessary to
specialize some of the parameters of a multi&ndash;parameter procedure.  For
example, from the binary operation <code>cons</code> one might want to obtain
the unary operation <code>(lambda (x) (cons 1 x))</code>.  This specialization
of parameters is also known as &ldquo;partial application&rdquo;, &ldquo;operator
section&rdquo; or &ldquo;projection&rdquo;.

        <p>The <code>cut</code> and <code>cute</code> syntaxes allow to write this sort of
specialization in a simple and compact way.  Examples:

     <pre class="example">          (cut cons (+ a 1) &lt;&gt;)   ==&gt; (lambda (x2)
                                        (cons (+ a 1) x2))
          
          (cut list 1 &lt;&gt; 3 &lt;&gt; 5)  ==&gt; (lambda (x2 x4)
                                        (list 1 x2 3 x4 5))
          
          (cut list)              ==&gt; (lambda () (list))
          
          (cut list 1 &lt;&gt; 3 &lt;...&gt;) ==&gt; (lambda (x2 . xs)
                                        (apply list 1 x2 3 xs))
          
          (cut &lt;&gt; a b)            ==&gt; (lambda (f) (f a b))
</pre>
        <p><code>cut</code> specializes some of the parameters of its first argument. 
The parameters that are to show up as formal variables of the result are
indicated by the symbol <code>&lt;&gt;</code>, pronouced as &ldquo;slot&rdquo;.  In addition,
the symbol <code>&lt;...&gt;</code>, pronounced as &ldquo;rest&ndash;slot&rdquo;, matches all
residual arguments of a variable argument procedure.  The first argument
can also be a slot.

        <p><code>cute</code> evaluates the non&ndash;slot expressions at the time the
procedure is specialized, not at the time the specialized procedure is
called.  For example:

     <pre class="example">          (cute cons (+ a 1) &lt;&gt;) ==&gt; (let ((a1 (+ a 1)))
                                       (lambda (x2)
                                         (cons a1 x2)))
</pre>
        <p class="noindent"><code>cute</code> will evaluate <code>(+ a 1)</code> once, while the <code>cut</code>
would evaluate it during every invocation of the resulting procedure.

        <p>The formal syntax of a specialized expression is:

     <pre class="example">          &lt;cut-expression&gt; -&gt; (cut  &lt;slot-or-expr&gt; &lt;slot-or-expr&gt;*)
                           |  (cut  &lt;slot-or-expr&gt; &lt;slot-or-expr&gt;* &lt;...&gt;)
                           |  (cute &lt;slot-or-expr&gt; &lt;slot-or-expr&gt;*)
                           |  (cute &lt;slot-or-expr&gt; &lt;slot-or-expr&gt;* &lt;...&gt;)
          
          &lt;slot-or-expr&gt;   -&gt; &lt;&gt;              ; a "slot"
                           |  &lt;expression&gt;    ; a "non-slot expression"
</pre>
        <p>The <code>&lt;&gt;</code> and <code>&lt;...&gt;</code> auxiliary syntaxes are exported by the
library <code>(nausicaa language auxiliary-syntaxes)</code> and reexported by
this library. 
</p></blockquote></div>

<div class="defun">
&mdash; Syntax: <b>ensure</b><var> test </var>(<var>by form0 form ...</var>) (<var>else form0 form ...</var>)<var><a name="index-ensure-966"></a></var><br>
&mdash; Syntax: <b>ensure</b><var> test </var>(<var>by form0 form ...</var>) (<var>else-by form0 form ...</var>)<var> ... </var>(<var>else form0 form ...</var>)<var><a name="index-ensure-967"></a></var><br>
<blockquote><p>Evaluate the <var>form</var>s in the <code>by</code> and <code>else-by</code> clauses, in
sequence, until <var>test</var> evaluates to true.  If the first evaluation
of <var>test</var> gives true: no <var>form</var>s are evaluated.  If neither the
<code>by</code> nor the <code>else-by</code> forms succeed in making <var>test</var>
true: the <var>form</var>s in the <code>else</code> clause are evaluated.

        <p>Return the value of the last <var>form</var> in the clause that made
<var>test</var> true, or the value in the last <var>form</var> in the <code>else</code>
clause, or <code>#f</code> if the first evaluation of <var>test</var> was true and
no <var>form</var>s were evaluated.

        <p>Examples:

     <pre class="example">          (let ((i #f))
            (ensure (= i 1)
                (by
                  (set! i 1)
                  123)
              (else-by
                (set! i 2)
                456)
              (else
                (set! i 3)
                789)))
          &rArr; 123
          
          (let ((i #f))
            (ensure (= i 2)
                (by
                  (set! i 1)
                  123)
              (else-by
                (set! i 2)
                456)
              (else
                (set! i 3)
                789)))
          &rArr; 456
          
          (let ((i #f))
            (ensure (= i 3)
                (by
                  (set! i 1)
                  123)
              (else-by
                (set! i 2)
                456)
              (else
                (set! i 3)
                789)))
          &rArr; 789
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Syntax: <b>xor</b><var> expr ...<a name="index-xor-968"></a></var><br>
<blockquote><p>Exclusive <code>or</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Syntax: <b>unwind-protect</b><var> &lt;body&gt; &lt;cleanup0&gt; &lt;cleanup&gt; ...<a name="index-unwind_002dprotect-969"></a></var><br>
<blockquote><p>Utility wrapper for <code>with-exception-handler</code>, expands to:

     <pre class="example">          (let ((cleanup (lambda ()
                           <var>&lt;cleanup0&gt;</var>
                           <var>&lt;cleanup&gt;</var>
                           ...)))
            (with-exception-handler
                (lambda (E)
                  (cleanup)
                  (raise E))
              (lambda ()
                (call-with-values
                    (lambda () <var>&lt;body&gt;</var>)
                  (lambda return-values
                    (cleanup)
                    (apply values return-values))))))
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Syntax: <b>include</b><var> &lt;pathname&gt;<a name="index-include-970"></a></var><br>
<blockquote><p>Read the file with <var>&lt;pathname&gt;</var>, which must be a string, using
<code>get-datum</code> until end&ndash;of&ndash;file; then evaluate the result as if it
was included in the lexical context of the use of <code>include</code>.  This
syntax makes use of no search path.

        <p>This syntax is derived from the example in <a href="stdlib-syntax_002dcase-conversion.html#stdlib-syntax_002dcase-conversion">include</a>. 
</p></blockquote></div>

<!-- page -->
   </body></html>

