<html lang="en">
<head>
<title>parser-tools ip-addresses v4 parser - Nausicaa for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="parser_002dtools-ip_002daddresses-v4.html#parser_002dtools-ip_002daddresses-v4" title="parser-tools ip-addresses v4">
<link rel="prev" href="parser_002dtools-ip_002daddresses-v4-lexer.html#parser_002dtools-ip_002daddresses-v4-lexer" title="parser-tools ip-addresses v4 lexer">
<link rel="next" href="parser_002dtools-ip_002daddresses-v4-errors.html#parser_002dtools-ip_002daddresses-v4-errors" title="parser-tools ip-addresses v4 errors">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.3d6 of Nausicaa, a
collection of libraries for Vicare Scheme implementing the language
`(nausicaa)' on top of `(vicare)'.

Copyright (C) 2012, 2013 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="parser-tools-ip-addresses-v4-parser"></a>
<a name="parser_002dtools-ip_002daddresses-v4-parser"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="parser_002dtools-ip_002daddresses-v4-errors.html#parser_002dtools-ip_002daddresses-v4-errors">parser-tools ip-addresses v4 errors</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="parser_002dtools-ip_002daddresses-v4-lexer.html#parser_002dtools-ip_002daddresses-v4-lexer">parser-tools ip-addresses v4 lexer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="parser_002dtools-ip_002daddresses-v4.html#parser_002dtools-ip_002daddresses-v4">parser-tools ip-addresses v4</a>
<hr>
</div>

<h5 class="subsubsection">11.4.1.2 Parsing an IPv4 address</h5>

<p>The following bindings are exported by the library <code>(nausicaa
parser-tools ipv4-addresses)</code>.

<div class="defun">
&mdash; Function: <b>make-ipv4-address-parser</b><var><a name="index-make_002dipv4_002daddress_002dparser-1486"></a></var><br>
<blockquote><p>Return a low level LALR parser function for IPv4 address or address
prefix textual representations; it works as described in
<a href="parser_002dtools-lalr-parser.html#parser_002dtools-lalr-parser">Running the parser</a>.

        <p>The returned parser function, when applied to the lexer and error
handler, returns a list of values representing the address; this list
must be further parsed and validated as described below.

        <p>The lexer thunk used as argument for the returned parser function must
work as described in <a href="parser_002dtools-ip_002daddresses-v4-lexer.html#parser_002dtools-ip_002daddresses-v4-lexer">Tokenising an IPv4 address string</a>.

        <p>To parse an IPv4 address string with the low&ndash;level parser function we
can do:

     <pre class="example">          (import (nausicaa)
            (prefix (nausicaa parser-tools ipv4-addresses) ip.))
          
          (define (parse-address string)
            (define lexer
              (ip.make-ipv4-address-lexer (ip.string: string)))
            (define parser
              (ip.make-ipv4-address-parser))
            (define error-handler
              (ip.make-ipv4-address-parser-error-handler
                'parse-address (list string)))
            (parser lexer error-handler))
</pre>
        <p>Here are some examples of address parsing:

     <pre class="example">          (parse-address "1.2.3.4")       &rArr; (1 2 3 4)
          (parse-address "192.168.99.1")  &rArr; (192 168 99 1)
</pre>
        <p class="noindent">and here are some examples of address prefix parsing:

     <pre class="example">          (parse-address "1.2.3.4/8")      &rArr; (1 2 3 4 (8))
          (parse-address "192.168.99.1/8") &rArr; (192 168 99 1 (8))
</pre>
        <p>From the examples we see that:

          <ol type=1 start=1>
<li>If the input is an address prefix: the list has 5 elements and
the last element of the returned list is a list of one value, the value
being the prefix length: a number specifying how many of the leftmost
contiguous bits of the address comprise the prefix.

          <li>If the input is an address: the list has 4 elements and the last
element is a number.
             </ol>
</p></blockquote></div>

<div class="defun">
&mdash; Function: <b>parse-ipv4-address-only</b><var> string<a name="index-parse_002dipv4_002daddress_002donly-1487"></a></var><br>
<blockquote><p>High&ndash;level parser function for IPv4 address textual representations. 
If successful: return a list of 4 elements representing the
result of the parsing; otherwise raise an exception with compound
condition object of types <code>&amp;who</code>, <code>&amp;error</code>,
<code>&amp;message</code>, <code>&amp;irritants</code>,
<code>&amp;ipv4-address-parser-error</code>.

     <pre class="example">          (parse-ipv4-address-only "1.2.3.4")
          &rArr; (1 2 3 4)
          
          (parse-ipv4-address-only "192.168.99.1")
          &rArr; (192 168 99 1)
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: <b>parse-ipv4-address-prefix</b><var> string<a name="index-parse_002dipv4_002daddress_002dprefix-1488"></a></var><br>
<blockquote><p>High&ndash;level parser function for IPv4 address prefix textual
representations.  If successful return 2 values: a list of
4 fixnums representing the address numbers and a fixnum
representing the prefix length; otherwise raise an exception with
compound condition object of types <code>&amp;error</code>, <code>&amp;who</code>,
<code>&amp;message</code>, <code>&amp;irritants</code>,
<code>&amp;ipv4-address-parser-error</code>.

     <pre class="example">          (parse-ipv4-address-prefix "1.2.3.4/8")
          &rArr; (1 2 3 4) 8
          
          (parse-ipv4-address-prefix "192.168.99.1/8")
          &rArr; (192 168 99 1) 8
</pre>
        </blockquote></div>

<div class="defun">
&mdash; Function: <b>parse-ipv4-address</b><var> string<a name="index-parse_002dipv4_002daddress-1489"></a></var><br>
<blockquote><p>High&ndash;level parser function for IPv4 address or address prefix textual
representations.  If successful: return a list of 4 or 5
elements representing the result of the parsing; otherwise raise an
exception with compound condition object of types <code>&amp;who</code>,
<code>&amp;error</code>, <code>&amp;message</code>, <code>&amp;irritants</code>,
<code>&amp;ipv4-address-parser-error</code>.

     <pre class="example">          (parse-ipv4-address "1.2.3.4")
          &rArr; (1 2 3 4)
          
          (parse-ipv4-address "192.168.99.1")
          &rArr; (192 168 99 1)
          
          (parse-ipv4-address "1.2.3.4/8")
          &rArr; (1 2 3 4 (8))
          
          (parse-ipv4-address "192.168.99.1/8")
          &rArr; (192 168 99 1 (8))
</pre>
        </blockquote></div>

<!-- page -->
   </body></html>

