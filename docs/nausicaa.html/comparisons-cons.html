<html lang="en">
<head>
<title>comparisons cons - Nausicaa for Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Nausicaa for Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="comparisons.html#comparisons" title="comparisons">
<link rel="prev" href="comparisons-default.html#comparisons-default" title="comparisons default">
<link rel="next" href="comparisons-branch.html#comparisons-branch" title="comparisons branch">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes version 0.2d11 of Nausicaa/Scheme, a set of
Scheme libraries defining a slightly modified R6RS Scheme language
and augmenting the features of the base and standard R6RS libraries.

The project home page of Nausicaa is at:

             `http://marcomaggi.github.com/nausicaa.html'


development of Nausicaa takes place at:

               `http://github.com/marcomaggi/nausicaa/'


Copyright (C) 2008-2011 by Marco Maggi.

Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.

Copyright (C) 1996, 1999-2005 Dorai Sitaram.

Copyright (C) 1998 Oleg Kiselyov.

Copyright (C) 1998, 1999, 2000 Olin Shivers.

Copyright (C) 1999 John David Stone.

Copyright (C) 1999, 2002 Marc Feeley.

Copyright (C) 2001, 2009 Danny Dube'

Copyright (C) 2002 Dr. Mirko Luedde.

Copyright (C) 2002, 2003, 2005, 2006 Sebastian Egner.

Copyright (C) 2003 Ray Dillinger.

Copyright (C) 2003 Taylor Campbell.

Copyright (C) 2005 Jens Axel Soegaard.

Copyright (C) 2005-2009 Alex Shinn.

Copyright (C) 2008 Taro Minowa (Higepon).

Copyright (C) 2005-2008 Dominique Boucher.

Copyright (C) 2004, 2005 Tony Garnock-Jones

Copyright (C) 2005 LShift Ltd.

Copyright (C) 2007, 2008 Philip L. Bewig.

Copyright (C) 2000 Will Fitzgerald.

Copyright (C) 2000 Neodesic Corporation.

Copyright (C) 2000-2006 Joachim Henke.

Copyright (C) 2004-2009 Neil Van Dyke.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections being ``GNU Free
     Documentation License'' and ``GNU General Public License'', no
     Front--Cover Texts, and no Back--Cover Texts.  A copy of the
     license is included in the section entitled ``GNU Free
     Documentation License''.

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
Marco Maggi <marco.maggi-ipsu@poste.it>.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
`README' and `CREDITS' files for additional attributions.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="comparisons-cons"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="comparisons-branch.html#comparisons-branch">comparisons branch</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="comparisons-default.html#comparisons-default">comparisons default</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="comparisons.html#comparisons">comparisons</a>
<hr>
</div>

<h3 class="section">45.8 Constructing compare procedures</h3>

<p>The syntactic extensions defined in this section are the primary
utilities for defining new compare procedures as conveniently as
possible.

<div class="defun">
&mdash; Syntax: <b>refine-compare</b><var> expr ...<a name="index-refine_002dcompare-4434"></a></var><br>
<blockquote><p>The arguments, if any, must be expressions; they are evaluated from left
to right until a non&ndash;zero value is found (which then is the value) or
until there are no more arguments to evaluate (in which case the value
is &lsquo;<samp><span class="samp">0</span></samp>&rsquo;).  If no arguments are supplied, the return value is
&lsquo;<samp><span class="samp">0</span></samp>&rsquo;. 
</p></blockquote></div>

<div class="defun">
&mdash; Syntax: <b>select-compare</b><var> expr1 expr2 clause ...<a name="index-select_002dcompare-4435"></a></var><br>
<blockquote><p>Each <var>clause</var>, with the possible exception of the last, is of the
form:

     <pre class="example">          (<var>&lt;type?&gt;</var> <var>&lt;c1&gt;</var> ...)
</pre>
        <p class="noindent">where <var>&lt;type?&gt;</var> is an expression evaluating to a predicate procedure,
and <var>&lt;ci&gt;</var> are expressions evaluating to an exact integer in
{-1, 0, 1}.  The last <var>clause</var> may be an &ldquo;else clause&rdquo;,
which has the form:

     <pre class="example">          (else <var>&lt;c1&gt;</var> ...)
</pre>
        <p><code>select-compare</code> is a conditional for defining hierarchical
extensions and refinements of compare procedures.  It compares the
values of <var>expr1</var> and <var>expr2</var> by trying the type tests in order,
and applies an implict <code>refine-compare</code> on the consequences upon a
match.

        <p>In more detail, evaluation proceeds as follows: First <var>expr1</var> and
<var>expr2</var> are evaluated in unspecified order, resulting in values
<var>x1</var> and <var>x2</var>, respectively.  Then the clauses are evaluated one
by one, from left to right.

        <p>For clause:

     <pre class="example">          (<var>&lt;type?&gt;</var> <var>&lt;c1&gt;</var> ...)
</pre>
        <p class="noindent">first <var>&lt;type?&gt;</var> is evaluated resulting in a predicate procedure
<var>type?</var>  and then the expressions <code>(</code><var>type?</var> <var>x1</var><code>)</code> and
<code>(</code><var>type?</var>  <var>x2</var><code>)</code> are evaluated and interpreted as
booleans:

          <ol type=1 start=1>
<li>If both booleans are true then the overall value is:

          <pre class="example">               (refine-compare <var>&lt;c1&gt;</var> ...)
</pre>
          <li>If only the first is true the result is &lsquo;<samp><span class="samp">-1</span></samp>&rsquo;.

          <li>If only the second is true the result is &lsquo;<samp><span class="samp">+1</span></samp>&rsquo;.

          <li>If neither is true the next clause is considered.
             </ol>

        <p>An else clause is treated as if both tests where true.  If there are no
clauses left, the result is &lsquo;<samp><span class="samp">0</span></samp>&rsquo;.

        <p><code>select-compare</code> evaluates <var>expr1</var> and <var>expr2</var> exactly
once, even in the absence of any clauses.  Moreover, each <var>&lt;type?&gt;</var>
is evaluated at most once and the resulting procedure <var>type?</var> is
called at most twice. 
</p></blockquote></div>

<div class="defun">
&mdash; Syntax: <b>cond-compare</b><var> &lt;clause&gt; ...<a name="index-cond_002dcompare-4436"></a></var><br>
<blockquote><p>Each <var>&lt;clause&gt;</var>, with the possible exception of the last, is of the
form:

     <pre class="example">          ((<var>&lt;t1&gt;</var> <var>&lt;t2&gt;</var>) <var>&lt;c1&gt;</var> ...)
</pre>
        <p class="noindent">where <var>&lt;t1&gt;</var> and <var>&lt;t2&gt;</var> are expressions evaluating to booleans,
and <var>&lt;ci&gt;</var> are expressions evaluating to an exact integer in
{-1, 0, 1}.

        <p>The last <var>clause</var> may be an &ldquo;else clause&rdquo;, which has the form:

     <pre class="example">          (else <var>&lt;c1&gt;</var> ...)
</pre>
        <p><code>cond-compare</code> is another conditional for defining hierarchical
extensions and refinements of compare procedures.

        <p>Evaluation proceeds as follows: The clauses are evaluated one by one,
from left to right.  For clause:

     <pre class="example">          ((<var>&lt;t1&gt;</var> <var>&lt;t2&gt;</var>) <var>&lt;c1&gt;</var> ...)
</pre>
        <p class="noindent">first <var>&lt;t1&gt;</var> and <var>&lt;t2&gt;</var> are evaluated and the results are
interpreted as boolean values:

          <ol type=1 start=1>
<li>If both booleans are true then the overall value is:

          <pre class="example">               (refine-compare <var>&lt;c1&gt;</var> ...)
</pre>
          <li>If only the first is true the result is &lsquo;<samp><span class="samp">-1</span></samp>&rsquo;.

          <li>If only the second is true the result is &lsquo;<samp><span class="samp">+1</span></samp>&rsquo;.

          <li>If neither is true the next clause is considered.
             </ol>

        <p>An else clause is treated as if both booleans where true.  If there are
no clauses left (or there are no clauses to begin with), the result is
&lsquo;<samp><span class="samp">0</span></samp>&rsquo;.

        <p><code>cond-compare</code> evaluates each expression at most once. 
</p></blockquote></div>

<!-- page -->
   </body></html>

