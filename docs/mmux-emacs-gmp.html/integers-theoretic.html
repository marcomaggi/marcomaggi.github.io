<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This document describes version 0.1.0-devel.0 of MMUX Emacs GMP, a GNU Emacs module
implemented on top of a C11 language library, providing an interface to the GMP library.

The library supports POSIX platforms.  This package is meant to work with GNU Emacs version
26+ and GMP version 6.2.0+.  This package depends upon the external packages:
cl-lib.  To run the test suite: this package requires the ERT package.

This package is distributed under the terms of the GNU General Public License (GPL).

The latest release can be downloaded from:

https://bitbucket.org/marcomaggi/mmux-emacs-gmp/downloads

development takes place at:

https://github.com/marcomaggi/mmux-emacs-gmp

and as backup at:

https://bitbucket.org/marcomaggi/mmux-emacs-gmp

Copyright (C) 2020 by Marco Maggi mrc.mgg@gmail.com


Permission is granted to copy, distribute and/or modify this document under the terms of the GNU
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being "GNU Free Documentation License" and "GNU General
Public License", no Front-Cover Texts, and no Back-Cover Texts.  A copy of the license is
included in the section entitled "GNU Free Documentation License". -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>integers theoretic (MMUX Emacs GMP)</title>

<meta name="description" content="integers theoretic (MMUX Emacs GMP)">
<meta name="keywords" content="integers theoretic (MMUX Emacs GMP)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="concept-index.html" rel="index" title="concept index">
<link href="type-index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="integers.html" rel="up" title="integers">
<link href="integers-bitlogic.html" rel="next" title="integers bitlogic">
<link href="integers-comparison.html" rel="prev" title="integers comparison">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<span id="integers-theoretic"></span><div class="header">
<p>
Next: <a href="integers-bitlogic.html" accesskey="n" rel="next">integers bitlogic</a>, Previous: <a href="integers-comparison.html" accesskey="p" rel="prev">integers comparison</a>, Up: <a href="integers.html" accesskey="u" rel="up">integers</a> &nbsp; [<a href="type-index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Number-theoretic-functions"></span><h3 class="section">3.10 Number theoretic functions</h3>


<dl>
<dt id="index-mpz_002dprobab_002dprime_002dp">Generic Function: <strong>mpz-probab-prime-p</strong> <em>(<var>N</var> <var>REPS</var>)</em></dt>
<dt id="index-mpz_002dprobab_002dprime_002dp-1">Method: <strong>mpz-probab-prime-p</strong> <em>((<var>N</var> mpz) (<var>REPS</var> integer))</em></dt>
<dd><p>Determine whether <var>N</var> is prime.
</p>
<div class="lisp">
<pre class="lisp">(mpz-probab-prime-p (mpz 3) 2)
&rArr; 2
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dnextprime">Generic Function: <strong>mpz-nextprime</strong> <em>(<var>ROP</var> <var>OP</var>)</em></dt>
<dt id="index-mpz_002dnextprime-1">Method: <strong>mpz-nextprime</strong> <em>((<var>ROP</var> mpz) (<var>OP</var> mpz))</em></dt>
<dd><p>Set <var>ROP</var> to the next prime greater than <var>OP</var>.
</p>
<div class="lisp">
<pre class="lisp">(let ((rop    (mpz))
      (op     (mpz 5)))
  (mpz-nextprime rop op)
  (mpz-get-si rop))
&rArr; 7a
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dgcd">Generic Function: <strong>mpz-gcd</strong> <em>(<var>ROP</var> <var>OP1</var> <var>OP2</var>)</em></dt>
<dt id="index-mpz_002dgcd-1">Method: <strong>mpz-gcd</strong> <em>((<var>ROP</var> mpz) (<var>OP1</var> mpz) (<var>OP2</var> mpz))</em></dt>
<dd><p>Set <var>ROP</var> to the greatest common divisor of <var>OP1</var> and <var>OP2</var>.
</p>
<div class="lisp">
<pre class="lisp">(let ((rop    (mpz))
      (op1    (mpz 10))
      (op2    (mpz 12)))
  (mpz-gcd rop op1 op2)
  (mpz-get-si rop))
&rArr; 2
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dgcd_002dui">Generic Function: <strong>mpz-gcd-ui</strong> <em>(<var>ROP</var> <var>OP1</var> <var>OP2</var>)</em></dt>
<dt id="index-mpz_002dgcd_002dui-1">Method: <strong>mpz-gcd-ui</strong> <em>((<var>ROP</var> mpz) (<var>OP1</var> mpz) (<var>OP2</var> integer))</em></dt>
<dd><p>Set <var>ROP</var> to the greatest common divisor of <var>OP1</var> and <var>OP2</var>.
</p>
<div class="lisp">
<pre class="lisp">(let ((rop    (mpz))
      (op1    (mpz 10))
      (op2    12))
  (let ((rop1 (mpz-gcd-ui rop op1 op2)))
    (mpz-get-si rop)    &rArr; 2
    rop1))              &rArr; 2
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dgcdext">Generic Function: <strong>mpz-gcdext</strong> <em>(<var>G</var> <var>S</var> <var>T</var> <var>A</var> <var>B</var>)</em></dt>
<dt id="index-mpz_002dgcdext-1">Method: <strong>mpz-gcdext</strong> <em>((G mpz) (S mpz) (T mpz) (A mpz) (B mpz))</em></dt>
<dd><p>Set <var>G</var> to the greatest common divisor of <var>A</var> and <var>B</var>, and in addition set <var>S</var> and
<var>T</var> to coefficients satisfying <var>A</var>*<var>S</var> + <var>B</var>*<var>T</var> = <var>G</var>.
</p>
<div class="lisp">
<pre class="lisp">;; A * S + B * T = G -&gt; 110 * 3 + 82 * (-4) = 2
(let ((G      (mpz))
      (S      (mpz))
      (T      (mpz))
      (A      (mpz 110))
      (B      (mpz 82)))
  (mpz-gcdext G S T A B)
  (mpz-get-si G)        &rArr; +2
  (mpz-get-si S)        &rArr; +3
  (mpz-get-si T))       &rArr; -4
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dlcm">Generic Function: <strong>mpz-lcm</strong> <em>(<var>ROP</var> <var>OP1</var> <var>OP2</var>)</em></dt>
<dt id="index-mpz_002dLCM">Method: <strong>mpz-<var>LCM</var></strong> <em>((rop mpz) (<var>OP1</var> mpz) (<var>OP2</var> mpz))</em></dt>
<dd><p>Set <var>ROP</var> to the least common multiple of <var>OP1</var> and <var>OP2</var>.
</p>
<div class="lisp">
<pre class="lisp">;;(* 2 7 5) =&gt; 70
(let ((rop    (mpz))
      (op1    (mpz (* 2 5)))
      (op2    (mpz (* 2 7))))
  (mpz-lcm rop op1 op2)
  (mpz-get-si rop))
&rArr; 70
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dlcm_002dui">Generic Function: <strong>mpz-lcm-ui</strong> <em>(<var>ROP</var> <var>OP1</var> <var>OP2</var>)</em></dt>
<dt id="index-mpz_002dlcm_002dui-1">Method: <strong>mpz-lcm-ui</strong> <em>((<var>ROP</var> mpz) (<var>OP1</var> mpz) (<var>OP2</var> integer))</em></dt>
<dd><p>Set <var>ROP</var> to the least common multiple of <var>OP1</var> and <var>OP2</var>.
</p>
<div class="lisp">
<pre class="lisp">;;(* 2 7 5) =&gt; 70
(let ((rop    (mpz))
      (op1    (mpz (* 2 5)))
      (op2    (* 2 7)))
  (mpz-lcm-ui rop op1 op2)
  (mpz-get-si rop))
&rArr; 70
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dinvert">Generic Function: <strong>mpz-invert</strong> <em>(<var>ROP</var> <var>OP1</var> <var>OP2</var>)</em></dt>
<dt id="index-mpz_002dinvert-1">Method: <strong>mpz-invert</strong> <em>((<var>ROP</var> mpz) (<var>OP1</var> mpz) (<var>OP2</var> mpz))</em></dt>
<dd><p>Compute the inverse of <var>OP1</var> modulo <var>OP2</var> and put the result in <var>ROP</var>.  See:
</p>
<div align="center"><a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse">https://en.wikipedia.org/wiki/Modular_multiplicative_inverse</a>
</div>
<div class="lisp">
<pre class="lisp">;;OP2 divides (evenly) the quantity ROP * OP1 - 1
;;
;; ROP * OP1 = X * OP2 + 1
;; 4 * 3 = 1 * 11 + 1
;;
(let ((rop    (mpz))
      (op1    (mpz 3))
      (op2    (mpz 11)))
  (let ((rv (mpz-invert rop op1 op2)))
    rv                  &rArr; t
    (mpz-get-si rop)))  &rArr; 4
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002djacobi">Generic Function: <strong>mpz-jacobi</strong> <em>(<var>A</var> <var>B</var>)</em></dt>
<dt id="index-mpz_002djacobi-1">Method: <strong>mpz-jacobi</strong> <em>((<var>A</var> mpz) (<var>B</var> mpz))</em></dt>
<dd><p>Calculate the Jacobi symbol (<var>A</var>/<var>B</var>).  This is defined only for <var>B</var> odd.
</p>
<div class="lisp">
<pre class="lisp">(let ((A      (mpz 11))
      (B      (mpz 9)))
  (mpz-jacobi A B))
&rArr; 1
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dlegendre">Generic Function: <strong>mpz-legendre</strong> <em>(<var>A</var> <var>B</var>)</em></dt>
<dt id="index-mpz_002dlegendre-1">Method: <strong>mpz-legendre</strong> <em>((<var>A</var> mpz) (<var>B</var> mpz))</em></dt>
<dd><p>Calculate the Legendre symbol (<var>A</var>/<var>P</var>).
</p>
<div class="lisp">
<pre class="lisp">(let ((A      (mpz 20))
      (P      (mpz 11)))
  (mpz-legendre A P))
&rArr; 1
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dkronecker">Generic Function: <strong>mpz-kronecker</strong> <em>(<var>A</var> <var>B</var>)</em></dt>
<dt id="index-mpz_002dkronecker-1">Method: <strong>mpz-kronecker</strong> <em>((<var>A</var> mpz) (<var>B</var> mpz))</em></dt>
<dd><p>Calculate the Jacobi symbol (<var>A</var>/<var>B</var>) with the Kronecker extension (<var>A</var>/2)=(<var>2</var>/A)
when a odd, or (<var>A</var>/2)=0 <var>WHEN</var> a even.
</p>
<div class="lisp">
<pre class="lisp">(let ((A      (mpz 15))
      (B      (mpz 4)))
  (mpz-kronecker A B))
&rArr; 1
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dkronecker_002dsi">Generic Function: <strong>mpz-kronecker-si</strong> <em>(<var>A</var> <var>B</var>)</em></dt>
<dt id="index-mpz_002dkronecker_002dsi-1">Method: <strong>mpz-kronecker-si</strong> <em>((<var>A</var> mpz) (<var>B</var> integer))</em></dt>
<dd><p>Calculate the Jacobi symbol (<var>A</var>/<var>B</var>) with the Kronecker extension (<var>A</var>/2)=(2/<var>A</var>)
when <var>A</var> odd, or (<var>A</var>/2)=0 when a even.
</p>
<div class="lisp">
<pre class="lisp">(let ((A      (mpz 15))
      (B      4))
  (mpz-kronecker-si A B))
&rArr; 1
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dkronecker_002dui">Generic Function: <strong>mpz-kronecker-ui</strong> <em>(<var>A</var> <var>B</var>)</em></dt>
<dt id="index-mpz_002dkronecker_002dui-1">Method: <strong>mpz-kronecker-ui</strong> <em>((<var>A</var> mpz) (<var>B</var> integer))</em></dt>
<dd><p>Calculate the Jacobi symbol (<var>A</var>/<var>B</var>) with the Kronecker extension (<var>A</var>/2)=(2/<var>A</var>)
when <var>A</var> odd, or (<var>A</var>/2)=0 when a even.
</p>
<div class="lisp">
<pre class="lisp">(let ((A      (mpz 15))
      (B      4))
  (mpz-kronecker-ui A B))
&rArr; 1
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dsi_002dkronecker">Generic Function: <strong>mpz-si-kronecker</strong> <em>(A B)</em></dt>
<dt id="index-mpz_002dsi_002dkronecker-1">Method: <strong>mpz-si-kronecker</strong> <em>((A integer) (B mpz))</em></dt>
<dd><p>Calculate the Jacobi symbol (<var>A</var>/<var>B</var>) with the Kronecker extension (<var>A</var>/2)=(2/<var>A</var>)
when <var>A</var> odd, or (<var>A</var>/2)=0 when a even.
</p>
<div class="lisp">
<pre class="lisp">(let ((A      15)
      (B      (mpz 4)))
  (mpz-si-kronecker A B))
&rArr; 1
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dui_002dkronecker">Generic Function: <strong>mpz-ui-kronecker</strong> <em>(A B)</em></dt>
<dt id="index-mpz_002dui_002dkronecker-1">Method: <strong>mpz-ui-kronecker</strong> <em>((A integer) (B mpz))</em></dt>
<dd><p>Calculate the Jacobi symbol (<var>A</var>/<var>B</var>) with the Kronecker extension (<var>A</var>/2)=(2/<var>A</var>)
when <var>A</var> odd, or (<var>A</var>/2)=0 when a even.
</p>
<div class="lisp">
<pre class="lisp">(let ((A      15)
      (B      (mpz 4)))
  (mpz-ui-kronecker A B))
&rArr; 1
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dremove">Generic Function: <strong>mpz-remove</strong> <em>(<var>ROP</var> <var>OP</var> <var>F</var>)</em></dt>
<dt id="index-mpz_002dremove-1">Method: <strong>mpz-remove</strong> <em>((<var>ROP</var> mpz) (<var>OP</var> mpz) (<var>F</var> mpz))</em></dt>
<dd><p>Remove all occurrences of the factor <var>F</var> from <var>OP</var> and store the result in <var>ROP</var>.
</p>
<div class="lisp">
<pre class="lisp">(let ((rop    (mpz))
      (op     (mpz 45))
      (F      (mpz 3)))
  (let ((rv (mpz-remove rop op F)))
    rv                  &rArr; 2
    (mpz-get-si rop)))  &rArr; 5
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dfac_002dui">Generic Function: <strong>mpz-fac-ui</strong> <em>(<var>ROP</var> <var>N</var>)</em></dt>
<dt id="index-mpz_002dfac_002dui-1">Method: <strong>mpz-fac-ui</strong> <em>((<var>ROP</var> mpz) (<var>N</var> integer))</em></dt>
<dd><p>Set <var>ROP</var> to the factorial of <var>N</var>.
</p>
<div class="lisp">
<pre class="lisp">;; (* 4 3 2 1) =&gt; 24
(let ((rop    (mpz))
      (N      4))
  (mpz-fac-ui rop N)
  (mpz-get-si rop))
&rArr; 24
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002d2fac_002dui">Generic Function: <strong>mpz-2fac-ui</strong> <em>(<var>ROP</var> <var>N</var>)</em></dt>
<dt id="index-mpz_002d2fac_002dui-1">Method: <strong>mpz-2fac-ui</strong> <em>((<var>ROP</var> mpz) (<var>N</var> integer))</em></dt>
<dd><p>Set <var>ROP</var> to the double factorial of <var>N</var>: <var>N</var>!!.  See:
</p>
<div align="center"><a href="https://en.wikipedia.org/wiki/Factorial#Multifactorials">https://en.wikipedia.org/wiki/Factorial#Multifactorials</a>
</div>
<div class="lisp">
<pre class="lisp">;;from the full factorial select the first number every 2:
;;
;; (* 9 8 7 6 5 4 3 2 1) -&gt; (* 9 7 5 3 1) =&gt; 945
;;    ^   ^   ^   ^   ^
;;
(let ((rop    (mpz))
      (N      9))
  (mpz-2fac-ui rop N)
  (mpz-get-si rop))
&rArr; 945
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dmfac_002duiui">Generic Function: <strong>mpz-mfac-uiui</strong> <em>(<var>ROP</var> <var>N</var> <var>M</var>)</em></dt>
<dt id="index-mpz_002dmfac_002duiui-1">Method: <strong>mpz-mfac-uiui</strong> <em>((<var>ROP</var> mpz) (<var>N</var> integer) (<var>M</var> integer))</em></dt>
<dd><p>Set <var>ROP</var> to the <var>M</var>&ndash;multi&ndash;factorial of <var>N</var>: <var>N</var>!^(<var>M</var>).  See:
</p>
<div align="center"><a href="https://en.wikipedia.org/wiki/Factorial#Multifactorials">https://en.wikipedia.org/wiki/Factorial#Multifactorials</a>
</div>
<div class="lisp">
<pre class="lisp">;;from the full factorial select the first number every 4:
;;
;;(* 10 9 8 7 6 5 4 3 2 1) -&gt; (* 10 6 2) =&gt; 120
;;   ^        ^       ^
(let ((rop    (mpz))
      (N      10)
      (M      4))
  (mpz-mfac-uiui rop N M)
  (mpz-get-si rop))
&rArr; 120
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dprimorial_002dui">Generic Function: <strong>mpz-primorial-ui</strong> <em>(<var>ROP</var> <var>N</var>)</em></dt>
<dt id="index-mpz_002dprimorial_002dui-1">Method: <strong>mpz-primorial-ui</strong> <em>((<var>ROP</var> mpz) (<var>N</var> integer))</em></dt>
<dd><p>Set <var>ROP</var> to the primorial of <var>N</var>: the product of all positive prime numbers &lt;=<var>N</var>.
</p>
<div class="lisp">
<pre class="lisp">;; (* 7 5 3 2 1) =&gt; 210
(let ((rop    (mpz))
      (op     7))
  (mpz-primorial-ui rop op)
  (mpz-get-si rop))
&rArr; 210
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dbin_002dui">Generic Function: <strong>mpz-bin-ui</strong> <em>(<var>ROP</var> <var>N</var> <var>K</var>)</em></dt>
<dt id="index-mpz_002dbin_002dui-1">Method: <strong>mpz-bin-ui</strong> <em>((<var>ROP</var> mpz) (<var>N</var> mpz) (<var>K</var> integer))</em></dt>
<dd><p>Compute the binomial coefficient <var>N</var> over <var>K</var> and store the result in <var>ROP</var>.
</p>
<div class="lisp">
<pre class="lisp">(let ((rop    (mpz))
      (N      (mpz 4))
      (K      2))
  (mpz-bin-ui rop N K)
  (mpz-get-si rop))
&rArr; 6
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dbin_002duiui">Generic Function: <strong>mpz-bin-uiui</strong> <em>(<var>ROP</var> <var>N</var> <var>K</var>)</em></dt>
<dt id="index-mpz_002dbin_002duiui-1">Method: <strong>mpz-bin-uiui</strong> <em>((<var>ROP</var> mpz) (<var>N</var> integer) (<var>K</var> integer))</em></dt>
<dd><p>Compute the binomial coefficient <var>N</var> over <var>K</var> and store the result in <var>ROP</var>.
</p>
<div class="lisp">
<pre class="lisp">(let ((rop    (mpz))
      (N      4)
      (K      2))
  (mpz-bin-uiui rop N K)
  (mpz-get-si rop))
&rArr; 6
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dfib_002dui">Generic Function: <strong>mpz-fib-ui</strong> <em>(<var>FN</var> <var>N</var>)</em></dt>
<dt id="index-mpz_002dfib_002dui-1">Method: <strong>mpz-fib-ui</strong> <em>((<var>FN</var> mpz) (<var>N</var> integer))</em></dt>
<dd><p>Set <var>FN</var> to to F[<var>N</var>]: the <var>N</var>&rsquo;th Fibonacci number.
</p>
<div class="lisp">
<pre class="lisp">(let ((FN     (mpz))
      (N      20))
  (mpz-fib-ui FN N)
  (mpz-get-si FN))
&rArr; 6765
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dfib2_002dui">Generic Function: <strong>mpz-fib2-ui</strong> <em>(FN FNSUB1 N)</em></dt>
<dt id="index-mpz_002dfib2_002dui-1">Method: <strong>mpz-fib2-ui</strong> <em>((FN mpz) (FNSUB1 mpz) (N integer))</em></dt>
<dd><p>Set <var>FN</var> to to F[<var>N</var>]: the <var>N</var>&rsquo;th Fibonacci number.  Set <var>FNSUB1</var> to to
F[<var>N</var>-1].
</p>
<div class="lisp">
<pre class="lisp">(let ((FN     (mpz))
      (FNSUB1 (mpz))
      (N      20))
  (mpz-fib2-ui FN FNSUB1 N)
  (mpz-get-si FN)               &rArr; 6765
  (mpz-get-si FNSUB1))          &rArr; 4181
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dlucnum_002dui">Generic Function: <strong>mpz-lucnum-ui</strong> <em>(<var>LN</var> <var>N</var>)</em></dt>
<dt id="index-mpz_002dlucnum_002dui-1">Method: <strong>mpz-lucnum-ui</strong> <em>((<var>LN</var> mpz) (<var>N</var> mpz))</em></dt>
<dd><p>Set <var>LN</var> to to L[<var>N</var>]: the <var>N</var>&rsquo;th Lucas number.
</p>
<div class="lisp">
<pre class="lisp">(let ((LN     (mpz))
      (N      9))
  (mpz-lucnum-ui LN N)
  (mpz-get-si LN))
&rArr; 76
</pre></div>
</dd></dl>


<dl>
<dt id="index-mpz_002dlucnum2_002dui">Generic Function: <strong>mpz-lucnum2-ui</strong> <em>(<var>LN</var> <var>LNSUB1</var> <var>N</var>)</em></dt>
<dt id="index-mpz_002dlucnum2_002dui-1">Method: <strong>mpz-lucnum2-ui</strong> <em>((<var>LN</var> mpz) (<var>LNSUB1</var> mpz) (<var>N</var> integer))</em></dt>
<dd><p>Set <var>LN</var> to to L[<var>N</var>]: the <var>N</var>&rsquo;th Lucas number.  Set <var>LNSUB1</var> to to L[<var>N</var>-1].
</p>
<div class="lisp">
<pre class="lisp">(let ((LN     (mpz))
      (LNSUB1 (mpz))
      (N      9))
  (mpz-lucnum2-ui LN LNSUB1 N)
  (mpz-get-si LN)       &rArr; 76
  (mpz-get-si LNSUB1))  &rArr; 47
</pre></div>
</dd></dl>

<hr>
<div class="header">
<p>
Next: <a href="integers-bitlogic.html" accesskey="n" rel="next">integers bitlogic</a>, Previous: <a href="integers-comparison.html" accesskey="p" rel="prev">integers comparison</a>, Up: <a href="integers.html" accesskey="u" rel="up">integers</a> &nbsp; [<a href="type-index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p>
</div>


<p>This document describes version <tt>0.1.0-devel.0</tt> of <em>MMUX Emacs GMP</em>.</p>
</body>
</html>
