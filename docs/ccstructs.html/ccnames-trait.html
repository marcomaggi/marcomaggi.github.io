<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This document describes version 0.3.0-devel.3 of CCStructs, a C11 language library
implementing common programming traits for C data structures.

This package supports POSIX platforms.  This package depends on the external packages:
CCExceptions, at least version 0.9.0; CCMemory, at least version
0.2.2.  To run the test suite: this package depends upon the external package
CCTests, at least version 0.4.1.

The package is distributed under the terms of the GNU Lesser General Public License (LGPL).

The latest release can be downloaded from:

https://bitbucket.org/marcomaggi/ccstructs/downloads

development takes place at:

https://github.com/marcomaggi/ccstructs

and as backup at:

https://bitbucket.org/marcomaggi/ccstructs

Copyright (C) 2018, 2019 by Marco Maggi mrc.mgg@gmail.com

Permission is granted to copy, distribute and/or modify this document under the terms of the GNU
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being "GNU Free Documentation License" and "GNU General
Public License", no Front-Cover Texts, and no Back-Cover Texts.  A copy of the license is
included in the section entitled "GNU Free Documentation License". -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>ccnames trait (CCStructs)</title>

<meta name="description" content="ccnames trait (CCStructs)">
<meta name="keywords" content="ccnames trait (CCStructs)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="concept-index.html" rel="index" title="concept index">
<link href="type-index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="ccnames.html" rel="up" title="ccnames">
<link href="Package-License.html" rel="next" title="Package License">
<link href="ccnames-struct-table.html" rel="prev" title="ccnames struct table">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="cclibraries.css">


</head>

<body lang="en">
<span id="ccnames-trait"></span><div class="header">
<p>
Previous: <a href="ccnames-struct-table.html" accesskey="p" rel="prev">ccnames struct table</a>, Up: <a href="ccnames.html" accesskey="u" rel="up">ccnames</a> &nbsp; [<a href="type-index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Well-known-names-for-trait-types_002e"></span><h3 class="appendixsec">A.3 Well known names for trait types.</h3>


<p>The macros for &ldquo;well known trait functions&rdquo; define an <acronym>API</acronym> to implement trait <code>struct</code>
types; an trait is a set of operations we can apply to a data <code>struct</code>; multiple data <code>struct</code>
types can implement multiple traits.  The following macros are defined in the header file
<samp>ccnames.h</samp>.
</p>

<dl>
<dt id="index-ccname_005ftrait_005fnew_005ftype">Macro: <strong>ccname_trait_new_type</strong> <em>(<var>TRAIT_TYPE</var>)</em></dt>
<dt id="index-ccname_005ftrait_005fnew_005ftype-1">Macro: <strong>ccname_trait_new_type</strong> <em>(<var>TRAIT_TYPE</var>, <var>STRUCT_TYPE</var>)</em></dt>
<dt id="index-ccname_005ftrait_005fnew_005ftype-2">Macro: <strong>ccname_trait_new_type</strong> <em>(<var>TRAIT_TYPE</var>, <var>STRUCT_TYPE</var>, <var>VARIANT</var>)</em></dt>
<dd><p>Given an trait type name, an optional struct name and an optional variant specification: expand
into the function type name of trait implementation constructors.  Constructors of such type
must build instances of <var>TRAIT_TYPE</var> as implemented by <var>STRUCT_TYPE</var>, as specified for the
variant <var>VARIANT</var>.
</p></dd></dl>


<dl>
<dt id="index-ccname_005ftrait_005fnew">Macro: <strong>ccname_trait_new</strong> <em>(<var>TRAIT_TYPE</var>, <var>STRUCT_TYPE</var>)</em></dt>
<dt id="index-ccname_005ftrait_005fnew-1">Macro: <strong>ccname_trait_new</strong> <em>(<var>TRAIT_TYPE</var>, <var>STRUCT_TYPE</var>, <var>VARIANT</var>)</em></dt>
<dd><p>Given an trait type name, a struct type name, an optional variant specification: expand into the
name of the <acronym>API</acronym> function <code>new()</code> that instantiates that variant of the trait for the
<code>struct</code>.
</p></dd></dl>


<dl>
<dt id="index-ccname_005ftrait_005ftable_005ftype">Macro: <strong>ccname_trait_table_type</strong> <em>(<var>TRAIT_TYPE</var>)</em></dt>
<dt id="index-ccname_005ftrait_005ftable_005ftype-1">Macro: <strong>ccname_trait_table_type</strong> <em>(<var>TRAIT_TYPE</var>, <var>VARIANT</var>)</em></dt>
<dd><p>Given an trait type name and an optional variant specification: expand into the name of the
methods table type for the trait type.
</p></dd></dl>


<dl>
<dt id="index-ccname_005ftrait_005ftable">Macro: <strong>ccname_trait_table</strong> <em>(<var>TRAIT_TYPE</var>, <var>STRUCT_TYPE</var>)</em></dt>
<dt id="index-ccname_005ftrait_005ftable-1">Macro: <strong>ccname_trait_table</strong> <em>(<var>TRAIT_TYPE</var>, <var>STRUCT_TYPE</var>, <var>VARIANT</var>)</em></dt>
<dd><p>Given an trait type name, a struct type name, and an optional variant specification: expand into
the name of the methods table for that variant of the trait implementation for the <code>struct</code>
type.
</p></dd></dl>


<dl>
<dt id="index-ccname_005ftrait_005fmethod_005ftype">Macro: <strong>ccname_trait_method_type</strong> <em>(<var>TRAIT_TYPE</var>, <var>METHOD_NAME</var>)</em></dt>
<dt id="index-ccname_005ftrait_005fmethod_005ftype-1">Macro: <strong>ccname_trait_method_type</strong> <em>(<var>TRAIT_TYPE</var>, <var>VARIANT</var>, <var>METHOD_NAME</var>)</em></dt>
<dd><p>Given an trait type name, an optional variant specification, and a method name: expand into the
type name of the method function for that variant of the trait implementation.
</p></dd></dl>


<dl>
<dt id="index-ccname_005ftrait_005fmethod">Macro: <strong>ccname_trait_method</strong> <em>(<var>TRAIT_TYPE</var>, <var>STRUCT_TYPE</var>, <var>METHOD_NAME</var>)</em></dt>
<dt id="index-ccname_005ftrait_005fmethod-1">Macro: <strong>ccname_trait_method</strong> <em>(<var>TRAIT_TYPE</var>, <var>STRUCT_TYPE</var>, <var>VARIANT</var>, <var>METHOD_NAME</var>)</em></dt>
<dd><p>Given an trait type name, a struct type name, an optional variant specification, and a method
name: expand into the name of the method function for that variant of the trait implementation
for the struct type.
</p></dd></dl>


<p>Let&rsquo;s say we have this <code>struct</code> definition:
</p>
<div class="example">
<pre class="example">typedef struct my_coords_t      my_coords_t;

struct my_coords_t {
  double        X;
  double        Y;
};
</pre></div>

<p>and we want to define an trait type <code>my_printable_T</code> to print the <code>struct</code> on a
standard stream, both in rectangular and polar forms.
</p>
<p>Every trait must have a <code>struct</code> acting as table of pointers to functions, whose functions
implements the trait methods.  The trait <code>struct</code> type is unique, the methods table
<code>struct</code> type is unique; for every data <code>struct</code> that implements the trait: we need a methods
table and an trait constructor.
</p>
<p>The trait <code>struct</code> type and the methods table <code>struct</code> type are defined as follows:
</p>
<div class="example">
<pre class="example">typedef struct my_printable_T   my_printable_T;
typedef struct ccname_trait_table_type(my_printable_T) \
  ccname_trait_table_type(my_printable_T);

struct my_printable_T {
  ccname_trait_table_type(my_printable_T)  const * methods;
  ccstructs_core_t                         const * self;
};

typedef void ccname_trait_method_type(my_printable_T, print) \
  (my_printable_T I, FILE * stream);

struct ccname_trait_table_type(my_printable_T) {
  ccname_trait_method_type(my_printable_T, print) * print_rec;
  ccname_trait_method_type(my_printable_T, print) * print_pol;
};
</pre></div>

<p>The <code>my_printable_T</code> trait <acronym>API</acronym> is defined as follows:
</p>
<div class="example">
<pre class="example">my_printable_T
my_printable_new (ccstructs_core_t const * S,
                  ccname_trait_table_type(my_printable_T) const * M)
{
  my_printable_T        I = {
    .methods    = M,
    .self       = S
  };
  return I;
}

ccstructs_core_t const *
my_printable_self (my_printable_T I)
{
  return I.self;
}

void
my_printable_print_rec (my_printable_T I, FILE * stream)
{
  I.methods-&gt;print_rec(I, stream);
}

void
my_printable_print_pol (my_printable_T I, FILE * stream)
{
  I.methods-&gt;print_pol(I, stream);
}
</pre></div>

<p>The implementation of <code>my_printable_T</code> for the data <code>struct</code> <code>my_coords_t</code> is
defined as follows:
</p>
<div class="example">
<pre class="example">static void
ccname_trait_method(my_printable_T, my_coords_t, print_rec) (my_printable_T I, FILE * stream)
{
  CCSTRUCTS_PC(my_coords_t, S, my_printable_self(I));

  fprintf(stream, &quot;X=%f, Y=%f\n&quot;, S-&gt;X, S-&gt;Y);
}

static void
ccname_trait_method(my_printable_T, my_coords_t, print_pol) (my_printable_T I, FILE * stream)
{
  CCSTRUCTS_PC(my_coords_t, S, my_printable_self(I));
  double        RHO   = hypot(S-&gt;X, S-&gt;Y);
  double        THETA = atan2(S-&gt;Y, S-&gt;X);

  fprintf(stream, &quot;RHO=%f, THETA=%f\n&quot;, RHO, THETA);
}

static ccname_trait_table_type(my_printable_T) const ccname_trait_table(my_printable_T, my_coords_t) = {
  .print_rec    = ccname_trait_method(my_printable_T, my_coords_t, print_rec),
  .print_pol    = ccname_trait_method(my_printable_T, my_coords_t, print_pol)
};

my_printable_T
ccname_trait_new(my_printable_T, my_coords_t) (my_coords_t * S)
{
  return my_printable_new(ccstructs_core(S), &amp;ccname_trait_table(my_printable_T, my_coords_t));
}
</pre></div>

<p>We can use the trait as follows:
</p>
<div class="example">
<pre class="example">int
main (void)
{
  cce_location_t        L[1];
  my_coords_t *         S;
  my_printable_T        I;

  if (cce_location(L)) {
    cce_run_catch_handlers_final(L);
  } else {
    S = ccname_new(my_coords_t, rec)(L, 1.0, 2.0);
    I = ccname_trait_new(my_printable_T, my_coords_t)(S);

    my_printable_print_rec(I, stdout);
    my_printable_print_pol(I, stdout);
    ccname_delete(my_coords_t)(S);
  }
  exit(EXIT_SUCCESS);
}
</pre></div>


<hr>
<div class="header">
<p>
Previous: <a href="ccnames-struct-table.html" accesskey="p" rel="prev">ccnames struct table</a>, Up: <a href="ccnames.html" accesskey="u" rel="up">ccnames</a> &nbsp; [<a href="type-index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html" title="Index" rel="index">Index</a>]</p>
</div>


<p>This document describes version <tt>0.3.0-devel.3</tt> of <em>CCStructs</em>.</p>
</body>
</html>
