<html lang="en">
<head>
<title>2016 April 26 - Marco's Weblog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Marco's Weblog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="2016.html#g_t2016" title="2016">
<link rel="next" href="2016-April-21.html#g_t2016-April-21" title="2016 April 21">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2015, 2016 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="weblog.css">
</head>
<body>
<div class="node">
<a name="g_t2016-April-26"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="2016-April-21.html#g_t2016-April-21">2016 April 21</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="2016.html#g_t2016">2016</a>
<hr>
</div>

<h3 class="unnumberedsec">Enumerations, labels</h3>

<div align="center">Posted on April 26, 2016</div>

   <p>More work in the &lsquo;<samp><span class="samp">typed-language</span></samp>&rsquo;
<a href="https://github.com/marcomaggi/vicare/tree/typed-language.marcomaggi-2015-11-18">branch</a> of <a href="References.html#References">Vicare</a>, for both the expander and the built&ndash;in types
infrastructure.

   <p>Everything I discuss here is relative to code in the head of the
&lsquo;<samp><span class="samp">typed-language</span></samp>&rsquo; branch.  In this post I will take great pleasure in just
copying and pasting chunks of text from the documentation's Texinfo source files
(life is hard, but sometimes less so).

<!--  -->
<h4 class="unnumberedsubsec">Enumerations</h4>

<p>Vicare already had the <code>&lt;symbol&gt;</code> type for symbol objects.  It now also
supports the type annotation:

<pre class="lisp">     (enumeration <var>?symbol0</var> <var>?symbol</var> ...)
</pre>
   <p class="noindent">enumerations are used to match a symbol in a specified enumeration set:

<pre class="lisp">     (is-a? 'ciao (enumeration hello ciao salut ohayo))
     &rArr; #t
     
     (is-a? 'blue (enumeration hello ciao salut ohayo))
     &rArr; #f
</pre>
   <p>Enumeration type annotations are considered sub&ndash;types of <code>&lt;symbol&gt;</code>.  We can
combine enumerations in type annotations to filter out some symbols:

<pre class="lisp">     (define-type &lt;my-symbols&gt;
       (and (enumeration red blue green yellow purple)
            (enumeration blue yellow magenta)))
     
     (is-a? 'blue &lt;my-symbols&gt;)      &rArr; #t
     (is-a? 'red  &lt;my-symbols&gt;)      &rArr; #f
</pre>
   <p>As special case, if we define an alias for an <code>enumeration</code> type
annotation: we can use such identifier to validate symbols.  Example:

<pre class="lisp">     (define-type greetings
       (enumeration hello ciao salut ohayo))
     
     (is-a? 'ciao greetings) &rArr; #t
     (greetings ciao)        &rArr; ciao
     (greetings blue)        error--&gt; symbol not in enumeration
</pre>
   <p>The enumeration identifier is indeed used in the implementation of the
<code>define-enumeration</code> built&ndash;in syntax:

<pre class="lisp">     (define-enumeration greetings
       (hello ciao salut ohayo)
       make-greetings)
     
     (is-a? 'ciao greetings) &rArr; #t
     (greetings ciao)        &rArr; ciao
     (greetings blue)        error--&gt; symbol not in enumeration
</pre>
   <!--  -->
<h4 class="unnumberedsubsec">Label types</h4>

<p>I needed to code something fun, so I implemented label types; these entities where
already (in a similar form) in the Nausicaa libraries.  Labels are types built on top
of other types: we put type labels on values of a parent type to handle them locally
in a special way.  There are two kinds of labels:

     <ul>
<li>Labels <strong>without</strong> custom type predicate.  They are synonyms of their parent
type and add methods to it.  A value matches the label type if it matches the parent
type.

     <li>Labels <strong>with</strong> custom type predicate.  A value matches the label type if it
satisfies the label's type predicate; it is possible to establish when a value
matches the label type only at run&ndash;time. 
</ul>

   <p>Label types are defined using the syntax <code>define-label</code>, exported by the
library <code>(vicare language-extensions labels)</code>; labels are implemented half in
the expander itself and half in this external library.  A <code>define-label</code> use
can contain any of the following clauses, much similar to
<code>define-record-type</code>:

<pre class="lisp">     parent
     type-predicate
     equality-predicate
     comparison-procedure
     hash-function
     method
     case-method
</pre>
   <p class="noindent">where <code>parent</code> is mandatory; the parent of a label type can be any type
annotation.

   <p>The following example defines a label <code>&lt;String&gt;</code> that is just a synonym for
<code>&lt;string&gt;</code>:

<pre class="lisp">     (define-label &lt;String&gt;
       (parent &lt;string&gt;))
     
     (define {O &lt;String&gt;}
       "ciao")
     
     (.length O)     &rArr; 4
     (.hash   O)     ==&gt; (string-hash O)
</pre>
   <p class="noindent">now let's define a custom hash function (we ignore the parent hash function that gets
passed as <var>parent-func</var> argument):

<pre class="lisp">     (define-label &lt;String&gt;
       (parent &lt;string&gt;)
       (hash-function
         (lambda (parent-func)
           (lambda (S)
             (if (string-empty? S)
                 0
               (char-hash (string-ref S 0)))))))
     
     (define {O &lt;String&gt;}
       "ciao")
     
     (.hash O)    == (char-hash #\c)
</pre>
   <p class="noindent">now let's define a method for appending prefixes and suffixes:

<pre class="lisp">     (define-label &lt;String&gt;
       (parent &lt;string&gt;)
       (case-method append
         (({_ &lt;String&gt;} {O &lt;String&gt;} {suff &lt;String&gt;})
          (string-append O suff))
         (({_ &lt;String&gt;} {O &lt;String&gt;} {pref &lt;String&gt;} {suff &lt;String&gt;})
          (string-append pref O suff))))
     
     (define {O &lt;String&gt;}
       "ciao")
     
     (.append O "-suff")             &rArr; "ciao-suff"
     (.append O "pref-" "-suff")     &rArr; "pref-ciao-suff"
     
     (.length (.append O "pref-" "-suff"))
     &rArr; 14
</pre>
   <p>Now let's define a label type to represent fixnums returned by
comparison procedures (&lsquo;<samp><span class="samp">-1</span></samp>&rsquo;, &lsquo;<samp><span class="samp">0</span></samp>&rsquo;, &lsquo;<samp><span class="samp">+1</span></samp>&rsquo;):

<pre class="lisp">     (define-label &lt;comparison-fixnum&gt;
       (parent (or &lt;non-negative-fixnum&gt; &lt;negative-fixnum&gt;))
       (type-predicate
         (lambda (parent-pred)
           (lambda (obj)
             (and (parent-pred obj)
                  (fx&lt;=? obj +1)
                  (fx&gt;=? obj -1))))))
     
     (is-a? +1 &lt;comparison-fixnum&gt;)  &rArr; #t
     (is-a? -1 &lt;comparison-fixnum&gt;)  &rArr; #t
     (is-a?  0 &lt;comparison-fixnum&gt;)  &rArr; #t
     
     (is-a? +2 &lt;comparison-fixnum&gt;)  &rArr; #f
     (is-a? -2 &lt;comparison-fixnum&gt;)  &rArr; #f
</pre>
   <!--  -->
<h4 class="unnumberedsubsec">On the sorry state of error messages</h4>

<p>I am well aware that, whenever a type error is found by the expander, the displayed
error message is hard to read by humans.  The message is just a dump of the contents
of a compound condition object:

<pre class="smalllisp">     vicare&gt; (display 1 2)
     Unhandled exception
      Condition components:
        1. &amp;who: chi-application
        2. &amp;message: "expand-time mismatch between closure object's arguments signatures and operands signature"
        3. &amp;expand-time-type-signature-warning
        4. &amp;syntax:
            form: #[syntax expr=(display 1 2)]
            subform: #[id display]
        5. &amp;application-operator-expression: #[id display]
        6. &amp;application-operands-expressions: #[syntax expr=(1 2)]
        7. &amp;arguments-signatures: (#[signature (&lt;top&gt;)]
       #[signature (&lt;top&gt; &lt;textual-output-port&gt;)])
        8. &amp;operands-signature: #[signature (&lt;positive-fixnum&gt; &lt;positive-fixnum&gt;)]
</pre>
   <p class="noindent">notice that this thing is for a very simple function; it gets much worse with
functions having many clauses with many arguments.

   <p>In one of the possible futures of the Universe: I will implement a special exception
handler in the expander, so that these condition objects are parsed and readable text
is printed.  It will not be easy because there is a lot of information to be
shown<small class="dots">...</small>

<!--  -->
<h4 class="unnumberedsubsec">The Vicare Manifesto</h4>

<p>No there is no such thing, yet.  I have read Racket's
<a href="http://www.ccs.neu.edu/home/matthias/manifesto/">one</a> and I have seen Professor
Felleisen explain it in a tech <a href="https://www.youtube.com/watch?v=JnczIyPXGfc">talk</a>: it is great that people can state their philosophy in driving a project.

   <p>Ahem<small class="dots">...</small> at present, the only thing I can say about Vicare is: if you like the
Scheme language and procedural macros, give it a try (it will have static typing,
too!).  Not much<small class="dots">...</small> huh?

<!-- page -->
   </body></html>

