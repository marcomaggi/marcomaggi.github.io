<html lang="en">
<head>
<title>2015 March 24 - Marco's Weblog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Marco's Weblog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="2015.html#g_t2015" title="2015">
<link rel="next" href="2015-March-20.html#g_t2015-March-20" title="2015 March 20">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2015 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="weblog.css">
</head>
<body>
<div class="node">
<a name="g_t2015-March-24"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="2015-March-20.html#g_t2015-March-20">2015 March 20</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="2015.html#g_t2015">2015</a>
<hr>
</div>

<h3 class="unnumberedsec">Musings on the tagged language (part 5) (2015 March 24)</h3>

<p>In this tagged language design for <a href="References.html#References">Vicare</a>: one day everything looks fine, the
next day everything looks wrong.  For sure I am having some ideas that would be hard
to implement efficiently and maybe quite weird to use.  In the last entry on the
tagged language (see <a href="2015-February-18.html#g_t2015-February-18">2015 February 18</a>) I left myself with the idea of
implementing function overloading, which means having the following expansions:

<pre class="lisp">     (length '(1 2))         ==&gt; (list-length       '(1 2))
     (length '#(1 2))        ==&gt; (vector-length     '#(1 2))
     (length '#vu8(1 2))     ==&gt; (bytevector-length '#vu8(1 2))
     (length "1 2")          ==&gt; (list-length       "1 2")
</pre>
   <p class="noindent">but function overloading should <strong>not</strong> interfere with macro expansion; the
code:

<pre class="lisp">     (import (vicare))
     (add-method length (&lt;string&gt;) string-length)
     (define (frob obj)
       ---)
     (let-syntax ((length (syntax-rules ()
                            ((_ ?expr)
                             (frob ?expr))
                            )))
       (length "ciao"))
</pre>
   <p class="noindent">should cause the following expansion to happen:

<pre class="lisp">     (length "ciao") ==&gt; (frob "ciao")
</pre>
   <p class="noindent">is this actually doable?

<!--  -->
<h4 class="unnumberedsubsec">When to search the table of methods</h4>

<p>Let's step back one moment.  The following works and is already implemented in
<code>(vicare)</code>:

<pre class="lisp">     ("ciao" length)         &rArr; 4
</pre>
   <p class="noindent">because first the expander determines the type of <code>"ciao"</code> to be <code>&lt;string&gt;</code>,
then it searches the name <code>length</code> in the table of methods in <code>&lt;string&gt;</code>.

   <p>What should happen in the following:

<pre class="lisp">     (length "ciao")         &rArr; 4
</pre>
   <p class="noindent">is not clear.  Should the expander first search for a binding named <code>length</code>
using normal bindings resolution, then visit the methods table only if no syntax with
such name exists in the lexical context?  And if no method named <code>length</code>
exists: should it go back in the lexical context to search for a non&ndash;syntax binding?

   <p>This going back and forth is inefficient and confusing.

   <p>By using a method call syntax:

<pre class="lisp">     (method-call length "ciao")
</pre>
   <p class="noindent">everything is solved because we are explicitly declaring that we want to visit the
table of methods.  So we can keep normal bindings resolution.

<!--  -->
<h4 class="unnumberedsubsec">Reconsidering dot quoting</h4>

<p>Let's say we change the reader to implement the following &ldquo;quoting with dot&rdquo;:

<pre class="lisp">     (.<var>?symbol</var> <var>?arg</var> ...) ==&gt; (method-call <var>?symbol</var> <var>?arg</var> ...)
</pre>
   <p class="noindent">using this syntax we could take the following function:

<pre class="lisp">     (define (list-of-strings? obj)
       (if (pair? obj)
           (and (string? (car obj))
                (list-of-strings? (cdr obj)))
         (null? obj)))
</pre>
   <p class="noindent">and rewrite it as follows to generalise it to other implementations of lists (for
example the immutable lists of <acronym>SRFI</acronym>-116):

<pre class="lisp">     (define (list-of-strings? obj)
       (if (.pair? obj)
           (and (string? (.car obj))
                (list-of-strings? (.cdr obj)))
         (.null? obj)))
</pre>
   <p class="noindent">does it look bad with all those dots?

   <p>What if the following sequence of transformations is implemented?

<pre class="lisp">     (.length "ciao")
     ==&gt; (method-call length "ciao")
     ==&gt; ("ciao" length)
</pre>
   <p class="noindent">we would have prefix notation and the same mechanism for querying the table of
methods already half&ndash;implemented in <code>(vicare)</code>.

<!--  -->
<h4 class="unnumberedsubsec">About interfaces</h4>

<p>I want Vicare to be a practical language, not only a beautiful language as is
Scheme; for this reason I have included some syntaxes to implement loops with C
language style (<code>while</code>, <code>until</code>, <code>do ... while</code>, <code>do ... 
until</code>): they look ugly in Scheme, but some people are used to them<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>.

   <p>Everybody outside the Lisp world likes interfaces: the gist of them is to give a name
to a collection of method signatures which an object type can declare to implement. 
With Lisp notation it should look something like this:

<pre class="lisp">     (define-interface &lt;shape&gt;
       (method (draw (obj &lt;shape&gt;))))
     
     (define-class &lt;circle&gt;
       (implements &lt;shape&gt;)
       (fields x-center y-center radius)
       (method (draw (O &lt;circle&gt;))
         (actually-draw O)))
</pre>
   <p class="noindent">and, at expand&ndash;time, it is verified that the class <code>&lt;circle&gt;</code> actually contains
definitions for the methods in <code>&lt;shape&gt;</code>.  This is possible if the method
definitions are inside the <code>define-class</code> form.

   <p>What if I implement overloaded functions with <acronym>CLOS</acronym>&ndash;like syntax?  They are not
declared inside the type syntax, so would it be possible to implement interfaces?

<!-- page -->
   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> They do
not look as ugly as <code>loop</code> in Common Lisp, but still uglier than looping with
recursion.  By the way: after having implemented a library providing Common Lisp
style restarts, I want <code>loop</code>, too, in a standalone library.  (There are so
many clauses!!!  I dunno when I will find the will to implement it<small class="dots">...</small>)</p>

   <hr></div>

   </body></html>

