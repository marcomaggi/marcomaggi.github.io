<html lang="en">
<head>
<title>2016 Jun 28 - Marco's Weblog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Marco's Weblog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="2016.html#g_t2016" title="2016">
<link rel="prev" href="2016-Jul-13.html#g_t2016-Jul-13" title="2016 Jul 13">
<link rel="next" href="2016-Jun-25.html#g_t2016-Jun-25" title="2016 Jun 25">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2015, 2016 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="weblog.css">
</head>
<body>
<div class="node">
<a name="g_t2016-Jun-28"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="2016-Jun-25.html#g_t2016-Jun-25">2016 Jun 25</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="2016-Jul-13.html#g_t2016-Jul-13">2016 Jul 13</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="2016.html#g_t2016">2016</a>
<hr>
</div>

<h3 class="unnumberedsec">Syntax <code>this</code> and interfaces</h3>

<div align="center">Posted on Tue Jun 28, 2016</div>

   <p>More work in the &lsquo;<samp><span class="samp">typed-language</span></samp>&rsquo;
<a href="https://github.com/marcomaggi/vicare/tree/typed-language.marcomaggi-2015-11-18">branch</a> of <a href="References.html#References">Vicare</a>, for both the expander and the built&ndash;in types
infrastructure.

   <p>Everything I discuss here is relative to code in the head of the
&lsquo;<samp><span class="samp">typed-language</span></samp>&rsquo; branch.

<!--  -->
<h4 class="unnumberedsubsec">Syntax <code>this</code></h4>

<p>Under many programming languages that support some form of object&ndash;oriented
programming, object&ndash;types have methods; in the definition of methods the first
argument is the type instance itself.  Usually such argument is implicit (like under
C++) and it can be accessed through the reserved keyword <code>this</code>.

   <p>Until recently, this was not the case under Vicare, where <code>method</code> clauses
in record&ndash;type definitions required us to explicitly write the first argument:

<pre class="lisp">     (define-record-type &lt;duo&gt;
       (fields one two)
       (method (add {O &lt;duo&gt;})
         (+ (.one O) (.two O))))
     
     (define O (new &lt;duo&gt; 1 2))
     (.add O)        &rArr; 3
</pre>
   <p>This is no more.  <code>(vicare)</code> now exports the fluid syntax <code>this</code>, which
is meant to be used to access the implicit first argument of methods.  So the code
above is now invalid and it must be written:

<pre class="lisp">     (define-record-type &lt;duo&gt;
       (fields one two)
       (method (add)
         (+ (.one this) (.two this))))
     
     (define O (new &lt;duo&gt; 1 2))
     (.add O)        &rArr; 3
</pre>
   <p class="noindent">where <code>this</code> references a read&ndash;only variable of type <code>&lt;duo&gt;</code>.

   <p>Everywhere the clauses <code>method</code>, <code>case-method</code> and
<code>method/overload</code> are used to define methods: the first argument is implicit
and the fluid syntax <code>this</code> is used in the body of methods to access it.

<!--  -->
<h4 class="unnumberedsubsec">Interfaces</h4>

<p>Interfaces are a mechanism to verify, at expand&ndash;time, that: instances of an
object&ndash;type can be used in a generic expression, because they implement all the
needed methods and such methods can be called at run&ndash;time through dynamic
dispatching.  The current implementation is to be considered experimental; some of
the internals are in the boot image and the rest is in the library <code>(vicare
language-extensions interfaces)</code>.

   <p>Let's consider this code:

<pre class="lisp">     (define-record-type &lt;a-vector&gt;
       (fields {vec &lt;nevector&gt;})
       (method ({first &lt;top&gt;})
         (vector-ref (.vec this) 0)))
     
     (define-record-type &lt;a-string&gt;
       (fields {vec &lt;nestring&gt;})
       (method ({first &lt;top&gt;})
         (string-ref (.vec this) 0)))
     
     (define-record-type &lt;a-list&gt;
       (fields {vec &lt;nelist&gt;})
       (method ({first &lt;top&gt;})
         (car (.vec this))))
     
     (define (fun O)
       (.first O))
     
     (fun (new &lt;a-vector&gt; '#(1 2 3)))        &rArr; 1
     (fun (new &lt;a-string&gt; "ABC"))            &rArr; #\A
     (fun (new &lt;a-list&gt; '(a b c)))           &rArr; a
</pre>
   <p class="noindent">everything works fine in the function <code>fun</code> because all of <code>&lt;a-vector&gt;</code>,
<code>&lt;a-string&gt;</code> and <code>&lt;a-list&gt;</code> implement the method &lsquo;<samp><span class="samp">first</span></samp>&rsquo;.  The code
<code>(.first O)</code> expands into a call to <code>method-call-late-binding</code>, which, at
run&ndash;time, finds the method implementation functions in the type descriptors of
<code>&lt;a-vector&gt;</code>, <code>&lt;a-string&gt;</code> and <code>&lt;a-list&gt;</code>.

   <p>Fine, but the code is not type&ndash;checked at expand&ndash;time.  Enter interfaces.  Let's
modify the code as follows:

<pre class="lisp">     (define-interface &lt;Sequence&gt;
       (method-prototype first
         (lambda () =&gt; (&lt;top&gt;))))
     
     (define-record-type &lt;a-vector&gt;
       (implements &lt;Sequence&gt;)
       (fields {vec &lt;nevector&gt;})
       (method ({first &lt;top&gt;})
         (vector-ref (.vec this) 0)))
     
     (define-record-type &lt;a-string&gt;
       (implements &lt;Sequence&gt;)
       (fields {vec &lt;nestring&gt;})
       (method ({first &lt;top&gt;})
         (string-ref (.vec this) 0)))
     
     (define-record-type &lt;a-list&gt;
       (implements &lt;Sequence&gt;)
       (fields {vec &lt;nelist&gt;})
       (method ({first &lt;top&gt;})
         (car (.vec this))))
     
     (define (fun {O &lt;Sequence&gt;})
       (.first O))
     
     (fun (new &lt;a-vector&gt; '#(1 2 3)))        &rArr; 1
     (fun (new &lt;a-string&gt; "ABC"))            &rArr; #\A
     (fun (new &lt;a-list&gt; '(a b c)))           &rArr; a
</pre>
   <p class="noindent">everything works almost as before, but the record&ndash;type definition clause
<code>(implements &lt;Sequence&gt;)</code> causes the expander to validate, at expand-time, that
the record&ndash;types actually implement a method <code>first</code> with the correct type
signature.

   <p>Also, the function application <code>(fun </code><var>?operand</var><code>)</code> is validated at
expand&ndash;time to verify that the type of <var>?operand</var> is an object&ndash;type that
implements <code>&lt;Sequence&gt;</code>.  Such validation can happen <strong>only</strong> if the
expander is able to determine the type of <var>?operand</var>; this validation cannot
happen at run&ndash;time, so, for example, it is impossible for label types to implement
interfaces.

   <p>Interfaces can implement methods, case&ndash;methods and overloaded methods of their own,
with the same syntax used for record&ndash;types.  Right now an interface type cannot
declare another interface as super&ndash;type; I will decide what to do in future.

<!-- page -->
   </body></html>

