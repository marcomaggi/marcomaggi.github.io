<html lang="en">
<head>
<title>2016 Sep 18 - Marco's Weblog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Marco's Weblog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="2016.html#g_t2016" title="2016">
<link rel="prev" href="2016-Oct-20.html#g_t2016-Oct-20" title="2016 Oct 20">
<link rel="next" href="2016-Sep-4.html#g_t2016-Sep-4" title="2016 Sep 4">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2015, 2016 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="weblog.css">
</head>
<body>
<div class="node">
<a name="g_t2016-Sep-18"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="2016-Sep-4.html#g_t2016-Sep-4">2016 Sep 4</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="2016-Oct-20.html#g_t2016-Oct-20">2016 Oct 20</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="2016.html#g_t2016">2016</a>
<hr>
</div>

<h3 class="unnumberedsec">Musings on record constructors and overall architecture</h3>

<div align="center">Posted on Sun Sep 18, 2016</div>

   <p>Work is going on in private branches of <a href="References.html#References">Vicare</a>.  Slowly.

   <p>Development of the typed language's <code>strict-type-checking</code> option is on its way:
it causes a warning to be raised whenever a typed variable is set to a value that is
only compatible rather than matching.  For example:

<pre class="lisp">     (define {O &lt;fixnum&gt;}
       (cast-signature (&lt;integer&gt;) 123))
</pre>
   <p class="noindent">will raise a warning when <code>strict-type-checking</code> is enabled, because
<code>&lt;integer&gt;</code> is only compatible with <code>&lt;fixnum&gt;</code> and will cause further
validation at run&ndash;time.

<!--  -->
<h4 class="unnumberedsubsec">On record constructors</h4>

<p>I am unhappy with the state of the record constructors.  The <acronym>R6RS</acronym> constructors
infrastructure works like this:

<pre class="lisp">     (define-record-type &lt;duo&gt;
       (fields one two)
       (protocol
         (lambda (make-record)
           make-record)))
     
     (define-record-type &lt;trio&gt;
       (parent &lt;duo&gt;)
       (fields three)
       (protocol
         (lambda (make-duo)
           (lambda (x y z)
             ((make-duo x y) z)))))
     
     (make-&lt;trio&gt; 1 2 3)     &rArr; #[&lt;trio&gt; one=1 two=2 three=3]
</pre>
   <p class="noindent">we specify a <code>protocol</code> clause that builds and returns a closure object used
as record constructor.  I like it: I find it very flexible and very <em>Schemey</em>.

   <p>It also has a significant <em>impedance mismatch</em> with the way records are built
using the typed language's extensions: it has no way to provide a type signature for
the constructor and overloaded constructors are possible but only with run&ndash;time
dispatching.  With the code as it is now, we can do this:

<pre class="lisp">     (define-record-type &lt;duo&gt;
       (fields one two)
       (protocol
         (lambda (make-record)
           (define/overload ({make-duo &lt;duo&gt;} {x &lt;real&gt;} {y &lt;real&gt;})
             (make-record x y))
           (define/overload ({make-duo &lt;duo&gt;} {z &lt;complex&gt;})
             (make-record (real-part z) (imag-part z)))
           make-duo))
       (constructor-signature
         (case-lambda
           ((&lt;real&gt; &lt;real&gt;)        =&gt; (&lt;duo&gt;))
           ((&lt;complex&gt;)            =&gt; (&lt;duo&gt;))))
     
     (new &lt;duo&gt; 1 2)         &rArr; #[&lt;duo&gt; one=1 two=2]
     (new &lt;duo&gt; 1+2i)        &rArr; #[&lt;duo&gt; one=1 two=2]
</pre>
   <p class="noindent">but it is not optimal: in this code there is everything needed to select the
specialised constructor at expand&ndash;time, but the selection happens at run&ndash;time.

   <p>A possible solution: introduce &ldquo;named protocols&rdquo;; have <code>new</code> call a
constructor other than the one defined by <code>protocol</code>.  Something like this:

<pre class="lisp">     (define-record-type &lt;duo&gt;
       (fields one two)
       (protocol
         (lambda (make-record)
           make-record))
       (named-protocol make-duo-from-complex
         (lambda (make-record)
           (lambda (z)
             (make-record (real-part z) (imag-part z)))))
       (constructor ({x &lt;real&gt;} {y &lt;real&gt;})
         (make-&lt;duo&gt; x y))
       (constructor ({z &lt;complex&gt;})
         (make-duo-from-complex z)))
</pre>
   <p class="noindent">it works like this:

     <ul>
<li>We can use multiple <code>constructor</code> clauses and multiple <code>named-protocol</code>
clauses, in addition to the standard <code>protocol</code> clause.

     <li>Every <code>named-protocol</code> clause defines a record&ndash;constructor descriptor whose
constructor is bound to a specified name.  The default <code>protocol</code> clause is
just like a <code>named-protocol</code> clause whose constructor is bound to the
preselected syntactic identifier <code>make-&lt;duo&gt;</code>.

     <li>Every <code>constructor</code> clause defines a specialisation for an overloaded
function; the overloaded function name is <code>new-&lt;duo&gt;</code>.  The body of the
specialisation can use any of the constructors defined by <code>protocol</code> and
<code>named-protocol</code>.

     <li>Whenever a <code>constructor</code> clause is used in the body of a
<code>define-record-type</code> use: the syntax <code>new</code> expands into a call to
<code>new-&lt;duo&gt;</code>, rather than into a call to <code>make-&lt;duo&gt;</code>. 
</ul>

   <p>The <code>constructor</code> clauses expand into the overloaded function:

<pre class="lisp">     (define/overload ({new-&lt;duo&gt; &lt;duo&gt;} {x &lt;real&gt;} {y &lt;real&gt;})
       (make-&lt;duo&gt; x y))
     
     (define/overload ({new-&lt;duo&gt; &lt;duo&gt;} {z &lt;complex&gt;})
       (make-duo-from-complex z))
</pre>
   <p>Obviously we can define the <code>constructor</code> clauses to use the default
constructor:

<pre class="lisp">     (define-record-type &lt;duo&gt;
       (fields one two)
       (protocol
         (lambda (make-record)
           make-record))
       (constructor ({x &lt;real&gt;} {y &lt;real&gt;})
         (make-&lt;duo&gt; x y))
       (constructor ({z &lt;complex&gt;})
         (make-&lt;duo&gt; (real-part z) (imag-part z))))
</pre>
   <p>With this solution the clause <code>constructor-signature</code> would be removed.

<!--  -->
<h4 class="unnumberedsubsec">Overall architecture</h4>

<p>At some point, in one of the possible futures, I would like to split the expander and
compiler from the boot image; this means <code>(rnrs eval (6))</code>, <code>(vicare
expander)</code>, <code>(vicare compiler)</code> become external libraries.  Not an easy thing to
do.

   <p>Right now there is a single executable program installed with Vicare, but with
this change there would be more of them:

     <dl>
<dt><samp><span class="command">vicare-repl</span></samp><dd>A precompiled Scheme program that runs the <acronym>REPL</acronym>.  It would load an external
library <code>(vicare cafe)</code>, which is now an internal set of features.

     <br><dt><samp><span class="command">vicare-compiler</span></samp><dd>A Scheme program that implements the compiler.

     <br><dt><samp><span class="command">vicare</span></samp><dd>The run&ndash;time we have now.  It would become a program that runs precompiled Scheme
programs. 
</dl>

   <p>Things should change internally.

   <p>For example the record&ndash;type describing compiled libraries should be restructured. 
To be able to run compiled programs that load compiled libraries without loading the
expander: a library's invoke code must be loaded without loading the visit code
(which needs the expander library).  This could mean that the invoke code is split
from <code>.fasl</code> files into its own file; it would make it possible to install a
package holding only precompiled programs and libraries, without including the
development stuff.  Cool.

   <p>The boot process would be greatly revolutionised.  In addition to shipping
precompiled boot images, the package would include precompiled compiler and expander
libraries under the <samp><span class="file">boot</span></samp> directory.  A lot of processing that is now performed
in the build script <samp><span class="file">makefile.sps</span></samp> should be restructured.

   <p>I will think of this.  I want to start by putting the <acronym>REPL</acronym> into an external
program; it will also be a test for compiled programs that is now absent from the
package.

<!-- page -->
   </body></html>

