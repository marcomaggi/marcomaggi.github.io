<html lang="en">
<head>
<title>2015 September 12 - Marco's Weblog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Marco's Weblog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="2015.html#g_t2015" title="2015">
<link rel="next" href="2015-September-10.html#g_t2015-September-10" title="2015 September 10">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2015 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="weblog.css">
</head>
<body>
<div class="node">
<a name="g_t2015-September-12"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="2015-September-10.html#g_t2015-September-10">2015 September 10</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="2015.html#g_t2015">2015</a>
<hr>
</div>

<h3 class="unnumberedsec">Record methods and dot notation</h3>

<div align="center">Posted on September 12, 2015</div>

   <p>More <a href="References.html#References">Vicare</a>'s expander development for the internal representation of <acronym>R6RS</acronym>
record types (see <a href="2015-September-10.html#g_t2015-September-10">On records</a>).  All the changes discussed here
are in the <a href="References.html#References">master</a> branch.

<!--  -->
<h4 class="unnumberedsubsec">Methods for records</h4>

<p>As experimental (and still undocumented) feature, I have started support for methods
in the definitions of <acronym>R6RS</acronym> record types.  Three new keyword syntactic bindings
are now exported by the library <code>(vicare)</code>: <code>method</code>,
<code>case-method</code> and <code>method-call</code>.

   <p>The clause <code>method</code> can be put multiple times in the body of a
<code>define-record-type</code> use, to define a method for the record&ndash;type:

<pre class="lisp">     (define-record-type duo
       (fields one two)
       (method (sum-them self)
         (+ (duo-one self)
            (duo-two self)))
       (method (mul-them self)
         (* (duo-one self)
            (duo-two self)))
       (method (display self port)
         (display self port)))
</pre>
   <p class="noindent">we can think of <code>method</code> as acting like <code>define</code> with regard to the
syntax of arguments to function; the first argument to a method is the record itself. 
The syntax <code>method-call</code> is then used to call a record's methods:

<pre class="lisp">     (define {O duo}
       (make-duo 3 4))
     
     (method-call sum-them O)        &rArr; 7
     (method-call mul-them O)        &rArr; 12
     
     (method-call display O (current-error-port))
     (newline (current-error-port))  -| #[record duo one=3 two=4]
</pre>
   <p>The clause <code>case-method</code> is similar, we can think of it as acting like
<code>case-define</code>:

<pre class="lisp">     (define-record-type alpha
       (fields a)
       (case-method on-a
         ((self)
          (alpha-a self))
         ((self new-val)
          (alpha-a-set! self new-val))))
     
     (define {O alpha}
       (make-alpha 1))
     
     (method-call on-a O)            &rArr; 1
     (method-call on-a O 2)
     (method-call on-a O)            &rArr; 2
</pre>
   <p>The syntax <code>method-call</code> searches for a record&ndash;type's methods by comparing
the symbols with <code>eq?</code> (<strong>not</strong> the syntactic identifiers with
<code>free-identifier=?</code>).

   <p>If a method with the given name is not found: the syntax searches for a field with
the given name, but only if the number of arguments is right.  The syntax of
<code>method-call</code> is:

<pre class="example">     (method-call <var>?name</var> <var>?subject-expr</var> <var>?arg</var> ...)
</pre>
     <ul>
<li>If there are <strong>no</strong> arguments <var>?arg</var>, then a field with name <var>?name</var> is
searched and, if found, the form is expanded to an application of the field's
accessor:

     <pre class="example">          (<var>?accessor</var> <var>?subject-expr</var>)
</pre>
     <li>If there is <strong>only one</strong> argument <var>?arg</var>, then a field with name <var>?name</var>
is searched and, if found, the form is expanded to an application of the field's
mutator:

     <pre class="example">          (<var>?mutator</var> <var>?subject-expr</var> <var>?arg</var>)
</pre>
     </ul>

   <p>The clauses <code>method</code> and <code>case-method</code> are accepted by
<code>define-record-type</code> only when the language is non&ndash;strict <acronym>R6RS</acronym>.  The
syntax <code>method-call</code> is able to retrieve the type of its second argument only
when the tagged language is enabled (at present, only with a few expressions given
that the tagged language is only half&ndash;written).

<!--  -->
<h4 class="unnumberedsubsec">Dot notation</h4>

<p>Some time ago I reconsidered dot notation to call a type's methods (see <a href="2015-March-24.html#g_t2015-March-24">Reconsidering dot quoting</a>).  I do not know the language Clojure, but I read
stuff through Reddit; recently a post made me skim through the syntax table of this
language and I found that they use the dot notation I have in mind to call Java
methods (see <a href="http://clojure.org/java_interop">Clojure &mdash; java_interop</a><a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>): I am not completely crazy!

   <p>Encouraged by this, I have implemented the reader syntax transformation:

<pre class="example">     (.<var>?symbol</var> <var>?arg</var> ...) ==&gt; (method-call <var>?symbol</var> <var>?arg</var> ...)
</pre>
   <p class="noindent">that is, when the reader's textual input port is configured in &lsquo;<samp><span class="samp">#!vicare</span></samp>&rsquo; mode:
if a list starts with a symbol; the name of the symbol is a string of length at least
2; the first character of the string is a dot; the second character of the
string is <strong>not</strong> a dot, then a <code>method-call</code> symbol is inserted and the
symbol stripped of the dot.

   <p>We can try it at the <acronym>REPL</acronym>:

<pre class="example">     vicare&gt; '(.ciao)
     $1 = (method-call ciao)
</pre>
   <p>Notice that <acronym>R6RS</acronym> forbids symbols starting with a dot, with the exception of the
ellipsis; so everything that was possible before, with the reader, is still possible
now.

   <p>So we can use this syntax to call a record's methods as in the following program:

<pre class="lisp">     #!vicare
     (program (demo)
       (options tagged-language)
       (import (vicare))
     
       (define-record-type duo
         (fields one two)
         (method (sum-them O)
           (+ (duo-one O)
              (duo-two O)))
         (method (mul-them O)
           (* (duo-one O)
              (duo-two O)))
         (method (display O port)
           (display O port)))
     
       (define {O duo}
         (make-duo 3 4))
     
       (pretty-print (.sum-them O)
                     (current-error-port))
     
       (pretty-print (.mul-them O)
                     (current-error-port))
     
       (.display O (current-error-port))
       (newline (current-error-port))
     
       #| end of program |# )
</pre>
   <p class="noindent">which compiled and run will print:

<pre class="example">     $ vicare --compile-program demo.sps --output demo
     $ vicare --binary-program ./demo
     7
     12
     #[record duo one=3 two=4]
</pre>
   <p>This dot notation still looks weird to my eyes, will I get used to it?

   <p>This feature of the reader is still undocumented: it is experimental.

<!-- page -->
   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> By the way: Clojure has some very weird syntax, weirder than
the ones I have imagined!</p>

   <hr></div>

   </body></html>

