<html lang="en">
<head>
<title>2015 September 10 - Marco's Weblog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Marco's Weblog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="2015.html#g_t2015" title="2015">
<link rel="next" href="2015-September-08.html#g_t2015-September-08" title="2015 September 08">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2015 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="weblog.css">
</head>
<body>
<div class="node">
<a name="g_t2015-September-10"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="2015-September-08.html#g_t2015-September-08">2015 September 08</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="2015.html#g_t2015">2015</a>
<hr>
</div>

<h3 class="unnumberedsec">On records</h3>

<div align="center">Posted on September 10, 2015</div>

   <p>I am reviewing some code in <a href="References.html#References">Vicare</a>'s expander to clean up the internal
representation of <acronym>R6RS</acronym> record types and related syntaxes (<code>is-a?</code>,
<code>slot-ref</code>, <code>slot-set!</code>, <small class="dots">...</small>).  All the changes discussed here are
in the <a href="References.html#References">master</a> branch.

<!--  -->
<h4 class="unnumberedsubsec">Record&ndash;type name's syntactic binding's descriptor</h4>

<p>Whenever we use the syntax <code>define-record-type</code>, a new syntactic binding is
created using the record&ndash;type name as name of the syntactic identifier; its
descriptor is a pair with format:

<pre class="example">     ($record-type-name . <var>?value</var>)
</pre>
   <p class="noindent">where the symbol <code>$record-type-name</code> is the &ldquo;type&rdquo; of the descriptor and
<var>?value</var> is its &ldquo;value&rdquo;.

   <p>Up until now, the <var>?value</var> in the descriptor has been a list with the first two
items being: the syntactic identifier bound to the record&ndash;type descriptor (<acronym>RTD</acronym>),
the syntactic identifier bound to the default record&ndash;constructor descriptor
(<acronym>RCD</acronym>); optionally another item can be present in the list, a record carrying
further informations about the record&ndash;type.

   <p>I changed this and now the <var>?value</var> is itself a record of type
<code>&lt;r6rs-record-type-spec&gt;</code>; this way the syntactic binding descriptor can carry
informations in a more ordered fashion.  This should open the door to a better
handling of types in the expander.

<!--  -->
<h4 class="unnumberedsubsec">Syntactic interface to setting record destructors</h4>

<p>I have added the clause <code>destructor-protocol</code> to the body of
<code>define-record-type</code>; <code>destructor-protocol</code> is a new syntactic binding
exported by the library <code>(vicare)</code>.  The syntax <code>define-record-type</code>
accepts this clause only when the selected language is non&ndash;strict <acronym>R6RS</acronym>.

   <p>The definition clause:

<pre class="lisp">     (destructor-protocol <var>?expr</var>)
</pre>
   <p class="noindent">allows the specification of an expression <var>?expr</var> which must evaluate to the
destructor protocol function; this function is used as explained below to construct a
destructor function to be called:

     <ul>
<li>Implicitly by the garbage collector when a record of this type is collected.

     <li>Explicitly with the <code>delete</code> syntax. 
</ul>

   <p>It is possible for a destructor function to be applied multiple times to the same
record: once a destructor is set in the descriptor, it can be explicitly applied to
records and later applied again by the garbage collector.  Destructor functions must
be written in such a way that multiple applications are not a problem.  For example,
it is usually possible, upon destruction, to reset some record fields to the void
object: when the destructor detects a field set to void, it knows that the record has
already been finalised.

   <p>Here is how the destructor function is built:

     <ul>
<li>If this type has a <code>destructor-protocol</code> clause and no parent: <var>?expr</var>
must evaluate to a closure object accepting no arguments and returning a closure
object acting as destructor function for records of this type.  For example:

     <pre class="lisp">          (define-record-type &lt;port&gt;
            (fields port)
            (destructor-protocol
              (lambda ()
                (lambda (record)
                  (close-port (&lt;port&gt;-port record))))))
</pre>
     <li>If this type has a <code>destructor-protocol</code> clause and a parent specified with
the <code>parent</code> or <code>parent-rtd</code> clauses: <var>?expr</var> must evaluate to a
closure object accepting as single argument the parent's destructor function and
returning as single value a closure object acting as destructor function for records
of this type.  For example:

     <pre class="lisp">          (define-record-type &lt;port&gt;
            (fields port)
            (destructor-protocol
              (lambda ()
                (lambda (record)
                  (close-port (&lt;port&gt;-port record))))))
          
          (define-record-type &lt;file&gt;
            (parent &lt;port&gt;)
            (fields filename)
            (destructor-protocol
              (lambda (destroy-&lt;port&gt;)
                (lambda (record)
                  (destroy-&lt;port&gt; record)))))
</pre>
     <p class="noindent">notice that the destructor of &lsquo;<samp><span class="samp">&lt;file&gt;</span></samp>&rsquo; is meant to call the destructor of its
supertype &lsquo;<samp><span class="samp">&lt;port&gt;</span></samp>&rsquo; at some point; however calling the supertype's destructor is
optional.

     <li>If this type has no <code>destructor-protocol</code> clause, it has a parent and the
parent has a destructor function: the parent's destructor function becomes this
type's destructor function. 
</ul>

<!--  -->
<h4 class="unnumberedsubsec">Structs, record, Nausicaa's classes, built&ndash;in object types, <small class="dots">...</small></h4>

<p>How many &ldquo;record&rdquo; objects are there in Vicare?

     <dl>
<dt><strong>Vicare's structs</strong><dd>Lightweight records providing: basic type disjunction (all the other records are in
truth structs), simple &ldquo;fields initialising&rdquo; constructors, access to named slots,
no inheritance, custom object printers, instance destructors.

     <br><dt><strong><acronym>R6RS</acronym> records</strong><dd>Heavyweight records providing: type disjunction, access to named slots, simple
inheritance, multiple construction protocols, custom object printers (as extension to
<acronym>R6RS</acronym>), instance destructors (as extension to <acronym>R6RS</acronym>).

     <br><dt><strong>Nausicaa's classes</strong><dd>Heavyweight records implemented by the library <code>(nausicaa)</code> providing: type
disjunction, access to named slots, simple inheritance, multiple construction
protocols, custom object printers, instance destructors, class methods, support for
mixins, abstract types (class types whose public constructor raises an exception). 
</dl>

   <p>In addition to these both the tagged language half&ndash;written in the library
<code>(vicare)</code> and the Nausicaa language implemented by the library
<code>(nausicaa)</code> implement object types representing the &ldquo;object&ndash;oriented&rdquo;
specification of built&ndash;in Scheme objects like fixnums, vectors, and others.

   <p>Are there too many of these?  I am tempted to reorganise everything and:

     <ul>
<li>Keep structs hidden in the internals of Vicare; maybe exposed by a separate
library like <code>(vicare structs)</code>, rather than by <code>(vicare)</code>.

     <li>Use records defined by <code>define-record-type</code> as the only public record
facility.

     <li>Remove Nausicaa's <code>define-class</code> and integrate all its features in
<code>define-record-type</code>.

     <li>Unify the interface of records with the type of built&ndash;in Scheme objects. 
</ul>

   <p>That would be a major backwards&ndash;incompatible change.  I will have to think more
about this<small class="dots">...</small> in the meantime I will continue developing
<code>define-record-type</code> trying to understand how much it can be extended without
making the expander a huge mess.

<!-- page -->
   </body></html>

