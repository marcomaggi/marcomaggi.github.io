<html lang="en">
<head>
<title>2015 February 13 bis - Marco's Weblog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Marco's Weblog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="2015.html#g_t2015" title="2015">
<link rel="prev" href="2015-February-14.html#g_t2015-February-14" title="2015 February 14">
<link rel="next" href="2015-February-13.html#g_t2015-February-13" title="2015 February 13">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2015 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="weblog.css">
</head>
<body>
<div class="node">
<a name="g_t2015-February-13-bis"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="2015-February-13.html#g_t2015-February-13">2015 February 13</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="2015-February-14.html#g_t2015-February-14">2015 February 14</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="2015.html#g_t2015">2015</a>
<hr>
</div>

<h3 class="unnumberedsec">Musings on the tagged language (part 1)</h3>

<p>At
<a href="https://github.com/marcomaggi/vicare/commit/68cac65a460b8f419f724721b94a6b85a0f5eac6">present</a>, <a href="References.html#References">Vicare</a>'s <code>master</code> branch implements the embryo of a language with
type annotations; it is called <em>tagged language</em> because calling it <em>typed
language</em> seems presumptuous at this stage.

   <p>We can have the following <acronym>REPL</acronym> session:

<pre class="example">     vicare&gt; (enable-tagged-language)
     vicare&gt; (import (vicare expander tags))
     vicare&gt; (define-struct alpha ({a &lt;string&gt;} {b &lt;number&gt;} {c &lt;pair&gt;}))
     vicare&gt; (define-struct beta ({d alpha}))
     vicare&gt; (define {O beta} (make-beta (make-alpha "ciao" 123 '(1 . 2))))
     vicare&gt; O
     $1 = #[struct type=beta]
     vicare&gt; (O d)
     $1 = #[struct type=alpha]
     vicare&gt; ((O d) a)
     $1 = "ciao"
     vicare&gt; (((O d) a) length)
     $1 = 4
     vicare&gt; (((O d) c) car)
     $1 = 1
     vicare&gt; (((O d) c) cdr)
     $1 = 2
     vicare&gt; ("hello" length)
     $1 = 5
     vicare&gt;(set! O 99)
     Unhandled exception
      Condition components:
        1. &amp;who: tag-assert-and-return
        2. &amp;message: "expand-time return values signature mismatch"
        3. &amp;expand-time-retvals-signature-violation:
            expected-signature: #["retvals-signature" (#&lt;syntax expr=beta mark*=(top)&gt;)]
            returned-signature: #["retvals-signature" (#&lt;syntax expr=&lt;fixnum&gt; mark*=(top)&gt;)]
        4. &amp;syntax:
            form: (#&lt;syntax expr=tag-assert-and-return mark*=(top)&gt;
       (#&lt;syntax expr=beta mark*=(top)&gt;)
       #&lt;syntax expr=99 mark*=(top)&gt;)
            subform: #&lt;syntax expr=99 mark*=(top)&gt;
     vicare&gt;
</pre>
   <p>The syntax:

<pre class="example">     (<var>?object-reference</var> <var>?field-name</var>)
     (<var>?object-reference</var> <var>?method-name</var>)
</pre>
   <p class="noindent">resembles the dot&ndash;notation that traditionally allows to access fields and call
class&ndash;specific methods in object&ndash;oriented languages; for this reason I say the
tagged language implements <em>object&ndash;oriented perfumed programming</em>.

   <p>This syntax does not adhere to the Lisp style.  The form:

<pre class="example">     ("hello" length)
</pre>
   <p class="noindent">especially violates the
<a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-12.html#node_sec_9.1">primitive syntax</a> as defined by <acronym>R6RS</acronym>, because the first subform is a constant rather than
an identifier or a subexpression evaluating to a procedure.  Should a string be an
<em>applicable</em> object?

   <p>A more Lispy style would be:

<pre class="example">     (<var>?field-name</var> <var>?object-reference</var>)
     (<var>?method-name</var> <var>?object-reference</var>)
</pre>
   <p class="noindent">which is actually what we have when using multimethods as defined by Common Lisp's
<acronym>CLOS</acronym> and all the Scheme extensions inspired by <acronym>CLOS</acronym>.

   <p>The Lispy style is problematic in Scheme because, as mandated by <acronym>R6RS</acronym>: all the
identifiers bound to field accessors and method procedures must be exported by
imported libraries.  This means that (if we write by hand <code>library</code> forms,
which is usually the case), we have to write all the names of fields and methods in
the <code>export</code> list; there can be many of them.

   <p>The non&ndash;Lispy syntax solves this problem by having the expander consider the string
in <code>("hello" length)</code> an object of type <code>&lt;string&gt;</code> and searching for a
method or field named &lsquo;<samp><span class="samp">length</span></samp>&rsquo; in the definition of the built&ndash;in class
<code>&lt;string&gt;</code>; with this mechanism, if we import the class identifier alone, we
automatically have access to all its methods and fields.  But it is not Lispy.

   <p>I like <acronym>CLOS</acronym>'s multimethods.  Ideally I would implement the tagged language on top
of expand&ndash;time multimethods whose definition is separated from the class definitions
of the arguments; there would be some true freedom with this.  The syntax of method
calls would be:

<pre class="example">     (length "hello")
</pre>
   <p class="noindent">which is truly Lispy.  In my ideal world, there would be no need to explicitly export
and import the identifier <code>length</code>; this is not simple to achieve in a sound
manner.

<!-- page -->
   </body></html>

