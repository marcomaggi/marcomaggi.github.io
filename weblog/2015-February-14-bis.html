<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Copyright (C) 2015, 2016 by Marco Maggi marco.maggi-ipsu@poste.it

Permission is granted to copy, distribute and/or modify this document under the terms
of the GNU Free Documentation License, Version 1.3 or any later version published
by the Free Software Foundation; with Invariant Sections being "GNU Free
Documentation License" and "GNU General Public License", no Front-Cover Texts,
and no Back-Cover Texts.  A copy of the license is included in the section entitled
"GNU Free Documentation License". -->
<!-- Created by GNU Texinfo 6.3, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Marco&rsquo;s Weblog: 2015 February 14 bis</title>

<meta name="description" content="Marco&rsquo;s Weblog: 2015 February 14 bis">
<meta name="keywords" content="Marco&rsquo;s Weblog: 2015 February 14 bis">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link href="index.html#Top" rel="start" title="Top">
<link href="concept-index.html#concept-index" rel="index" title="concept index">
<link href="concept-index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="2015.html#g_t2015" rel="up" title="2015">
<link href="2015-February-14.html#g_t2015-February-14" rel="next" title="2015 February 14">
<link href="2015-February-15.html#g_t2015-February-15" rel="prev" title="2015 February 15">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="weblog.css">


</head>

<body lang="en">
<a name="g_t2015-February-14-bis"></a>
<div class="header">
<p>
Next: <a href="2015-February-14.html#g_t2015-February-14" accesskey="n" rel="next">2015 February 14</a>, Previous: <a href="2015-February-15.html#g_t2015-February-15" accesskey="p" rel="prev">2015 February 15</a>, Up: <a href="2015.html#g_t2015" accesskey="u" rel="up">2015</a> &nbsp; [<a href="concept-index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Musings-on-the-tagged-language-_0028part-2_0029-_00282015-February-14-bis_0029"></a>
<h3 class="unnumberedsec">Musings on the tagged language (part 2) (2015 February 14 bis)</h3>


<p>In a previous entry (see <a href="2015-February-13-bis.html#g_t2015-February-13-bis">2015 February 13 bis</a>) I discussed the problem of having
type methods and field accessors with Lispy syntax in the tagged language; in
particular the need to have all the methods available by importing only the
identifier of the type, rather than all the identifiers of methods and field
accessors.
</p>
<a name="The-current-situation"></a>
<h4 class="unnumberedsubsec">The current situation</h4>

<p>In the expression:
</p>
<div class="example">
<pre class="example">(&quot;ciao&quot; length)
</pre></div>

<p>the literal expression <code>&quot;ciao&quot;</code> is considered of type <code>&lt;string&gt;</code> and the
symbol <code>length</code>, that comes <strong>after</strong> it, is searched in the list of
methods and field accessors of <code>&lt;string&gt;</code>.  What matters is the symbol
<code>length</code> whose name is the string <code>&quot;length&quot;</code>; it does not matter if
<code>length</code> is an identifier that is bound in the lexical context of the
expression.
</p>
<p>This is not a Lisp&ndash;style solution.
</p>

<a name="A-possible_002c-more-Lispy_002c-solution"></a>
<h4 class="unnumberedsubsec">A possible, more Lispy, solution</h4>

<p>In the expression:
</p>
<div class="example">
<pre class="example">(length &quot;ciao&quot;)
</pre></div>

<p>the literal expression <code>&quot;ciao&quot;</code> is considered of type <code>&lt;string&gt;</code> and the
symbol <code>length</code>, that comes <strong>before</strong> it, is searched in the list of
multimethods whose first argument is of type <code>&lt;string&gt;</code>.  Again, what matters is
the symbol <code>length</code> whose name is the string <code>&quot;length&quot;</code>; it does not matter
if <code>length</code> is an identifier that is bound in the lexical context of the
expression.
</p>
<p>What the expander should do in the following situation:
</p>
<div class="example">
<pre class="example">(import (vicare))

(length &quot;ciao&quot;)
</pre></div>

<p>is to first check if the class <code>&lt;string&gt;</code> contains a reference to a multimethod
named <code>length</code>:
</p>
<ul>
<li> If such method <strong>does</strong> exist: it means that its first argument is of type
<code>&lt;string&gt;</code>; the expander must check that the multimethod has one argument only,
in which case the implementation is used in the expression.

</li><li> If such method <strong>does not</strong> exist: the expander must try to resolve the
identifier <code>length</code> in the lexical context of the expression.  The result would
be to use the binding exported by <code>(vicare)</code>.
</li></ul>

<p>Assuming in future <code>(vicare)</code> implements an <code>add-method</code> syntax like
<code>(nausicaa)</code> does, in the following example:
</p>
<div class="example">
<pre class="example">(import (vicare))

(add-method length (&lt;list&gt;)       length)
(add-method length (&lt;string&gt;)     string-length)
(add-method length (&lt;bytevector&gt;) bytevector-length)

(length &quot;ciao&quot;)
</pre></div>

<p>the syntax uses of <code>add-method</code> would add methods implementations for
<code>length</code> to the expand&ndash;time state of the classes <code>&lt;list&gt;</code>, <code>&lt;string&gt;</code>
and <code>&lt;bytevector&gt;</code>; then the expression would be transformed to:
</p>
<div class="example">
<pre class="example">(string-length &quot;ciao&quot;)
</pre></div>

<p>The library <code>(nausicaa)</code> already implements multimethods; in that
implementation we could do:
</p>
<div class="example">
<pre class="example">(define-generic length (obj))

(add-method length (&lt;list&gt;)       length)
(add-method length (&lt;string&gt;)     string-length)
(add-method length (&lt;bytevector&gt;) bytevector-length)
</pre></div>

<p>the methods that specialise the generic function <code>length</code> are stored in a table
in the state of the generic function; dispatching happens at run&ndash;time.  No matter
what the type of the arguments, all the methods go in the state of the generic
function <code>length</code> which is associated to the identifier <code>length</code>.
</p>
<p>In the hypothetical solution above, the difference would be that:
</p>
<ul>
<li> The method that specialises <code>length</code> for <code>&lt;list&gt;</code> goes in a table associated
to <code>&lt;list&gt;</code>.

</li><li> The method that specialises <code>length</code> for <code>&lt;string&gt;</code> goes in a table
associated to <code>&lt;string&gt;</code>.

</li><li> The method that specialises <code>length</code> for <code>&lt;bytevector&gt;</code> goes in a table
associated to <code>&lt;bytevector&gt;</code>.
</li></ul>

<p>not a big difference.  Most likely, much of the code that implements run&ndash;time
dispatching for multimethods in <code>(nausicaa)</code> can be adapted to implement
expand&ndash;time dispatching integrated in the expander.
</p>
<p>Also, the expander code that parses <code>(&quot;ciao&quot; length)</code> as a &ldquo;special syntax&rdquo;
can be adapted to parse <code>(length &quot;ciao&quot;)</code> as a special syntax and fall back to
the usual expression expansion when needed.
</p>
<hr>
<div class="header">
<p>
Next: <a href="2015-February-14.html#g_t2015-February-14" accesskey="n" rel="next">2015 February 14</a>, Previous: <a href="2015-February-15.html#g_t2015-February-15" accesskey="p" rel="prev">2015 February 15</a>, Up: <a href="2015.html#g_t2015" accesskey="u" rel="up">2015</a> &nbsp; [<a href="concept-index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="concept-index.html#concept-index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
