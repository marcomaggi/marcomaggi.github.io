<html lang="en">
<head>
<title>2016 Jun 25 - Marco's Weblog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Marco's Weblog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="2016.html#g_t2016" title="2016">
<link rel="next" href="2016-Jun-18.html#g_t2016-Jun-18" title="2016 Jun 18">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2015, 2016 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="weblog.css">
</head>
<body>
<div class="node">
<a name="g_t2016-Jun-25"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="2016-Jun-18.html#g_t2016-Jun-18">2016 Jun 18</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="2016.html#g_t2016">2016</a>
<hr>
</div>

<h3 class="unnumberedsec">Super-types and sub-types</h3>

<div align="center">Posted on Sat Jun 25, 2016</div>

   <p>More work in the &lsquo;<samp><span class="samp">typed-language</span></samp>&rsquo;
<a href="https://github.com/marcomaggi/vicare/tree/typed-language.marcomaggi-2015-11-18">branch</a> of <a href="References.html#References">Vicare</a>, for both the expander and the built&ndash;in types
infrastructure.

   <p>Everything I discuss here is relative to code in the head of the
&lsquo;<samp><span class="samp">typed-language</span></samp>&rsquo; branch.

<!--  -->
<h4 class="unnumberedsubsec">Super&ndash;types and sub&ndash;types</h4>

<p>Done a crackdown on the machinery that determines when two expand&ndash;time type
specifications, or two run&ndash;time type descriptors, are super&ndash;type and sub&ndash;type. 
There are plenty of built&ndash;in syntaxes to check this relation.

   <p>Given the core types <code>&lt;number&gt;</code>, <code>&lt;fixnum&gt;</code> and <code>&lt;string&gt;</code>, we have:

<pre class="lisp">     (type-annotation-matching &lt;number&gt; &lt;fixnum&gt;)    &rArr; exact-match
     (type-annotation-matching &lt;fixnum&gt; &lt;number&gt;)    &rArr; possible-match
     (type-annotation-matching &lt;number&gt; &lt;string&gt;)    &rArr; no-match
</pre>
   <p class="noindent">it means that the following code will type&ndash;check at expand&ndash;time, and no type
checking is performed at run&ndash;time on the operand &lsquo;<samp><span class="samp">123</span></samp>&rsquo;:

<pre class="lisp">     (define (fun {O &lt;number&gt;})
       O)
     
     (fun 123)       &rArr; 123
</pre>
   <p class="noindent">the following code will type&ndash;check at expand&ndash;time, and the operand in the
application of <code>fun</code> is checked at run&ndash;time:

<pre class="lisp">     (define (fun {O &lt;fixnum&gt;})
       O)
     
     (define ({rand &lt;number&gt;})
       123)
     
     (fun (rand))
</pre>
   <p class="noindent">the following code will raise an expand&ndash;time violation:

<pre class="lisp">     (define (fun {O &lt;fixnum&gt;})
       O)
     
     (fun "ciao")    error--&gt; expand-time type mismatch
</pre>
   <p>There are many type annotation variants, so there are many rules to compare type
specifications and type descriptors.  Special care is needed when defining type
annotations for closure objects that must be used as operands in function calls.  The
general rule is this:

<pre class="lisp">     (type-annotation-super-and-sub? &lt;number&gt; &lt;fixnum&gt;)      &rArr; #t
     (type-annotation-super-and-sub? &lt;struct&gt; &lt;record&gt;)      &rArr; #t
     
     (type-annotation-super-and-sub?
        (lambda (&lt;fixnum&gt;) =&gt; (&lt;struct&gt;))
        (lambda (&lt;number&gt;) =&gt; (&lt;record&gt;)))   &rArr; #t
</pre>
   <p class="noindent">we see that:

     <ul>
<li>The argument of the super&ndash;type's closure (<code>&lt;fixnum&gt;</code>) is a sub&ndash;type of the
argument of the sub&ndash;type's closure (<code>&lt;number&gt;</code>).

     <li>The return value of the super&ndash;type's closure (<code>&lt;struct&gt;</code>) is a super&ndash;type of
the return value of the sub&ndash;type's closure (<code>&lt;record&gt;</code>). 
</ul>

<p class="noindent">in other words: the super&ndash;type's argument must be equal or stricter; the sub&ndash;type's
return value must be equal or stricter.

   <p>Scheme is, originally, a dynamically typed language; so, sometimes, we may need a
type specification describing a closure object that accepts arguments of any type. 
Given the comparison rules for super&ndash;types and sub&ndash;types, this appears problematic
because the super&ndash;type's arguments must have types that are sub&ndash;types of any other
type.

   <p>For this we can use the special type annotation <code>&lt;bottom&gt;</code>, which is a
conventional sub&ndash;type of all the other types; for example the type annotation:

<pre class="lisp">     (define-type &lt;my-func&gt;
       (lambda (&lt;bottom&gt;) =&gt; (&lt;string&gt;)))
</pre>
   <p class="noindent">is a super&ndash;type of both <code>number-&gt;string</code> and <code>symbol-&gt;string</code>, because
<code>&lt;number&gt;</code> and <code>&lt;symbol&gt;</code> are super&ndash;types of <code>&lt;bottom&gt;</code>.

   <p>In addition, the improper list <code>&lt;bottom&gt;</code> is now used to represent the type of
return values for expressions that do not return (for example: they raise an
exception).  So now:

<pre class="lisp">     (type-of error)
     &rArr; #[signature ((lambda ((or &lt;false&gt; &lt;symbol&gt; &lt;string&gt;) &lt;string&gt; . &lt;list&gt;)
                            =&gt; &lt;bottom&gt;))]
     
     (type-of (error #f "wrong"))
     &rArr; #[signature &lt;bottom&gt;]
</pre>
   <p class="noindent">in previous revisions Vicare used <code>&lt;no-return&gt;</code> for this purpose, but now
<code>&lt;no-return&gt;</code> has been removed.

<!--  -->
<h4 class="unnumberedsubsec">Farewell <code>slot-set</code> and <code>slot-ref!</code></h4>

<p>I have removed <code>slot-set</code> and <code>slot-ref!</code>; with the typed language's
dot notation to access record's and struct's fields, there is no need to keep such
syntaxes.  Also, <em>they</em> say that having a uniform syntax to access an object's
interface makes code more maintainable
(<a href="https://en.wikipedia.org/wiki/Uniform_access_principle">Uniform access principle</a>).

<!--  -->
<h4 class="unnumberedsubsec">New <code>constructor-signature</code> clause for <code>define-record-type</code></h4>

<p>I have implemented the <code>constructor-signature</code> clause to specify the type
signature of record&ndash;type constructor procedures:

<pre class="lisp">     (define-record-type &lt;alpha&gt;
       (fields {A &lt;fixnum&gt;}
               {B &lt;string&gt;})
       (protocol
         (lambda (make-record)
           (lambda (A)
             (make-record A (number-&gt;string A)))))
       (constructor-signature
         (lambda (&lt;fixnum&gt;) =&gt; (&lt;alpha&gt;))))
</pre>
   <!-- page -->
   </body></html>

