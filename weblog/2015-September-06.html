<html lang="en">
<head>
<title>2015 September 06 - Marco's Weblog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Marco's Weblog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="2015.html#g_t2015" title="2015">
<link rel="prev" href="2015-September-08.html#g_t2015-September-08" title="2015 September 08">
<link rel="next" href="2015-July-02.html#g_t2015-July-02" title="2015 July 02">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2015 by Marco Maggi <marco.maggi-ipsu@poste.it>

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with Invariant Sections being ``GNU Free Documentation
     License'' and ``GNU General Public License'', no Front--Cover
     Texts, and no Back--Cover Texts.  A copy of the license is
     included in the section entitled ``GNU Free Documentation
     License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link rel="stylesheet" type="text/css" href="weblog.css">
</head>
<body>
<div class="node">
<a name="g_t2015-September-06"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="2015-July-02.html#g_t2015-July-02">2015 July 02</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="2015-September-08.html#g_t2015-September-08">2015 September 08</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="2015.html#g_t2015">2015</a>
<hr>
</div>

<h3 class="unnumberedsec">Harbinger of Failure</h3>

<div align="center">Posted on September 6, 2015</div>

   <p>It has been a <strong>VERY HOT SUMMER</strong>, my brain has gone in overheating; I am going
to discharge some s#!t in this post: bear with it, or skip a section, or go away now.

<!--  -->
<h4 class="unnumberedsubsec">Dirt discharging</h4>

<p>Recently, through <a href="https://news.ycombinator.com/item?id=9839344">Hacker News</a>, I
have come in contact with the concept of
<a href="https://marketing.wharton.upenn.edu/mktg/assets/File/Anderson-Eric%202015_02_05_Harbingers.pdf">Harbingers of Failure</a>; according to this theory: customers that systematically
purchase new products that flop; when considered as a group, their collective
behaviour is a predictor of product failure.  As a single person I am statistically
irrelevant, but if I think of the computer programming technologies I have dived in,
I feel like one of those people.  Sheesh<small class="dots">...</small> existentially scary!

   <p>Back when I was a kid: Computer Programming fascinated me; I tried to learn something
on the Commodore 64, but, alone without guidance, I was unable to do much.  Later, at
university, Software Engineering interested me; I decided to learn generic computer
programming to have &ldquo;something more&rdquo;, in addition to what I actually wanted to do
as professional work.  While studying engineering, I also dreamt of buying (yes)
high&ndash;quality libraries for numerical methods and then to interface them to a
powerful programming language, to build good tools for freelancing: a personal
competitive advantage; in retrospect: a stupid idea.

   <p>After all these years, I can tell that I am not that good at programming.  I can
handle only that much complexity and abstraction, so I need a programming language
that allows me to clearly organise concepts my way; otherwise I can do nothing. 
Syntax is also of paramount importance; this is a problem I also have with
mathematics: there are expression notations that consume too much of my brain power
(most likely, the slots in my very short&ndash;term memory) and too little is left to
process the meaning; so I need the &ldquo;right&rdquo; notation, otherwise I can do nothing.

   <p>When studying Mathematics, Physics and applied engineering disciplines, I always
struggled to find the right mathematical notation for my brain (I made enemies this
way: professors and their minions kept demanding things written &ldquo;the way I do&rdquo;,
which obviously was not my way).  Likewise, I have been in search of the &ldquo;right&rdquo;
programming language.

   <p>At university, the first course on computers (the italian denomination was
&ldquo;Fondamenti di Informatica&rdquo;) suggested Pascal as programming language in which to
develop the project for the final exam; but there was freedom; I ditched Pascal and
chose C.  That was a good choice (when I think of Borand's Turbo C: I have tears in
my eyes).  It was the last good choice.

   <p>Later, I laid my eyes on Lisp (shoot me now!).  I borrowed an introductive book on
Common Lisp from the library; I had no way to try the language; reading about
<code>lambda</code> and <code>mapcar</code> made my head spin.  I kept a bookmark in my brain to
come back to it in some future.

   <p>Later I wanted to learn a programming language to do stuff without too much effort: I
chose <a href="http://www.tcl.tk/">Tcl</a>.  Back then, Tk was one of the most advanced free
software GUI toolkits available on the GNU+Linux platform.  Tcl is hated by many; it
is not exactly the most effective language; it had some successful applications, but
today it has very small commercial appeal.  For certain it has limitations.  I stuck
with it for a while, because I learned much using it; I wrote some Tcl package and
some interfaces to C language libraries.  I could have learned much using other
languages, too.  IIRC, when I started using it, the Tcl core was at version 8.3 or
8.4, many years later it is at version 8.6: it is a <em>mature</em> software.  Not
mainstream.

   <p>Later I wanted to drop Tcl and try something different: I learned that Scheme exists
and it is a Lisp; I learned that <a href="http://www.gnu.org/software/guile/guile.html">GUILE</a> is a Scheme implementation part of the GNU Project.  Here I was.  I learned
what I think is a decent amount of the language and started writing some extensions
for it: Zlib bindings; BZip2 bindings; CSV files; email addresses processing;
<a href="http://morihit.net/ezxdisp/">Ezxdisp</a> bindings; Libgcrypt bindings; GD bindings;
GMP, MPFR, MPC, MPFI bindings; GSL bindings; Libiconv bindings; OpenSSL bindings;
Nettle bindings; Nuri bindings; Tcl bindings; some other stuff.

   <p>At some point I felt that GUILE was going nowhere (one of the maintainers
<a href="http://lists.gnu.org/archive/html/guile-user/2007-12/msg00029.html">asked</a> for a
ping from people still actively working of GUILE projects; I was the only one
answering with availability of extensions for the then&ndash;current GUILE version); I
tried to propose
<a href="http://lists.gnu.org/archive/html/guile-user/2007-12/msg00002.html">something</a>
but went down in flames (no clear direction for the project was built and discussed
by people more competent than me).  I thought: if I have to contribute in developing
a project I need to have faith into its future; I had it no more for GUILE.  I do not
think GUILE can be considered mainstream (look at other &ldquo;languages for extensions&rdquo;
like <a href="http://www.lua.org/">LUA</a>).

   <p>For a while I tried PLT Scheme, now evolved into <a href="http://racket-lang.org/">Racket</a>.  It appears to me that Racket is one of the most successful Lisp languages;
for sure the most successful Scheme (or derivative of Scheme); sticking with Racket
would have been a good choice.  Instead, I was defeated by its complexity; for some
reason, just &ldquo;passively&rdquo; using it was not enough to satisfy me; I had to actively
understand it.  No, this is not it.  It is not about understanding or not, it is
about having to bend my mind to accept what Racket is and how it works (because it
works, not doubt about it), even if it is not the way my mind works.  I dropped it.

   <p>At some point, I wanted to try something different.  So I got an interest in
<a href="http://nekovm.org/">Neko</a><small class="dots">...</small> I bet you never heard about it.  From the web
site:

   <blockquote>
Neko is a high&ndash;level dynamically typed programming language.  It can be used as an
embedded scripting language.  It has been designed to provide a common runtime for
several different languages.  Learning and using Neko is very easy.  You can easily
extend the language with C libraries.  You can also write generators from your own
language to Neko and then use the Neko Runtime to compile, run, and access existing
libraries. 
</blockquote>

   <p>I wrote some libraries for it and (crazyness) translated documentation in
<a href="https://github.com/marcomaggi/nimby-doc/blob/master/src/neko.texi">Texinfo format</a>.  I realised that Neko was not going to be adopted for something useful; so I
dropped it.

   <p>Back to Scheme.  I like Scheme.  <acronym>R6RS</acronym> had been ratified and implementations
started to pop up.  I had some enthusiasm for it, so I dove in.  It hurts me to list
all the things I have done to contribute in building a community around <acronym>R6RS</acronym>
implementations; so I am not going to do it.  <acronym>R6RS</acronym> tanked.  But I am still here
developing a Scheme implementation of which I am, in practice, the only user.

<!--  -->
<h4 class="unnumberedsubsec">Vicare/Tcl</h4>

<p>I have written a library <a href="http://github.com/marcomaggi/vicare-tcl/">binding</a> for
Vicare Scheme to Tcl version 8.6.4.  It works with the head of the <code>master</code> branch. 
This binding makes it possible to run scripts in a Tcl interpreter; it allows to load
the Tk toolkit library and interface Vicare to it.  Not the best way to write
applications with <acronym>GUI</acronym>.  Whatever<small class="dots">...</small>

<!--  -->
<h4 class="unnumberedsubsec">Container libraries</h4>

<p>Lately I have been developing container libraries.  Containers or collections or
whatever we want to call them are basic tools that should be present in any
respectable programming language's standard library.  The support for <acronym>R6RS</acronym>
already makes available built&ndash;in strings, lists, vectors, hashtables and
bytevectors; Vicare extends the standard features with more functions for all of
these containers.  In addition, the following libraries are available:

     <dl>
<dt><code>(vicare containers weak-hashtables)</code><dd>Like hashtables, but references to values are &ldquo;weak&rdquo;.  It means that storing a
value in a weak hashtable does not prevent it from being garbage collected.

     <br><dt><code>(vicare containers bytevector-compounds)</code><dd>A &ldquo;bytevector compound&rdquo; is a sequence of octets split into a sequence of
bytevectors.  Bytevector compounds have a special <acronym>API</acronym> to handle the sequence of
octets as a First&ndash;in First&ndash;out queue.

     <br><dt><code>(vicare containers char-sets)</code><dd>Sets of objects satisfying the predicate <code>char?</code>.  It is conceptually based on
<acronym>SRFI</acronym>-14, but it has extensions.

     <br><dt><code>(vicare containers binary-heaps)</code><dd>Binary heaps allow collecting objects according to a sorting function.  They allow
the extraction of the &ldquo;lesser&rdquo; contained object.  They are useful for sorting.

     <br><dt><code>(vicare containers chains)</code><dd>A &ldquo;chain&rdquo; is a doubly&ndash;linked list.  Being doubly&ndash;linked, both forwards and
backwards iterations are possible.

     <br><dt><code>(vicare containers stacks)</code><dd>Stack objects are containers with efficient insertion and extraction in Last&ndash;In
First&ndash;Out mode.

     <br><dt><code>(vicare containers queues)</code><dd>Queue objects are containers with efficient insertion and extraction in First&ndash;In
First&ndash;Out mode.

     <br><dt><code>(vicare containers deques)</code><dd>Deque objects, or double&ndash;ended queues, are containers with efficient insertion and
extraction at both ends.

     <br><dt><code>(vicare containers dynamic-arrays)</code><dd>Dynamic array objects offer an <acronym>API</acronym> similar to those of vectors, but with efficient
dynamic resizing.

     <br><dt><code>(vicare containers binary-search-trees)</code><dd>Binary search trees implement storage of objects in a way that allows &ldquo;fast&rdquo;
searching of members.  The objects need to have a &ldquo;less than&rdquo; comparison function. 
This library implements basic data types and functions; no balancing strategies are
implemented here.

     <br><dt><code>(vicare containers sets-and-bags)</code><dd>This library is actually the reference implementation of <acronym>SRFI</acronym>-113 adapted to
Vicare.  Sets and bags (also known as multisets) are unordered collections that
can contain any Scheme object.

     <br><dt><code>(vicare containers ilists)</code><dd>This library implements immutable lists.  It is actually the reference implementation
of <acronym>SRFI</acronym>-116 adapted to Vicare.

     <br><dt><code>(vicare containers ralists)</code><dd>This library implements random&ndash;access lists.  It is actually the reference
implementation of <acronym>SRFI</acronym>-101 adapted to Vicare. 
</dl>

   <p>The documentation for the container libraries is in the file <samp><span class="file">vicare-libs</span></samp>. 
Let's not forget the <a href="https://github.com/marcomaggi/fectors/tree/vicare-scheme">fectors</a> and <a href="https://github.com/marcomaggi/pfds/tree/vicare-scheme">pfds</a>
projects, which provide functional data structures.

<!--  -->
<h4 class="unnumberedsubsec"><code>new</code> and <code>delete</code></h4>

<p>At some point I wanted a set of syntaxes to perform operations on structs, records
and Nausicaa's classes through the use of the type identifier.  The idea was that: by
importing <code>(rnrs)</code> as base language and the syntactic identifier of a type from
a library, every operation on type instances must be possible.

   <p>The idea tastes good, but it leads to some weird syntaxes; a particular case is the
constructor call.  If we define a record type:

<pre class="lisp">     (define-record-type duo
       (fields one two))
</pre>
   <p class="noindent">we can call the constructor function as follows:

<pre class="lisp">     (make-duo 1 2)  &rArr; #[record duo one=1 two=2]
</pre>
   <p class="noindent">obviously, if the type definition is in a library, we have to export the syntactic
binding <code>make-duo</code>.  But what if a special syntax allows us to call the
constructor by specifying only the syntactic identifier <code>duo</code>?  Here is the
weird syntax:

<pre class="lisp">     (duo (1 2))  &rArr; #[record duo one=1 two=2]
</pre>
   <p class="noindent">this is actually implemented and it works for structs, records and Nausicaa's
classes.

   <p>Lately I have changed my mind a bit.  While, for an ideal world, I still like the
idea of coding operations using only the type identifier, I consider the weird
syntaxes as too much of a price: the expression <code>(duo (1 2))</code> does not really
look like a constructor call.  A more Schemey syntax, or at least Common Lispy
syntax, causes less confusion when parsing code with human eyes.

   <p>The expander already has syntaxes for dealing with type name syntactic identifiers:
<code>type-descriptor</code>, <code>is-a?</code>, <code>slot-ref</code>, <code>slot-set!</code>; they
are exported by <code>(vicare)</code>.  In the current head of the <a href="References.html#References">master</a> branch, I
have added two new syntaxes: <code>new</code> and <code>delete</code>; these syntaxes take
their name from the the C++ and D operators, everybody knows these names. 
<code>new</code> is for calling the default constructor and <code>delete</code> is for
calling the destructor.

   <p>For example, with structs:

<pre class="lisp">     (import (vicare))
     
     (define-struct duo (one two))
     
     (define (duo-destructor stru)
       (fprintf (current-error-port) "destroying ~s\n" stru))
     
     (set-struct-type-destructor! (type-descriptor duo)
       duo-destructor)
     
     (define O
       (new duo 1 2))
     
     (delete O)
     -| destroying #[struct duo one=1 two=2]
</pre>
   <p class="noindent">and with records:

<pre class="lisp">     (import (vicare))
     
     (define-record-type duo
       (fields one two))
     
     (define (duo-destructor reco)
       (fprintf (current-error-port) "destroying ~s\n" stru))
     
     (record-type-destructor-set! (type-descriptor duo)
       duo-destructor)
     
     (define O
       (new duo 1 2))
     
     (delete O)
     -| destroying #[record duo one=1 two=2]
</pre>
   <p>I will progressively remove the weird syntaxes from the expander.

<!--  -->
<h4 class="unnumberedsubsec">About Nausicaa</h4>

<p>I am letting the Nausicaa libraries fall behind the development of the libraries
based on <code>(vicare)</code>; I am not abandoning them.  It is just that, while I am
thinking about how to implement the typed language in the expander, it makes no sense
to change Nausicaa and change it again, and again, and again.  When the design of the
typed language reaches some sort of stability, I will update Nausicaa.

<!--  -->
<h4 class="unnumberedsubsec">Subreddit</h4>

<p>Just for fun I have created a <a href="https://www.reddit.com/r/vicarescheme/">subreddit</a>
for discussions about Vicare.

<!-- page -->
   </body></html>

